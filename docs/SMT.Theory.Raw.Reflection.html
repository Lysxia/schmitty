<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SMT.Theory.Raw.Reflection</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--guardedness</a> <a id="27" class="Symbol">#-}</a>

<a id="32" class="Comment">--------------------------------------------------------------------------------</a>
<a id="113" class="Comment">-- Schmitty the Solver</a>
<a id="136" class="Comment">--</a>
<a id="139" class="Comment">-- Defines `reflectToRawScript`, which converts reflected Agda syntax to scripts</a>
<a id="220" class="Comment">-- in the raw theory.</a>
<a id="242" class="Comment">--------------------------------------------------------------------------------</a>

<a id="324" class="Keyword">module</a> <a id="331" href="SMT.Theory.Raw.Reflection.html" class="Module">SMT.Theory.Raw.Reflection</a> <a id="357" class="Keyword">where</a>

<a id="364" class="Keyword">open</a> <a id="369" class="Keyword">import</a> <a id="376" href="Category.Monad.html" class="Module">Category.Monad</a>
<a id="391" class="Keyword">open</a> <a id="396" class="Keyword">import</a> <a id="403" href="Data.Bool.html" class="Module">Data.Bool</a> <a id="413" class="Symbol">as</a> <a id="416" class="Module">Bool</a> <a id="421" class="Keyword">using</a> <a id="427" class="Symbol">(</a><a id="428" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="432" class="Symbol">;</a> <a id="434" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="438" class="Symbol">;</a> <a id="440" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="445" class="Symbol">)</a>
<a id="447" class="Keyword">open</a> <a id="452" class="Keyword">import</a> <a id="459" href="Data.Fin.html" class="Module">Data.Fin</a> <a id="468" class="Symbol">as</a> <a id="471" class="Module">Fin</a> <a id="475" class="Keyword">using</a> <a id="481" class="Symbol">(</a><a id="482" href="Data.Fin.Base.html#1126" class="Datatype">Fin</a><a id="485" class="Symbol">;</a> <a id="487" href="Data.Fin.Base.html#1179" class="InductiveConstructor">suc</a><a id="490" class="Symbol">;</a> <a id="492" href="Data.Fin.Base.html#1148" class="InductiveConstructor">zero</a><a id="496" class="Symbol">)</a>
<a id="498" class="Keyword">open</a> <a id="503" class="Keyword">import</a> <a id="510" href="Data.Integer.html" class="Module">Data.Integer</a> <a id="523" class="Symbol">as</a> <a id="526" class="Module">Int</a> <a id="530" class="Keyword">using</a> <a id="536" class="Symbol">(</a><a id="537" href="Agda.Builtin.Int.html#246" class="Datatype">ℤ</a><a id="538" class="Symbol">;</a> <a id="540" href="Agda.Builtin.Int.html#264" class="InductiveConstructor">+_</a><a id="542" class="Symbol">;</a> <a id="544" href="Agda.Builtin.Int.html#291" class="InductiveConstructor">-[1+_]</a><a id="550" class="Symbol">)</a>
<a id="552" class="Keyword">open</a> <a id="557" class="Keyword">import</a> <a id="564" href="Data.List.html" class="Module">Data.List</a> <a id="574" class="Symbol">as</a> <a id="577" class="Module">List</a> <a id="582" class="Keyword">using</a> <a id="588" class="Symbol">(</a><a id="589" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="593" class="Symbol">;</a> <a id="595" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="598" class="Symbol">;</a> <a id="600" href="Data.List.Base.html#10383" class="InductiveConstructor">[]</a><a id="602" class="Symbol">)</a>
<a id="604" class="Keyword">open</a> <a id="609" class="Keyword">import</a> <a id="616" href="Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="645" class="Keyword">using</a> <a id="651" class="Symbol">(</a><a id="652" href="Data.List.Relation.Unary.All.html#1444" class="Datatype">All</a><a id="655" class="Symbol">;</a> <a id="657" href="Data.List.Relation.Unary.All.html#1524" class="InductiveConstructor Operator">_∷_</a><a id="660" class="Symbol">;</a> <a id="662" href="Data.List.Relation.Unary.All.html#1507" class="InductiveConstructor">[]</a><a id="664" class="Symbol">)</a>
<a id="666" class="Keyword">open</a> <a id="671" class="Keyword">import</a> <a id="678" href="Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="707" class="Keyword">using</a> <a id="713" class="Symbol">(</a><a id="714" href="Data.List.Relation.Unary.Any.html#1219" class="InductiveConstructor">here</a><a id="718" class="Symbol">;</a> <a id="720" href="Data.List.Relation.Unary.Any.html#1272" class="InductiveConstructor">there</a><a id="725" class="Symbol">)</a>
<a id="727" class="Keyword">open</a> <a id="732" class="Keyword">import</a> <a id="739" href="Data.List.NonEmpty.html" class="Module">Data.List.NonEmpty</a> <a id="758" class="Symbol">as</a> <a id="761" class="Module">List⁺</a> <a id="767" class="Keyword">using</a> <a id="773" class="Symbol">(</a><a id="774" href="Data.List.NonEmpty.Base.html#1079" class="Record">List⁺</a><a id="779" class="Symbol">;</a> <a id="781" href="Data.List.NonEmpty.Base.html#1125" class="InductiveConstructor Operator">_∷_</a><a id="784" class="Symbol">)</a>
<a id="786" class="Keyword">open</a> <a id="791" class="Keyword">import</a> <a id="798" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="807" class="Symbol">as</a> <a id="810" class="Module">Nat</a> <a id="814" class="Keyword">using</a> <a id="820" class="Symbol">(</a><a id="821" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="822" class="Symbol">;</a> <a id="824" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="828" class="Symbol">;</a> <a id="830" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="833" class="Symbol">;</a> <a id="835" href="Data.Nat.Base.html#2874" class="Primitive Operator">_∸_</a><a id="838" class="Symbol">)</a>
<a id="840" class="Keyword">import</a> <a id="847" href="Data.Nat.Literals.html" class="Module">Data.Nat.Literals</a> <a id="865" class="Symbol">as</a> <a id="868" class="Module">NatLits</a> <a id="876" class="Keyword">using</a> <a id="882" class="Symbol">(</a><a id="883" href="Data.Nat.Literals.html#353" class="Function">number</a><a id="889" class="Symbol">)</a>
<a id="891" class="Keyword">open</a> <a id="896" class="Keyword">import</a> <a id="903" href="Data.Product.html" class="Module">Data.Product</a> <a id="916" class="Symbol">as</a> <a id="919" class="Module">Prod</a> <a id="924" class="Keyword">using</a> <a id="930" class="Symbol">(</a><a id="931" href="Agda.Builtin.Sigma.html#166" class="Record">Σ</a><a id="932" class="Symbol">;</a> <a id="934" href="Data.Product.html#1369" class="Function">∃</a><a id="935" class="Symbol">;</a> <a id="937" href="Data.Product.html#916" class="Function">Σ-syntax</a><a id="945" class="Symbol">;</a> <a id="947" href="Data.Product.html#1806" class="Function">∃-syntax</a><a id="955" class="Symbol">;</a> <a id="957" href="Data.Product.html#1167" class="Function Operator">_×_</a><a id="960" class="Symbol">;</a> <a id="962" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="965" class="Symbol">;</a> <a id="967" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="972" class="Symbol">;</a> <a id="974" href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="979" class="Symbol">)</a>
<a id="981" class="Keyword">open</a> <a id="986" class="Keyword">import</a> <a id="993" href="Data.String.html" class="Module">Data.String</a> <a id="1005" class="Keyword">using</a> <a id="1011" class="Symbol">(</a><a id="1012" href="Agda.Builtin.String.html#336" class="Postulate">String</a><a id="1018" class="Symbol">)</a>
<a id="1020" class="Keyword">open</a> <a id="1025" class="Keyword">import</a> <a id="1032" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="1042" class="Symbol">as</a> <a id="1045" class="Module">Unit</a> <a id="1050" class="Keyword">using</a> <a id="1056" class="Symbol">(</a><a id="1057" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="1058" class="Symbol">)</a>
<a id="1060" class="Keyword">open</a> <a id="1065" class="Keyword">import</a> <a id="1072" href="Function.html" class="Module">Function</a>
<a id="1081" class="Keyword">open</a> <a id="1086" class="Keyword">import</a> <a id="1093" href="Level.html" class="Module">Level</a> <a id="1099" class="Keyword">using</a> <a id="1105" class="Symbol">(</a><a id="1106" href="Agda.Primitive.html#597" class="Postulate">Level</a><a id="1111" class="Symbol">)</a>
<a id="1113" class="Keyword">open</a> <a id="1118" class="Keyword">import</a> <a id="1125" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1163" class="Symbol">as</a> <a id="1166" class="Module">PropEq</a> <a id="1173" class="Keyword">using</a> <a id="1179" class="Symbol">(</a><a id="1180" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="1183" class="Symbol">;</a> <a id="1185" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="1189" class="Symbol">)</a>
<a id="1191" class="Keyword">open</a> <a id="1196" class="Keyword">import</a> <a id="1203" href="Reflection.html" class="Module">Reflection</a> <a id="1214" class="Symbol">as</a> <a id="1217" class="Module">Rfl</a> <a id="1221" class="Keyword">hiding</a> <a id="1228" class="Symbol">(</a><a id="1229" href="Agda.Builtin.Reflection.html#8261" class="Postulate">return</a><a id="1235" class="Symbol">;</a> <a id="1237" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">_&gt;&gt;=_</a><a id="1242" class="Symbol">)</a>
<a id="1244" class="Keyword">import</a> <a id="1251" href="Reflection.TypeChecking.Monad.Categorical.html" class="Module">Reflection.TypeChecking.Monad.Categorical</a> <a id="1293" class="Symbol">as</a> <a id="1296" class="Module">TC</a>
<a id="1299" class="Keyword">open</a> <a id="1304" class="Keyword">import</a> <a id="1311" href="Reflection.DeBruijn.html" class="Module">Reflection.DeBruijn</a> <a id="1331" class="Keyword">using</a> <a id="1337" class="Symbol">(</a><a id="1338" href="Reflection.DeBruijn.html#2006" class="Function">η-expand</a><a id="1346" class="Symbol">;</a> <a id="1348" href="Reflection.DeBruijn.html#3921" class="Function Operator">_∈FV_</a><a id="1353" class="Symbol">)</a>
<a id="1355" class="Keyword">open</a> <a id="1360" class="Keyword">import</a> <a id="1367" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="1384" class="Keyword">using</a> <a id="1390" class="Symbol">(</a><a id="1391" href="Relation.Nullary.html#656" class="Function Operator">¬_</a><a id="1393" class="Symbol">;</a> <a id="1395" href="Relation.Nullary.html#1511" class="Record">Dec</a><a id="1398" class="Symbol">;</a> <a id="1400" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a><a id="1403" class="Symbol">;</a> <a id="1405" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a><a id="1407" class="Symbol">)</a>
<a id="1409" class="Keyword">open</a> <a id="1414" class="Keyword">import</a> <a id="1421" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a> <a id="1448" class="Keyword">using</a> <a id="1454" class="Symbol">(</a><a id="1455" href="Relation.Nullary.Decidable.Core.html#1027" class="Function">isYes</a><a id="1460" class="Symbol">)</a>
<a id="1462" class="Keyword">open</a> <a id="1467" class="Keyword">import</a> <a id="1474" href="SMT.Theory.html" class="Module">SMT.Theory</a>
<a id="1485" class="Keyword">open</a> <a id="1490" class="Keyword">import</a> <a id="1497" href="SMT.Theory.Raw.Base.html" class="Module">SMT.Theory.Raw.Base</a>

<a id="1518" class="Keyword">open</a> <a id="1523" class="Keyword">import</a> <a id="1530" href="Agda.Builtin.FromNat.html" class="Module">Agda.Builtin.FromNat</a>
<a id="1551" class="Keyword">open</a> <a id="1556" class="Keyword">import</a> <a id="1563" href="Agda.Builtin.FromNeg.html" class="Module">Agda.Builtin.FromNeg</a>

<a id="1585" class="Keyword">instance</a> <a id="1594" href="SMT.Theory.Raw.Reflection.html#1594" class="Function">_</a> <a id="1596" class="Symbol">=</a> <a id="1598" href="Data.Nat.Literals.html#353" class="Function">NatLits.number</a>

<a id="1614" class="Keyword">private</a>
  <a id="1624" class="Keyword">open</a> <a id="1629" class="Keyword">module</a> <a id="TCMonad"></a><a id="1636" href="SMT.Theory.Raw.Reflection.html#1636" class="Module">TCMonad</a> <a id="1644" class="Symbol">{</a><a id="1645" href="SMT.Theory.Raw.Reflection.html#1645" class="Bound">ℓ</a><a id="1646" class="Symbol">}</a> <a id="1648" class="Symbol">=</a> <a id="1650" href="Category.Monad.html#832" class="Module">Category.Monad.RawMonad</a> <a id="1674" class="Symbol">{</a><a id="1675" href="SMT.Theory.Raw.Reflection.html#1645" class="Bound">ℓ</a><a id="1676" class="Symbol">}</a> <a id="1678" href="Reflection.TypeChecking.Monad.Categorical.html#1061" class="Function">TC.monad</a> <a id="1687" class="Keyword">renaming</a> <a id="1696" class="Symbol">(</a><a id="1697" href="Category.Applicative.Indexed.html#1034" class="Function Operator">_⊛_</a> <a id="1701" class="Symbol">to</a> <a id="1704" class="Function Operator">_&lt;*&gt;_</a><a id="1709" class="Symbol">)</a>

<a id="1712" class="Keyword">private</a>
  <a id="1722" class="Keyword">variable</a>
    <a id="1735" href="SMT.Theory.Raw.Reflection.html#1735" class="Generalizable">ℓ</a> <a id="1737" class="Symbol">:</a> <a id="1739" href="Agda.Primitive.html#597" class="Postulate">Level</a>
    <a id="1749" href="SMT.Theory.Raw.Reflection.html#1749" class="Generalizable">A</a> <a id="1751" class="Symbol">:</a> <a id="1753" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="1757" href="SMT.Theory.Raw.Reflection.html#1735" class="Generalizable">ℓ</a>


<a id="1761" class="Keyword">private</a>
  <a id="1771" class="Comment">-- We don&#39;t know the type of raw function symbols, so just look at</a>
  <a id="1840" class="Comment">-- the arguments. Design decision: only keep visible arguments.</a>
  <a id="argTypes"></a><a id="1906" href="SMT.Theory.Raw.Reflection.html#1906" class="Function">argTypes</a> <a id="1915" class="Symbol">:</a> <a id="1917" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="1922" class="Symbol">(</a><a id="1923" href="Agda.Builtin.Reflection.html#3697" class="Datatype">Arg</a> <a id="1927" href="SMT.Theory.Raw.Reflection.html#1749" class="Generalizable">A</a><a id="1928" class="Symbol">)</a> <a id="1930" class="Symbol">→</a> <a id="1932" href="SMT.Theory.Base.html#1984" class="Record">Signature</a> <a id="1942" href="SMT.Theory.Raw.Base.html#1535" class="InductiveConstructor">⋆</a>
  <a id="1946" href="SMT.Theory.Raw.Reflection.html#1906" class="Function">argTypes</a> <a id="1955" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>              <a id="1971" class="Symbol">.</a><a id="1972" href="SMT.Theory.Base.html#2042" class="Field">ArgSorts</a> <a id="1981" class="Symbol">=</a> <a id="1983" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
  <a id="1988" href="SMT.Theory.Raw.Reflection.html#1906" class="Function">argTypes</a> <a id="1997" class="Symbol">(</a><a id="1998" href="Reflection.Argument.html#1209" class="InductiveConstructor">vArg</a> <a id="2003" class="Symbol">_</a> <a id="2005" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2007" href="SMT.Theory.Raw.Reflection.html#2007" class="Bound">args</a><a id="2011" class="Symbol">)</a> <a id="2013" class="Symbol">.</a><a id="2014" href="SMT.Theory.Base.html#2042" class="Field">ArgSorts</a> <a id="2023" class="Symbol">=</a> <a id="2025" href="SMT.Theory.Raw.Base.html#1535" class="InductiveConstructor">⋆</a> <a id="2027" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2029" href="SMT.Theory.Raw.Reflection.html#1906" class="Function">argTypes</a> <a id="2038" href="SMT.Theory.Raw.Reflection.html#2007" class="Bound">args</a> <a id="2043" class="Symbol">.</a><a id="2044" href="SMT.Theory.Base.html#2042" class="Field">ArgSorts</a>
  <a id="2055" href="SMT.Theory.Raw.Reflection.html#1906" class="CatchallClause Function">argTypes</a><a id="2063" class="CatchallClause"> </a><a id="2064" class="CatchallClause Symbol">(_</a><a id="2066" class="CatchallClause">      </a><a id="2072" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="2073" class="CatchallClause"> </a><a id="2074" href="SMT.Theory.Raw.Reflection.html#2074" class="CatchallClause Bound">args</a><a id="2078" class="CatchallClause Symbol">)</a><a id="2079" class="CatchallClause"> </a><a id="2080" class="CatchallClause Symbol">.</a><a id="2081" href="SMT.Theory.Base.html#2042" class="CatchallClause Field">ArgSorts</a> <a id="2090" class="Symbol">=</a>     <a id="2096" href="SMT.Theory.Raw.Reflection.html#1906" class="Function">argTypes</a> <a id="2105" href="SMT.Theory.Raw.Reflection.html#2074" class="Bound">args</a> <a id="2110" class="Symbol">.</a><a id="2111" href="SMT.Theory.Base.html#2042" class="Field">ArgSorts</a>


<a id="reflectToRawVar"></a><a id="2122" href="SMT.Theory.Raw.Reflection.html#2122" class="Function">reflectToRawVar</a> <a id="2138" class="Symbol">:</a> <a id="2140" class="Symbol">(</a><a id="2141" href="SMT.Theory.Raw.Reflection.html#2141" class="Bound">Γ</a> <a id="2143" class="Symbol">:</a> <a id="2145" href="SMT.Theory.Raw.Base.html#3187" class="Function">RawCtxt</a><a id="2152" class="Symbol">)</a> <a id="2154" class="Symbol">(</a><a id="2155" href="SMT.Theory.Raw.Reflection.html#2155" class="Bound">n</a> <a id="2157" class="Symbol">:</a> <a id="2159" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2160" class="Symbol">)</a> <a id="2162" class="Symbol">→</a> <a id="2164" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="2167" class="Symbol">(</a><a id="2168" href="Data.Product.html#1806" class="Function">∃[</a> <a id="2171" href="SMT.Theory.Raw.Reflection.html#2171" class="Bound">σ</a> <a id="2173" href="Data.Product.html#1806" class="Function">]</a> <a id="2175" class="Symbol">(</a><a id="2176" href="SMT.Theory.Raw.Reflection.html#2141" class="Bound">Γ</a> <a id="2178" href="SMT.Theory.Raw.Base.html#3227" class="Function Operator">∋ᵣ</a> <a id="2181" href="SMT.Theory.Raw.Reflection.html#2171" class="Bound">σ</a><a id="2182" class="Symbol">))</a>
<a id="2185" href="SMT.Theory.Raw.Reflection.html#2122" class="Function">reflectToRawVar</a> <a id="2201" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>      <a id="2209" href="SMT.Theory.Raw.Reflection.html#2209" class="Bound">n</a>       <a id="2217" class="Symbol">=</a> <a id="2219" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="2232" class="String">&quot;Variable out of bounds&quot;</a>
<a id="2257" href="SMT.Theory.Raw.Reflection.html#2122" class="Function">reflectToRawVar</a> <a id="2273" class="Symbol">(</a><a id="2274" href="SMT.Theory.Raw.Reflection.html#2274" class="Bound">x</a> <a id="2276" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2278" href="SMT.Theory.Raw.Reflection.html#2278" class="Bound">Γ</a><a id="2279" class="Symbol">)</a> <a id="2281" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="2289" class="Symbol">=</a> <a id="2291" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="2298" class="Symbol">(_</a> <a id="2301" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2303" href="Data.List.Relation.Unary.Any.html#1219" class="InductiveConstructor">here</a> <a id="2308" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="2312" class="Symbol">)</a>
<a id="2314" href="SMT.Theory.Raw.Reflection.html#2122" class="Function">reflectToRawVar</a> <a id="2330" class="Symbol">(</a><a id="2331" href="SMT.Theory.Raw.Reflection.html#2331" class="Bound">x</a> <a id="2333" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2335" href="SMT.Theory.Raw.Reflection.html#2335" class="Bound">Γ</a><a id="2336" class="Symbol">)</a> <a id="2338" class="Symbol">(</a><a id="2339" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2343" href="SMT.Theory.Raw.Reflection.html#2343" class="Bound">n</a><a id="2344" class="Symbol">)</a> <a id="2346" class="Symbol">=</a> <a id="2348" class="Keyword">do</a>
  <a id="2353" href="SMT.Theory.Raw.Reflection.html#2353" class="Bound">σ</a> <a id="2355" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2357" href="SMT.Theory.Raw.Reflection.html#2357" class="Bound">p</a> <a id="2359" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="2361" href="SMT.Theory.Raw.Reflection.html#2122" class="Function">reflectToRawVar</a> <a id="2377" href="SMT.Theory.Raw.Reflection.html#2335" class="Bound">Γ</a> <a id="2379" href="SMT.Theory.Raw.Reflection.html#2343" class="Bound">n</a>
  <a id="2383" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="2390" class="Symbol">(</a><a id="2391" href="SMT.Theory.Raw.Reflection.html#2353" class="Bound">σ</a> <a id="2393" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2395" href="Data.List.Relation.Unary.Any.html#1272" class="InductiveConstructor">there</a> <a id="2401" href="SMT.Theory.Raw.Reflection.html#2357" class="Bound">p</a><a id="2402" class="Symbol">)</a>

<a id="2405" class="Comment">-- | Keep track of which variables are allowed to be used by a script and which are not.</a>
<a id="2494" class="Comment">--   Non-dependent functions are translated to implication, but they still bring a variable</a>
<a id="2586" class="Comment">--   into scope in the reflected syntax. This will be marked &quot;not allowed&quot; for the script.</a>
<a id="AllowedVars"></a><a id="2677" href="SMT.Theory.Raw.Reflection.html#2677" class="Function">AllowedVars</a> <a id="2689" class="Symbol">=</a> <a id="2691" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="2696" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>

<a id="2702" class="Comment">-- | If Γ ⊢ x, then |Γ| ⊢ strengthenVar x, where |Γ| is the restriction of Γ to</a>
<a id="2782" class="Comment">--   only the allowed variables. Fails if x is not an allowed variable.</a>
<a id="strengthenVar"></a><a id="2854" href="SMT.Theory.Raw.Reflection.html#2854" class="Function">strengthenVar</a> <a id="2868" class="Symbol">:</a> <a id="2870" class="Symbol">(</a><a id="2871" href="SMT.Theory.Raw.Reflection.html#2871" class="Bound">fv</a> <a id="2874" class="Symbol">:</a> <a id="2876" href="SMT.Theory.Raw.Reflection.html#2677" class="Function">AllowedVars</a><a id="2887" class="Symbol">)</a> <a id="2889" class="Symbol">(</a><a id="2890" href="SMT.Theory.Raw.Reflection.html#2890" class="Bound">n</a> <a id="2892" class="Symbol">:</a> <a id="2894" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2895" class="Symbol">)</a> <a id="2897" class="Symbol">→</a> <a id="2899" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="2902" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="2904" href="SMT.Theory.Raw.Reflection.html#2854" class="Function">strengthenVar</a> <a id="2918" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>            <a id="2932" class="Symbol">_</a>       <a id="2940" class="Symbol">=</a> <a id="2942" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="2955" class="String">&quot;Free variable in goal&quot;</a>
<a id="2979" href="SMT.Theory.Raw.Reflection.html#2854" class="Function">strengthenVar</a> <a id="2993" class="Symbol">(</a><a id="2994" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="3000" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3002" class="Symbol">_)</a>   <a id="3007" class="Number">0</a>       <a id="3015" class="Symbol">=</a> <a id="3017" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="3024" class="Number">0</a>
<a id="3026" href="SMT.Theory.Raw.Reflection.html#2854" class="Function">strengthenVar</a> <a id="3040" class="Symbol">(</a><a id="3041" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="3047" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3049" class="Symbol">_)</a>   <a id="3054" class="Number">0</a>       <a id="3062" class="Symbol">=</a> <a id="3064" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="3077" class="String">&quot;Dependent quantification in term&quot;</a>
<a id="3112" href="SMT.Theory.Raw.Reflection.html#2854" class="Function">strengthenVar</a> <a id="3126" class="Symbol">(</a><a id="3127" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="3133" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3135" href="SMT.Theory.Raw.Reflection.html#3135" class="Bound">fvs</a><a id="3138" class="Symbol">)</a> <a id="3140" class="Symbol">(</a><a id="3141" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3145" href="SMT.Theory.Raw.Reflection.html#3145" class="Bound">n</a><a id="3146" class="Symbol">)</a> <a id="3148" class="Symbol">=</a> <a id="3150" href="SMT.Theory.Raw.Reflection.html#2854" class="Function">strengthenVar</a> <a id="3164" href="SMT.Theory.Raw.Reflection.html#3135" class="Bound">fvs</a> <a id="3168" href="SMT.Theory.Raw.Reflection.html#3145" class="Bound">n</a>
<a id="3170" href="SMT.Theory.Raw.Reflection.html#2854" class="Function">strengthenVar</a> <a id="3184" class="Symbol">(</a><a id="3185" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="3191" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3193" href="SMT.Theory.Raw.Reflection.html#3193" class="Bound">fvs</a><a id="3196" class="Symbol">)</a> <a id="3198" class="Symbol">(</a><a id="3199" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3203" href="SMT.Theory.Raw.Reflection.html#3203" class="Bound">n</a><a id="3204" class="Symbol">)</a> <a id="3206" class="Symbol">=</a> <a id="3208" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3212" href="Category.Functor.html#608" class="Function Operator">&lt;$&gt;</a> <a id="3216" href="SMT.Theory.Raw.Reflection.html#2854" class="Function">strengthenVar</a> <a id="3230" href="SMT.Theory.Raw.Reflection.html#3193" class="Bound">fvs</a> <a id="3234" href="SMT.Theory.Raw.Reflection.html#3203" class="Bound">n</a>

<a id="3237" class="Comment">-- Placeholder name used as a function symbol of type TERM _ → ⋆ to wrap variables.</a>
<a id="rawVar"></a><a id="3321" href="SMT.Theory.Raw.Reflection.html#3321" class="Function">rawVar</a> <a id="3328" class="Symbol">:</a> <a id="3330" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
<a id="3332" href="SMT.Theory.Raw.Reflection.html#3321" class="Function">rawVar</a> <a id="3339" class="Symbol">=</a> <a id="3341" class="Symbol">_</a>

<a id="3344" class="Keyword">private</a>
  <a id="3354" class="Keyword">pattern</a> <a id="`fromNat"></a><a id="3362" href="SMT.Theory.Raw.Reflection.html#3362" class="InductiveConstructor">`fromNat</a> <a id="3371" class="Symbol">=</a> <a id="3373" class="Keyword">quote</a> <a id="3379" href="Agda.Builtin.FromNat.html#282" class="Field">Number.fromNat</a>
  <a id="3396" class="Keyword">pattern</a> <a id="`fromNeg"></a><a id="3404" href="SMT.Theory.Raw.Reflection.html#3404" class="InductiveConstructor">`fromNeg</a> <a id="3413" class="Symbol">=</a> <a id="3415" class="Keyword">quote</a> <a id="3421" href="Agda.Builtin.FromNeg.html#284" class="Field">Negative.fromNeg</a>

  <a id="3441" class="Keyword">pattern</a> <a id="`Σ"></a><a id="3449" href="SMT.Theory.Raw.Reflection.html#3449" class="InductiveConstructor">`Σ</a>  <a id="3453" href="SMT.Theory.Raw.Reflection.html#3494" class="Bound">a</a> <a id="3455" href="SMT.Theory.Raw.Reflection.html#3503" class="Bound">b</a> <a id="3457" class="Symbol">=</a> <a id="3459" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="3463" class="Symbol">(</a><a id="3464" class="Keyword">quote</a> <a id="3470" href="Agda.Builtin.Sigma.html#166" class="Record">Σ</a><a id="3471" class="Symbol">)</a>        <a id="3480" class="Symbol">(_</a> <a id="3483" class="InductiveConstructor Operator">∷</a> <a id="3485" class="Symbol">_</a> <a id="3487" class="InductiveConstructor Operator">∷</a> <a id="3489" href="Reflection.Argument.html#1209" class="InductiveConstructor">vArg</a> <a id="3494" href="SMT.Theory.Raw.Reflection.html#3494" class="Bound">a</a> <a id="3496" class="InductiveConstructor Operator">∷</a> <a id="3498" href="Reflection.Argument.html#1209" class="InductiveConstructor">vArg</a> <a id="3503" href="SMT.Theory.Raw.Reflection.html#3503" class="Bound">b</a> <a id="3505" class="InductiveConstructor Operator">∷</a> <a id="3507" class="InductiveConstructor">[]</a><a id="3509" class="Symbol">)</a>
  <a id="3513" class="Keyword">pattern</a> <a id="`Σˢ"></a><a id="3521" href="SMT.Theory.Raw.Reflection.html#3521" class="InductiveConstructor">`Σˢ</a> <a id="3525" href="SMT.Theory.Raw.Reflection.html#3566" class="Bound">a</a> <a id="3527" href="SMT.Theory.Raw.Reflection.html#3575" class="Bound">b</a> <a id="3529" class="Symbol">=</a> <a id="3531" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="3535" class="Symbol">(</a><a id="3536" class="Keyword">quote</a> <a id="3542" href="Data.Product.html#916" class="Function">Σ-syntax</a><a id="3550" class="Symbol">)</a> <a id="3552" class="Symbol">(_</a> <a id="3555" class="InductiveConstructor Operator">∷</a> <a id="3557" class="Symbol">_</a> <a id="3559" class="InductiveConstructor Operator">∷</a> <a id="3561" href="Reflection.Argument.html#1209" class="InductiveConstructor">vArg</a> <a id="3566" href="SMT.Theory.Raw.Reflection.html#3566" class="Bound">a</a> <a id="3568" class="InductiveConstructor Operator">∷</a> <a id="3570" href="Reflection.Argument.html#1209" class="InductiveConstructor">vArg</a> <a id="3575" href="SMT.Theory.Raw.Reflection.html#3575" class="Bound">b</a> <a id="3577" class="InductiveConstructor Operator">∷</a> <a id="3579" class="InductiveConstructor">[]</a><a id="3581" class="Symbol">)</a>
  <a id="3585" class="Keyword">pattern</a> <a id="`∃"></a><a id="3593" href="SMT.Theory.Raw.Reflection.html#3593" class="InductiveConstructor">`∃</a>  <a id="3597" href="SMT.Theory.Raw.Reflection.html#3638" class="Bound">a</a> <a id="3599" href="SMT.Theory.Raw.Reflection.html#3647" class="Bound">b</a> <a id="3601" class="Symbol">=</a> <a id="3603" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="3607" class="Symbol">(</a><a id="3608" class="Keyword">quote</a> <a id="3614" href="Data.Product.html#1369" class="Function">∃</a><a id="3615" class="Symbol">)</a>        <a id="3624" class="Symbol">(_</a> <a id="3627" class="InductiveConstructor Operator">∷</a> <a id="3629" class="Symbol">_</a> <a id="3631" class="InductiveConstructor Operator">∷</a> <a id="3633" href="Reflection.Argument.html#1271" class="InductiveConstructor">hArg</a> <a id="3638" href="SMT.Theory.Raw.Reflection.html#3638" class="Bound">a</a> <a id="3640" class="InductiveConstructor Operator">∷</a> <a id="3642" href="Reflection.Argument.html#1209" class="InductiveConstructor">vArg</a> <a id="3647" href="SMT.Theory.Raw.Reflection.html#3647" class="Bound">b</a> <a id="3649" class="InductiveConstructor Operator">∷</a> <a id="3651" class="InductiveConstructor">[]</a><a id="3653" class="Symbol">)</a>
  <a id="3657" class="Keyword">pattern</a> <a id="`∃ˢ"></a><a id="3665" href="SMT.Theory.Raw.Reflection.html#3665" class="InductiveConstructor">`∃ˢ</a> <a id="3669" href="SMT.Theory.Raw.Reflection.html#3710" class="Bound">a</a> <a id="3671" href="SMT.Theory.Raw.Reflection.html#3719" class="Bound">b</a> <a id="3673" class="Symbol">=</a> <a id="3675" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="3679" class="Symbol">(</a><a id="3680" class="Keyword">quote</a> <a id="3686" href="Data.Product.html#1806" class="Function">∃-syntax</a><a id="3694" class="Symbol">)</a> <a id="3696" class="Symbol">(_</a> <a id="3699" class="InductiveConstructor Operator">∷</a> <a id="3701" class="Symbol">_</a> <a id="3703" class="InductiveConstructor Operator">∷</a> <a id="3705" href="Reflection.Argument.html#1271" class="InductiveConstructor">hArg</a> <a id="3710" href="SMT.Theory.Raw.Reflection.html#3710" class="Bound">a</a> <a id="3712" class="InductiveConstructor Operator">∷</a> <a id="3714" href="Reflection.Argument.html#1209" class="InductiveConstructor">vArg</a> <a id="3719" href="SMT.Theory.Raw.Reflection.html#3719" class="Bound">b</a> <a id="3721" class="InductiveConstructor Operator">∷</a> <a id="3723" class="InductiveConstructor">[]</a><a id="3725" class="Symbol">)</a>

<a id="3728" class="Keyword">mutual</a>
  <a id="3737" class="Comment">-- |To avoid having to deal with overloaded literals in the different theories (the dictionaries</a>
  <a id="3836" class="Comment">--  are hard to deal with), we normalise any calls to fromNat and fromNeg.  To convince the</a>
  <a id="3930" class="Comment">--  termination checker that this is fine there&#39;s a fuel parameter limiting how many nested</a>
  <a id="4024" class="Comment">--  normalisations we are allowed to do. Overloading will not create any nested calls to fromNat</a>
  <a id="4123" class="Comment">--  or fromNeg so it&#39;s enough to provide 1 fuel for this.</a>
  <a id="4183" class="Comment">--  However we also use the fuel when eta-expanding the predicate in existentials, and since these</a>
  <a id="4284" class="Comment">--  can be arbitrarily nested we need a reasonable amount of fuel.</a>
  <a id="reflectToRawTerm"></a><a id="4353" href="SMT.Theory.Raw.Reflection.html#4353" class="Function">reflectToRawTerm</a> <a id="4370" class="Symbol">:</a> <a id="4372" class="Symbol">(</a><a id="4373" href="SMT.Theory.Raw.Reflection.html#4373" class="Bound">Γ</a> <a id="4375" class="Symbol">:</a> <a id="4377" href="SMT.Theory.Raw.Base.html#3187" class="Function">RawCtxt</a><a id="4384" class="Symbol">)</a> <a id="4386" class="Symbol">(</a><a id="4387" href="SMT.Theory.Raw.Reflection.html#4387" class="Bound">fv</a> <a id="4390" class="Symbol">:</a> <a id="4392" href="SMT.Theory.Raw.Reflection.html#2677" class="Function">AllowedVars</a><a id="4403" class="Symbol">)</a> <a id="4405" class="Symbol">→</a> <a id="4407" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4412" class="Symbol">→</a> <a id="4414" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="4417" class="Symbol">(</a><a id="4418" href="SMT.Theory.Raw.Base.html#3264" class="Datatype">RawTerm</a> <a id="4426" href="SMT.Theory.Raw.Reflection.html#4373" class="Bound">Γ</a> <a id="4428" href="SMT.Theory.Raw.Base.html#1535" class="InductiveConstructor">⋆</a><a id="4429" class="Symbol">)</a>
  <a id="4433" href="SMT.Theory.Raw.Reflection.html#4353" class="Function">reflectToRawTerm</a> <a id="4450" class="Symbol">=</a> <a id="4452" href="SMT.Theory.Raw.Reflection.html#4478" class="Function">reflectToRawTerm′</a> <a id="4470" class="Number">1000</a>

  <a id="reflectToRawTerm′"></a><a id="4478" href="SMT.Theory.Raw.Reflection.html#4478" class="Function">reflectToRawTerm′</a> <a id="4496" class="Symbol">:</a> <a id="4498" class="Symbol">(</a><a id="4499" href="SMT.Theory.Raw.Reflection.html#4499" class="Bound">fuel</a> <a id="4504" class="Symbol">:</a> <a id="4506" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="4507" class="Symbol">)</a> <a id="4509" class="Symbol">(</a><a id="4510" href="SMT.Theory.Raw.Reflection.html#4510" class="Bound">Γ</a> <a id="4512" class="Symbol">:</a> <a id="4514" href="SMT.Theory.Raw.Base.html#3187" class="Function">RawCtxt</a><a id="4521" class="Symbol">)</a> <a id="4523" class="Symbol">(</a><a id="4524" href="SMT.Theory.Raw.Reflection.html#4524" class="Bound">fv</a> <a id="4527" class="Symbol">:</a> <a id="4529" href="SMT.Theory.Raw.Reflection.html#2677" class="Function">AllowedVars</a><a id="4540" class="Symbol">)</a> <a id="4542" class="Symbol">→</a> <a id="4544" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4549" class="Symbol">→</a> <a id="4551" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="4554" class="Symbol">(</a><a id="4555" href="SMT.Theory.Raw.Base.html#3264" class="Datatype">RawTerm</a> <a id="4563" href="SMT.Theory.Raw.Reflection.html#4510" class="Bound">Γ</a> <a id="4565" href="SMT.Theory.Raw.Base.html#1535" class="InductiveConstructor">⋆</a><a id="4566" class="Symbol">)</a>
  <a id="4570" href="SMT.Theory.Raw.Reflection.html#4478" class="Function">reflectToRawTerm′</a> <a id="4588" href="SMT.Theory.Raw.Reflection.html#4588" class="Bound">fuel</a> <a id="4593" href="SMT.Theory.Raw.Reflection.html#4593" class="Bound">Γ</a> <a id="4595" href="SMT.Theory.Raw.Reflection.html#4595" class="Bound">fv</a> <a id="4598" class="Symbol">(</a><a id="4599" href="Agda.Builtin.Reflection.html#4790" class="InductiveConstructor">var</a> <a id="4603" href="SMT.Theory.Raw.Reflection.html#4603" class="Bound">x</a> <a id="4605" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4607" class="Symbol">)</a> <a id="4609" class="Symbol">=</a> <a id="4611" class="Keyword">do</a>
    <a id="4618" href="SMT.Theory.Raw.Reflection.html#4618" class="Bound">σ</a> <a id="4620" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4622" href="SMT.Theory.Raw.Reflection.html#4622" class="Bound">y</a> <a id="4624" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="4626" href="SMT.Theory.Raw.Reflection.html#2122" class="Function">reflectToRawVar</a> <a id="4642" href="SMT.Theory.Raw.Reflection.html#4593" class="Bound">Γ</a> <a id="4644" href="Category.Monad.Indexed.html#814" class="Function Operator">=&lt;&lt;</a> <a id="4648" href="SMT.Theory.Raw.Reflection.html#2854" class="Function">strengthenVar</a> <a id="4662" href="SMT.Theory.Raw.Reflection.html#4595" class="Bound">fv</a> <a id="4665" href="SMT.Theory.Raw.Reflection.html#4603" class="Bound">x</a>
    <a id="4671" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="4678" class="Symbol">(</a><a id="4679" href="SMT.Theory.Raw.Base.html#3380" class="InductiveConstructor">`appᵣ</a> <a id="4685" class="Symbol">{</a><a id="4686" class="Argument">Σ</a> <a id="4688" class="Symbol">=</a> <a id="4690" class="Keyword">record</a><a id="4696" class="Symbol">{</a><a id="4697" href="SMT.Theory.Base.html#2042" class="Field">ArgSorts</a> <a id="4706" class="Symbol">=</a> <a id="4708" href="SMT.Theory.Raw.Reflection.html#4618" class="Bound">σ</a> <a id="4710" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4712" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4714" class="Symbol">}}</a> <a id="4717" class="Symbol">(</a><a id="4718" class="Keyword">quote</a> <a id="4724" href="SMT.Theory.Raw.Reflection.html#3321" class="Function">rawVar</a><a id="4730" class="Symbol">)</a> <a id="4732" class="Symbol">(</a><a id="4733" href="SMT.Theory.Raw.Base.html#3304" class="InductiveConstructor">`varᵣ</a> <a id="4739" href="SMT.Theory.Raw.Reflection.html#4622" class="Bound">y</a> <a id="4741" href="Data.List.Relation.Unary.All.html#1524" class="InductiveConstructor Operator">∷</a> <a id="4743" href="Data.List.Relation.Unary.All.html#1507" class="InductiveConstructor">[]</a><a id="4745" class="Symbol">))</a>
  <a id="4750" href="SMT.Theory.Raw.Reflection.html#4478" class="CatchallClause Function">reflectToRawTerm′</a><a id="4767" class="CatchallClause"> </a><a id="4768" href="SMT.Theory.Raw.Reflection.html#4768" class="CatchallClause Bound">fuel</a><a id="4772" class="CatchallClause"> </a><a id="4773" href="SMT.Theory.Raw.Reflection.html#4773" class="CatchallClause Bound">Γ</a><a id="4774" class="CatchallClause"> </a><a id="4775" class="CatchallClause Symbol">_</a><a id="4776" class="CatchallClause">  </a><a id="4778" class="CatchallClause Symbol">(</a><a id="4779" href="Agda.Builtin.Reflection.html#4790" class="CatchallClause InductiveConstructor">var</a><a id="4782" class="CatchallClause"> </a><a id="4783" class="CatchallClause Symbol">_</a><a id="4784" class="CatchallClause"> </a><a id="4785" class="CatchallClause Symbol">_)</a>  <a id="4789" class="Symbol">=</a> <a id="4791" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="4804" class="String">&quot;Higher-order variable&quot;</a>
  <a id="4830" href="SMT.Theory.Raw.Reflection.html#4478" class="Function">reflectToRawTerm′</a> <a id="4848" href="SMT.Theory.Raw.Reflection.html#4848" class="Bound">fuel</a> <a id="4853" href="SMT.Theory.Raw.Reflection.html#4853" class="Bound">Γ</a> <a id="4855" class="Symbol">_</a>  <a id="4858" class="Symbol">(</a><a id="4859" href="Agda.Builtin.Reflection.html#5161" class="InductiveConstructor">lit</a> <a id="4863" href="SMT.Theory.Raw.Reflection.html#4863" class="Bound">l</a><a id="4864" class="Symbol">)</a>    <a id="4869" class="Symbol">=</a> <a id="4871" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="4878" class="Symbol">(</a><a id="4879" href="SMT.Theory.Raw.Base.html#3342" class="InductiveConstructor">`litᵣ</a> <a id="4885" href="SMT.Theory.Raw.Reflection.html#4863" class="Bound">l</a><a id="4886" class="Symbol">)</a>
  <a id="4890" href="SMT.Theory.Raw.Reflection.html#4478" class="Function">reflectToRawTerm′</a> <a id="4908" class="Symbol">(</a><a id="4909" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="4913" href="SMT.Theory.Raw.Reflection.html#4913" class="Bound">fuel</a><a id="4917" class="Symbol">)</a> <a id="4919" href="SMT.Theory.Raw.Reflection.html#4919" class="Bound">Γ</a> <a id="4921" href="SMT.Theory.Raw.Reflection.html#4921" class="Bound">fv</a> <a id="4924" href="SMT.Theory.Raw.Reflection.html#4924" class="Bound">t</a><a id="4925" class="Symbol">@(</a><a id="4927" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="4931" href="SMT.Theory.Raw.Reflection.html#3362" class="InductiveConstructor">`fromNat</a> <a id="4940" class="Symbol">_)</a> <a id="4943" class="Symbol">=</a> <a id="4945" href="SMT.Theory.Raw.Reflection.html#4478" class="Function">reflectToRawTerm′</a> <a id="4963" href="SMT.Theory.Raw.Reflection.html#4913" class="Bound">fuel</a> <a id="4968" href="SMT.Theory.Raw.Reflection.html#4919" class="Bound">Γ</a> <a id="4970" href="SMT.Theory.Raw.Reflection.html#4921" class="Bound">fv</a> <a id="4973" href="Category.Monad.Indexed.html#814" class="Function Operator">=&lt;&lt;</a> <a id="4977" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="4987" href="SMT.Theory.Raw.Reflection.html#4924" class="Bound">t</a>
  <a id="4991" href="SMT.Theory.Raw.Reflection.html#4478" class="Function">reflectToRawTerm′</a> <a id="5009" class="Symbol">(</a><a id="5010" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="5014" href="SMT.Theory.Raw.Reflection.html#5014" class="Bound">fuel</a><a id="5018" class="Symbol">)</a> <a id="5020" href="SMT.Theory.Raw.Reflection.html#5020" class="Bound">Γ</a> <a id="5022" href="SMT.Theory.Raw.Reflection.html#5022" class="Bound">fv</a> <a id="5025" href="SMT.Theory.Raw.Reflection.html#5025" class="Bound">t</a><a id="5026" class="Symbol">@(</a><a id="5028" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="5032" href="SMT.Theory.Raw.Reflection.html#3404" class="InductiveConstructor">`fromNeg</a> <a id="5041" class="Symbol">_)</a> <a id="5044" class="Symbol">=</a> <a id="5046" href="SMT.Theory.Raw.Reflection.html#4478" class="Function">reflectToRawTerm′</a> <a id="5064" href="SMT.Theory.Raw.Reflection.html#5014" class="Bound">fuel</a> <a id="5069" href="SMT.Theory.Raw.Reflection.html#5020" class="Bound">Γ</a> <a id="5071" href="SMT.Theory.Raw.Reflection.html#5022" class="Bound">fv</a> <a id="5074" href="Category.Monad.Indexed.html#814" class="Function Operator">=&lt;&lt;</a> <a id="5078" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="5088" href="SMT.Theory.Raw.Reflection.html#5025" class="Bound">t</a>
  <a id="5092" href="SMT.Theory.Raw.Reflection.html#4478" class="Function">reflectToRawTerm′</a> <a id="5110" class="Symbol">(</a><a id="5111" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="5115" href="SMT.Theory.Raw.Reflection.html#5115" class="Bound">fuel</a><a id="5119" class="Symbol">)</a> <a id="5121" href="SMT.Theory.Raw.Reflection.html#5121" class="Bound">Γ</a> <a id="5123" href="SMT.Theory.Raw.Reflection.html#5123" class="Bound">fv</a> <a id="5126" class="Symbol">(</a><a id="5127" href="SMT.Theory.Raw.Reflection.html#3449" class="InductiveConstructor">`Σ</a>  <a id="5131" href="SMT.Theory.Raw.Reflection.html#5131" class="Bound">a</a> <a id="5133" href="SMT.Theory.Raw.Reflection.html#5133" class="Bound">b</a><a id="5134" class="Symbol">)</a> <a id="5136" class="Symbol">=</a> <a id="5138" href="SMT.Theory.Raw.Reflection.html#6159" class="Function">reflectExist</a> <a id="5151" href="SMT.Theory.Raw.Reflection.html#5115" class="Bound">fuel</a> <a id="5156" href="SMT.Theory.Raw.Reflection.html#5121" class="Bound">Γ</a> <a id="5158" href="SMT.Theory.Raw.Reflection.html#5123" class="Bound">fv</a> <a id="5161" href="SMT.Theory.Raw.Reflection.html#5131" class="Bound">a</a> <a id="5163" href="SMT.Theory.Raw.Reflection.html#5133" class="Bound">b</a>
  <a id="5167" href="SMT.Theory.Raw.Reflection.html#4478" class="Function">reflectToRawTerm′</a> <a id="5185" class="Symbol">(</a><a id="5186" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="5190" href="SMT.Theory.Raw.Reflection.html#5190" class="Bound">fuel</a><a id="5194" class="Symbol">)</a> <a id="5196" href="SMT.Theory.Raw.Reflection.html#5196" class="Bound">Γ</a> <a id="5198" href="SMT.Theory.Raw.Reflection.html#5198" class="Bound">fv</a> <a id="5201" class="Symbol">(</a><a id="5202" href="SMT.Theory.Raw.Reflection.html#3521" class="InductiveConstructor">`Σˢ</a> <a id="5206" href="SMT.Theory.Raw.Reflection.html#5206" class="Bound">a</a> <a id="5208" href="SMT.Theory.Raw.Reflection.html#5208" class="Bound">b</a><a id="5209" class="Symbol">)</a> <a id="5211" class="Symbol">=</a> <a id="5213" href="SMT.Theory.Raw.Reflection.html#6159" class="Function">reflectExist</a> <a id="5226" href="SMT.Theory.Raw.Reflection.html#5190" class="Bound">fuel</a> <a id="5231" href="SMT.Theory.Raw.Reflection.html#5196" class="Bound">Γ</a> <a id="5233" href="SMT.Theory.Raw.Reflection.html#5198" class="Bound">fv</a> <a id="5236" href="SMT.Theory.Raw.Reflection.html#5206" class="Bound">a</a> <a id="5238" href="SMT.Theory.Raw.Reflection.html#5208" class="Bound">b</a>
  <a id="5242" href="SMT.Theory.Raw.Reflection.html#4478" class="Function">reflectToRawTerm′</a> <a id="5260" class="Symbol">(</a><a id="5261" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="5265" href="SMT.Theory.Raw.Reflection.html#5265" class="Bound">fuel</a><a id="5269" class="Symbol">)</a> <a id="5271" href="SMT.Theory.Raw.Reflection.html#5271" class="Bound">Γ</a> <a id="5273" href="SMT.Theory.Raw.Reflection.html#5273" class="Bound">fv</a> <a id="5276" class="Symbol">(</a><a id="5277" href="SMT.Theory.Raw.Reflection.html#3593" class="InductiveConstructor">`∃</a>  <a id="5281" href="SMT.Theory.Raw.Reflection.html#5281" class="Bound">a</a> <a id="5283" href="SMT.Theory.Raw.Reflection.html#5283" class="Bound">b</a><a id="5284" class="Symbol">)</a> <a id="5286" class="Symbol">=</a> <a id="5288" href="SMT.Theory.Raw.Reflection.html#6159" class="Function">reflectExist</a> <a id="5301" href="SMT.Theory.Raw.Reflection.html#5265" class="Bound">fuel</a> <a id="5306" href="SMT.Theory.Raw.Reflection.html#5271" class="Bound">Γ</a> <a id="5308" href="SMT.Theory.Raw.Reflection.html#5273" class="Bound">fv</a> <a id="5311" href="SMT.Theory.Raw.Reflection.html#5281" class="Bound">a</a> <a id="5313" href="SMT.Theory.Raw.Reflection.html#5283" class="Bound">b</a>
  <a id="5317" href="SMT.Theory.Raw.Reflection.html#4478" class="Function">reflectToRawTerm′</a> <a id="5335" class="Symbol">(</a><a id="5336" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="5340" href="SMT.Theory.Raw.Reflection.html#5340" class="Bound">fuel</a><a id="5344" class="Symbol">)</a> <a id="5346" href="SMT.Theory.Raw.Reflection.html#5346" class="Bound">Γ</a> <a id="5348" href="SMT.Theory.Raw.Reflection.html#5348" class="Bound">fv</a> <a id="5351" class="Symbol">(</a><a id="5352" href="SMT.Theory.Raw.Reflection.html#3665" class="InductiveConstructor">`∃ˢ</a> <a id="5356" href="SMT.Theory.Raw.Reflection.html#5356" class="Bound">a</a> <a id="5358" href="SMT.Theory.Raw.Reflection.html#5358" class="Bound">b</a><a id="5359" class="Symbol">)</a> <a id="5361" class="Symbol">=</a> <a id="5363" href="SMT.Theory.Raw.Reflection.html#6159" class="Function">reflectExist</a> <a id="5376" href="SMT.Theory.Raw.Reflection.html#5340" class="Bound">fuel</a> <a id="5381" href="SMT.Theory.Raw.Reflection.html#5346" class="Bound">Γ</a> <a id="5383" href="SMT.Theory.Raw.Reflection.html#5348" class="Bound">fv</a> <a id="5386" href="SMT.Theory.Raw.Reflection.html#5356" class="Bound">a</a> <a id="5388" href="SMT.Theory.Raw.Reflection.html#5358" class="Bound">b</a>
  <a id="5392" href="SMT.Theory.Raw.Reflection.html#4478" class="CatchallClause Function">reflectToRawTerm′</a><a id="5409" class="CatchallClause"> </a><a id="5410" href="SMT.Theory.Raw.Reflection.html#5410" class="CatchallClause Bound">fuel</a><a id="5414" class="CatchallClause"> </a><a id="5415" href="SMT.Theory.Raw.Reflection.html#5415" class="CatchallClause Bound">Γ</a><a id="5416" class="CatchallClause"> </a><a id="5417" href="SMT.Theory.Raw.Reflection.html#5417" class="CatchallClause Bound">fv</a><a id="5419" class="CatchallClause"> </a><a id="5420" class="CatchallClause Symbol">(</a><a id="5421" href="Agda.Builtin.Reflection.html#4903" class="CatchallClause InductiveConstructor">def</a><a id="5424" class="CatchallClause"> </a><a id="5425" href="SMT.Theory.Raw.Reflection.html#5425" class="CatchallClause Bound">f</a><a id="5426" class="CatchallClause"> </a><a id="5427" href="SMT.Theory.Raw.Reflection.html#5427" class="CatchallClause Bound">ts</a><a id="5429" class="CatchallClause Symbol">)</a> <a id="5431" class="Symbol">=</a> <a id="5433" href="SMT.Theory.Raw.Base.html#3380" class="InductiveConstructor">`appᵣ</a> <a id="5439" class="Symbol">{</a><a id="5440" class="Argument">Σ</a> <a id="5442" class="Symbol">=</a> <a id="5444" href="SMT.Theory.Raw.Reflection.html#1906" class="Function">argTypes</a> <a id="5453" href="SMT.Theory.Raw.Reflection.html#5427" class="Bound">ts</a><a id="5455" class="Symbol">}</a> <a id="5457" href="SMT.Theory.Raw.Reflection.html#5425" class="Bound">f</a> <a id="5459" href="Category.Functor.html#608" class="Function Operator">&lt;$&gt;</a> <a id="5463" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="5480" href="SMT.Theory.Raw.Reflection.html#5410" class="Bound">fuel</a> <a id="5485" href="SMT.Theory.Raw.Reflection.html#5415" class="Bound">Γ</a> <a id="5487" href="SMT.Theory.Raw.Reflection.html#5417" class="Bound">fv</a> <a id="5490" href="SMT.Theory.Raw.Reflection.html#5427" class="Bound">ts</a>
  <a id="5495" href="SMT.Theory.Raw.Reflection.html#4478" class="Function">reflectToRawTerm′</a> <a id="5513" href="SMT.Theory.Raw.Reflection.html#5513" class="Bound">fuel</a> <a id="5518" href="SMT.Theory.Raw.Reflection.html#5518" class="Bound">Γ</a> <a id="5520" href="SMT.Theory.Raw.Reflection.html#5520" class="Bound">fv</a> <a id="5523" class="Symbol">(</a><a id="5524" href="Agda.Builtin.Reflection.html#4846" class="InductiveConstructor">con</a> <a id="5528" href="SMT.Theory.Raw.Reflection.html#5528" class="Bound">c</a> <a id="5530" href="SMT.Theory.Raw.Reflection.html#5530" class="Bound">ts</a><a id="5532" class="Symbol">)</a> <a id="5534" class="Symbol">=</a> <a id="5536" href="SMT.Theory.Raw.Base.html#3380" class="InductiveConstructor">`appᵣ</a> <a id="5542" class="Symbol">{</a><a id="5543" class="Argument">Σ</a> <a id="5545" class="Symbol">=</a> <a id="5547" href="SMT.Theory.Raw.Reflection.html#1906" class="Function">argTypes</a> <a id="5556" href="SMT.Theory.Raw.Reflection.html#5530" class="Bound">ts</a><a id="5558" class="Symbol">}</a> <a id="5560" href="SMT.Theory.Raw.Reflection.html#5528" class="Bound">c</a> <a id="5562" href="Category.Functor.html#608" class="Function Operator">&lt;$&gt;</a> <a id="5566" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="5583" href="SMT.Theory.Raw.Reflection.html#5513" class="Bound">fuel</a> <a id="5588" href="SMT.Theory.Raw.Reflection.html#5518" class="Bound">Γ</a> <a id="5590" href="SMT.Theory.Raw.Reflection.html#5520" class="Bound">fv</a> <a id="5593" href="SMT.Theory.Raw.Reflection.html#5530" class="Bound">ts</a>
  <a id="5598" href="SMT.Theory.Raw.Reflection.html#4478" class="Function">reflectToRawTerm′</a> <a id="5616" href="SMT.Theory.Raw.Reflection.html#5616" class="Bound">fuel</a> <a id="5621" href="SMT.Theory.Raw.Reflection.html#5621" class="Bound">Γ</a> <a id="5623" href="SMT.Theory.Raw.Reflection.html#5623" class="Bound">fv</a> <a id="5626" class="Symbol">(</a><a id="5627" href="Agda.Builtin.Reflection.html#5078" class="InductiveConstructor">pi</a> <a id="5630" href="SMT.Theory.Raw.Reflection.html#5630" class="Bound">dom</a><a id="5633" class="Symbol">@(</a><a id="5635" href="Agda.Builtin.Reflection.html#3733" class="InductiveConstructor">arg</a> <a id="5639" class="Symbol">_</a> <a id="5641" href="SMT.Theory.Raw.Reflection.html#5641" class="Bound">a</a><a id="5642" class="Symbol">)</a> <a id="5644" class="Symbol">(</a><a id="5645" href="Agda.Builtin.Reflection.html#3980" class="InductiveConstructor">abs</a> <a id="5649" href="SMT.Theory.Raw.Reflection.html#5649" class="Bound">x</a> <a id="5651" href="SMT.Theory.Raw.Reflection.html#5651" class="Bound">b</a><a id="5652" class="Symbol">))</a> <a id="5655" class="Symbol">=</a> <a id="5657" class="Keyword">do</a>
    <a id="5664" href="Function.Base.html#4121" class="Function Operator">case</a> <a id="5669" class="Number">0</a> <a id="5671" href="Reflection.DeBruijn.html#3921" class="Function Operator">∈FV</a> <a id="5675" href="SMT.Theory.Raw.Reflection.html#5651" class="Bound">b</a> <a id="5677" href="Function.Base.html#4121" class="Function Operator">of</a> <a id="5680" class="Symbol">λ</a> <a id="5682" class="Keyword">where</a>
      <a id="5694" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="5700" class="Symbol">→</a>
        <a id="5710" href="SMT.Theory.Raw.Base.html#3418" class="InductiveConstructor">`forallᵣ</a> <a id="5719" href="SMT.Theory.Raw.Reflection.html#5649" class="Bound">x</a> <a id="5721" class="Symbol">(</a><a id="5722" href="SMT.Theory.Raw.Base.html#1552" class="InductiveConstructor">TERM</a> <a id="5727" href="SMT.Theory.Raw.Reflection.html#5641" class="Bound">a</a><a id="5728" class="Symbol">)</a> <a id="5730" href="Category.Functor.html#608" class="Function Operator">&lt;$&gt;</a> <a id="5734" href="Agda.Builtin.Reflection.html#8901" class="Postulate">extendContext</a> <a id="5748" href="SMT.Theory.Raw.Reflection.html#5630" class="Bound">dom</a> <a id="5752" class="Symbol">(</a><a id="5753" href="SMT.Theory.Raw.Reflection.html#4478" class="Function">reflectToRawTerm′</a> <a id="5771" href="SMT.Theory.Raw.Reflection.html#5616" class="Bound">fuel</a> <a id="5776" class="Symbol">(</a><a id="5777" href="SMT.Theory.Raw.Base.html#1552" class="InductiveConstructor">TERM</a> <a id="5782" href="SMT.Theory.Raw.Reflection.html#5641" class="Bound">a</a> <a id="5784" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="5786" href="SMT.Theory.Raw.Reflection.html#5621" class="Bound">Γ</a><a id="5787" class="Symbol">)</a> <a id="5789" class="Symbol">(</a><a id="5790" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="5795" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="5797" href="SMT.Theory.Raw.Reflection.html#5623" class="Bound">fv</a><a id="5799" class="Symbol">)</a> <a id="5801" href="SMT.Theory.Raw.Reflection.html#5651" class="Bound">b</a><a id="5802" class="Symbol">)</a>
      <a id="5810" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="5816" class="Symbol">→</a> <a id="5818" class="Keyword">do</a>
        <a id="5829" href="SMT.Theory.Raw.Reflection.html#5829" class="Bound">a</a> <a id="5831" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="5833" href="SMT.Theory.Raw.Reflection.html#4478" class="Function">reflectToRawTerm′</a> <a id="5851" href="SMT.Theory.Raw.Reflection.html#5616" class="Bound">fuel</a> <a id="5856" href="SMT.Theory.Raw.Reflection.html#5621" class="Bound">Γ</a> <a id="5858" href="SMT.Theory.Raw.Reflection.html#5623" class="Bound">fv</a> <a id="5861" href="SMT.Theory.Raw.Reflection.html#5641" class="Bound">a</a>
        <a id="5871" href="SMT.Theory.Raw.Reflection.html#5871" class="Bound">b</a> <a id="5873" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="5875" href="Agda.Builtin.Reflection.html#8901" class="Postulate">extendContext</a> <a id="5889" href="SMT.Theory.Raw.Reflection.html#5630" class="Bound">dom</a> <a id="5893" class="Symbol">(</a><a id="5894" href="SMT.Theory.Raw.Reflection.html#4478" class="Function">reflectToRawTerm′</a> <a id="5912" href="SMT.Theory.Raw.Reflection.html#5616" class="Bound">fuel</a> <a id="5917" href="SMT.Theory.Raw.Reflection.html#5621" class="Bound">Γ</a> <a id="5919" class="Symbol">(</a><a id="5920" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="5926" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="5928" href="SMT.Theory.Raw.Reflection.html#5623" class="Bound">fv</a><a id="5930" class="Symbol">)</a> <a id="5932" href="SMT.Theory.Raw.Reflection.html#5651" class="Bound">b</a><a id="5933" class="Symbol">)</a>
        <a id="5943" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="5950" class="Symbol">(</a><a id="5951" href="SMT.Theory.Raw.Base.html#3380" class="InductiveConstructor">`appᵣ</a> <a id="5957" class="Symbol">{</a><a id="5958" class="Argument">Σ</a> <a id="5960" class="Symbol">=</a> <a id="5962" class="Keyword">record</a> <a id="5969" class="Symbol">{</a><a id="5970" href="SMT.Theory.Base.html#2042" class="Field">ArgSorts</a> <a id="5979" class="Symbol">=</a> <a id="5981" href="SMT.Theory.Raw.Base.html#1535" class="InductiveConstructor">⋆</a> <a id="5983" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="5985" href="SMT.Theory.Raw.Base.html#1535" class="InductiveConstructor">⋆</a> <a id="5987" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="5989" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="5991" class="Symbol">}}</a> <a id="5994" class="Symbol">(</a><a id="5995" class="Keyword">quote</a> <a id="6001" href="Function.Core.html#646" class="Function">Morphism</a><a id="6009" class="Symbol">)</a> <a id="6011" class="Symbol">(</a><a id="6012" href="SMT.Theory.Raw.Reflection.html#5829" class="Bound">a</a> <a id="6014" href="Data.List.Relation.Unary.All.html#1524" class="InductiveConstructor Operator">∷</a> <a id="6016" href="SMT.Theory.Raw.Reflection.html#5871" class="Bound">b</a> <a id="6018" href="Data.List.Relation.Unary.All.html#1524" class="InductiveConstructor Operator">∷</a> <a id="6020" href="Data.List.Relation.Unary.All.html#1507" class="InductiveConstructor">[]</a><a id="6022" class="Symbol">))</a>
  <a id="6027" href="SMT.Theory.Raw.Reflection.html#4478" class="Function">reflectToRawTerm′</a> <a id="6045" href="SMT.Theory.Raw.Reflection.html#6045" class="Bound">fuel</a> <a id="6050" href="SMT.Theory.Raw.Reflection.html#6050" class="Bound">Γ</a> <a id="6052" href="SMT.Theory.Raw.Reflection.html#6052" class="Bound">fv</a> <a id="6055" class="Symbol">(</a><a id="6056" href="Agda.Builtin.Reflection.html#5196" class="InductiveConstructor">meta</a> <a id="6061" href="SMT.Theory.Raw.Reflection.html#6061" class="Bound">x</a> <a id="6063" class="Symbol">_)</a> <a id="6066" class="Symbol">=</a> <a id="6068" href="Agda.Builtin.Reflection.html#9287" class="Postulate">blockOnMeta</a> <a id="6080" href="SMT.Theory.Raw.Reflection.html#6061" class="Bound">x</a>
  <a id="6084" href="SMT.Theory.Raw.Reflection.html#4478" class="CatchallClause Function">reflectToRawTerm′</a><a id="6101" class="CatchallClause"> </a><a id="6102" href="SMT.Theory.Raw.Reflection.html#6102" class="CatchallClause Bound">fuel</a><a id="6106" class="CatchallClause"> </a><a id="6107" href="SMT.Theory.Raw.Reflection.html#6107" class="CatchallClause Bound">Γ</a><a id="6108" class="CatchallClause"> </a><a id="6109" href="SMT.Theory.Raw.Reflection.html#6109" class="CatchallClause Bound">fv</a><a id="6111" class="CatchallClause"> </a><a id="6112" href="SMT.Theory.Raw.Reflection.html#6112" class="CatchallClause Bound">t</a> <a id="6114" class="Symbol">=</a> <a id="6116" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="6129" class="String">&quot;reflectToRawTerm′ failed&quot;</a>

  <a id="reflectExist"></a><a id="6159" href="SMT.Theory.Raw.Reflection.html#6159" class="Function">reflectExist</a> <a id="6172" class="Symbol">:</a> <a id="6174" class="Symbol">(</a><a id="6175" href="SMT.Theory.Raw.Reflection.html#6175" class="Bound">fuel</a> <a id="6180" class="Symbol">:</a> <a id="6182" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="6183" class="Symbol">)</a> <a id="6185" class="Symbol">(</a><a id="6186" href="SMT.Theory.Raw.Reflection.html#6186" class="Bound">Γ</a> <a id="6188" class="Symbol">:</a> <a id="6190" href="SMT.Theory.Raw.Base.html#3187" class="Function">RawCtxt</a><a id="6197" class="Symbol">)</a> <a id="6199" class="Symbol">(</a><a id="6200" href="SMT.Theory.Raw.Reflection.html#6200" class="Bound">fv</a> <a id="6203" class="Symbol">:</a> <a id="6205" href="SMT.Theory.Raw.Reflection.html#2677" class="Function">AllowedVars</a><a id="6216" class="Symbol">)</a> <a id="6218" class="Symbol">→</a> <a id="6220" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="6225" class="Symbol">→</a> <a id="6227" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="6232" class="Symbol">→</a> <a id="6234" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="6237" class="Symbol">(</a><a id="6238" href="SMT.Theory.Raw.Base.html#3264" class="Datatype">RawTerm</a> <a id="6246" href="SMT.Theory.Raw.Reflection.html#6186" class="Bound">Γ</a> <a id="6248" href="SMT.Theory.Raw.Base.html#1535" class="InductiveConstructor">⋆</a><a id="6249" class="Symbol">)</a>
  <a id="6253" href="SMT.Theory.Raw.Reflection.html#6159" class="Function">reflectExist</a> <a id="6266" href="SMT.Theory.Raw.Reflection.html#6266" class="Bound">fuel</a> <a id="6271" href="SMT.Theory.Raw.Reflection.html#6271" class="Bound">Γ</a> <a id="6273" href="SMT.Theory.Raw.Reflection.html#6273" class="Bound">fv</a> <a id="6276" href="SMT.Theory.Raw.Reflection.html#6276" class="Bound">a</a> <a id="6278" href="SMT.Theory.Raw.Reflection.html#6278" class="Bound">b</a> <a id="6280" class="Symbol">=</a> <a id="6282" class="Keyword">do</a>
    <a id="6289" href="Agda.Builtin.Reflection.html#4960" class="InductiveConstructor">lam</a> <a id="6293" class="Symbol">_</a> <a id="6295" class="Symbol">(</a><a id="6296" href="Agda.Builtin.Reflection.html#3980" class="InductiveConstructor">abs</a> <a id="6300" href="SMT.Theory.Raw.Reflection.html#6300" class="Bound">x</a> <a id="6302" href="SMT.Theory.Raw.Reflection.html#6302" class="Bound">b</a><a id="6303" class="Symbol">)</a> <a id="6305" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="6307" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="6314" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="6316" href="Reflection.DeBruijn.html#2006" class="Function">η-expand</a> <a id="6325" href="Agda.Builtin.Reflection.html#2763" class="InductiveConstructor">visible</a> <a id="6333" href="SMT.Theory.Raw.Reflection.html#6278" class="Bound">b</a>
      <a id="6341" class="Keyword">where</a> <a id="6347" class="CatchallClause Symbol">_</a> <a id="6349" class="Symbol">→</a> <a id="6351" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="6364" class="String">&quot;reflectedToRawTerm′ failed to η-expand existential predicate&quot;</a>
    <a id="6431" href="SMT.Theory.Raw.Base.html#3459" class="InductiveConstructor">`existsᵣ</a> <a id="6440" href="SMT.Theory.Raw.Reflection.html#6300" class="Bound">x</a> <a id="6442" class="Symbol">(</a><a id="6443" href="SMT.Theory.Raw.Base.html#1552" class="InductiveConstructor">TERM</a> <a id="6448" href="SMT.Theory.Raw.Reflection.html#6276" class="Bound">a</a><a id="6449" class="Symbol">)</a> <a id="6451" href="Category.Functor.html#608" class="Function Operator">&lt;$&gt;</a> <a id="6455" href="Agda.Builtin.Reflection.html#8901" class="Postulate">extendContext</a> <a id="6469" class="Symbol">(</a><a id="6470" href="Reflection.Argument.html#1209" class="InductiveConstructor">vArg</a> <a id="6475" href="SMT.Theory.Raw.Reflection.html#6276" class="Bound">a</a><a id="6476" class="Symbol">)</a> <a id="6478" class="Symbol">(</a><a id="6479" href="SMT.Theory.Raw.Reflection.html#4478" class="Function">reflectToRawTerm′</a> <a id="6497" href="SMT.Theory.Raw.Reflection.html#6266" class="Bound">fuel</a> <a id="6502" class="Symbol">(</a><a id="6503" href="SMT.Theory.Raw.Base.html#1552" class="InductiveConstructor">TERM</a> <a id="6508" href="SMT.Theory.Raw.Reflection.html#6276" class="Bound">a</a> <a id="6510" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="6512" href="SMT.Theory.Raw.Reflection.html#6271" class="Bound">Γ</a><a id="6513" class="Symbol">)</a> <a id="6515" class="Symbol">(</a><a id="6516" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="6521" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="6523" href="SMT.Theory.Raw.Reflection.html#6273" class="Bound">fv</a><a id="6525" class="Symbol">)</a> <a id="6527" href="SMT.Theory.Raw.Reflection.html#6302" class="Bound">b</a><a id="6528" class="Symbol">)</a>

  <a id="reflectToRawArgs"></a><a id="6533" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="6550" class="Symbol">:</a> <a id="6552" class="Symbol">∀</a> <a id="6554" class="Symbol">(</a><a id="6555" href="SMT.Theory.Raw.Reflection.html#6555" class="Bound">fuel</a> <a id="6560" class="Symbol">:</a> <a id="6562" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="6563" class="Symbol">)</a> <a id="6565" href="SMT.Theory.Raw.Reflection.html#6565" class="Bound">Γ</a> <a id="6567" class="Symbol">(</a><a id="6568" href="SMT.Theory.Raw.Reflection.html#6568" class="Bound">fv</a> <a id="6571" class="Symbol">:</a> <a id="6573" href="SMT.Theory.Raw.Reflection.html#2677" class="Function">AllowedVars</a><a id="6584" class="Symbol">)</a> <a id="6586" class="Symbol">(</a><a id="6587" href="SMT.Theory.Raw.Reflection.html#6587" class="Bound">ts</a> <a id="6590" class="Symbol">:</a> <a id="6592" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="6597" class="Symbol">(</a><a id="6598" href="Agda.Builtin.Reflection.html#3697" class="Datatype">Arg</a> <a id="6602" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a><a id="6606" class="Symbol">))</a> <a id="6609" class="Symbol">→</a> <a id="6611" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="6614" class="Symbol">(</a><a id="6615" href="SMT.Theory.Raw.Base.html#3538" class="Function">RawArgs</a> <a id="6623" href="SMT.Theory.Raw.Reflection.html#6565" class="Bound">Γ</a> <a id="6625" class="Symbol">(</a><a id="6626" href="SMT.Theory.Base.html#2042" class="Field">ArgSorts</a> <a id="6635" class="Symbol">(</a><a id="6636" href="SMT.Theory.Raw.Reflection.html#1906" class="Function">argTypes</a> <a id="6645" href="SMT.Theory.Raw.Reflection.html#6587" class="Bound">ts</a><a id="6647" class="Symbol">)))</a>
  <a id="6653" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="6670" href="SMT.Theory.Raw.Reflection.html#6670" class="Bound">fuel</a> <a id="6675" href="SMT.Theory.Raw.Reflection.html#6675" class="Bound">Γ</a> <a id="6677" href="SMT.Theory.Raw.Reflection.html#6677" class="Bound">fv</a> <a id="6680" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="6683" class="Symbol">=</a> <a id="6685" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="6692" href="Data.List.Relation.Unary.All.html#1507" class="InductiveConstructor">[]</a>
  <a id="6697" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="6714" href="SMT.Theory.Raw.Reflection.html#6714" class="Bound">fuel</a> <a id="6719" href="SMT.Theory.Raw.Reflection.html#6719" class="Bound">Γ</a> <a id="6721" href="SMT.Theory.Raw.Reflection.html#6721" class="Bound">fv</a> <a id="6724" class="Symbol">(</a><a id="6725" href="Reflection.Argument.html#1209" class="InductiveConstructor">vArg</a> <a id="6730" href="SMT.Theory.Raw.Reflection.html#6730" class="Bound">t</a> <a id="6732" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="6734" href="SMT.Theory.Raw.Reflection.html#6734" class="Bound">ts</a><a id="6736" class="Symbol">)</a> <a id="6738" class="Symbol">=</a> <a id="6740" class="Symbol">⦇</a> <a id="6742" href="SMT.Theory.Raw.Reflection.html#4478" class="Function">reflectToRawTerm′</a> <a id="6760" href="SMT.Theory.Raw.Reflection.html#6714" class="Bound">fuel</a> <a id="6765" href="SMT.Theory.Raw.Reflection.html#6719" class="Bound">Γ</a> <a id="6767" href="SMT.Theory.Raw.Reflection.html#6721" class="Bound">fv</a> <a id="6770" href="SMT.Theory.Raw.Reflection.html#6730" class="Bound">t</a> <a id="6772" href="Data.List.Relation.Unary.All.html#1524" class="InductiveConstructor Operator">∷</a> <a id="6774" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="6791" href="SMT.Theory.Raw.Reflection.html#6714" class="Bound">fuel</a> <a id="6796" href="SMT.Theory.Raw.Reflection.html#6719" class="Bound">Γ</a> <a id="6798" href="SMT.Theory.Raw.Reflection.html#6721" class="Bound">fv</a> <a id="6801" href="SMT.Theory.Raw.Reflection.html#6734" class="Bound">ts</a> <a id="6804" class="Symbol">⦈</a>
  <a id="6808" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="6825" href="SMT.Theory.Raw.Reflection.html#6825" class="Bound">fuel</a> <a id="6830" href="SMT.Theory.Raw.Reflection.html#6830" class="Bound">Γ</a> <a id="6832" href="SMT.Theory.Raw.Reflection.html#6832" class="Bound">fv</a> <a id="6835" class="Symbol">(</a><a id="6836" href="Reflection.Argument.html#1271" class="InductiveConstructor">hArg</a> <a id="6841" class="Symbol">_</a> <a id="6843" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="6845" href="SMT.Theory.Raw.Reflection.html#6845" class="Bound">ts</a><a id="6847" class="Symbol">)</a> <a id="6849" class="Symbol">=</a> <a id="6851" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="6868" href="SMT.Theory.Raw.Reflection.html#6825" class="Bound">fuel</a> <a id="6873" href="SMT.Theory.Raw.Reflection.html#6830" class="Bound">Γ</a> <a id="6875" href="SMT.Theory.Raw.Reflection.html#6832" class="Bound">fv</a> <a id="6878" href="SMT.Theory.Raw.Reflection.html#6845" class="Bound">ts</a>
  <a id="6883" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="6900" href="SMT.Theory.Raw.Reflection.html#6900" class="Bound">fuel</a> <a id="6905" href="SMT.Theory.Raw.Reflection.html#6905" class="Bound">Γ</a> <a id="6907" href="SMT.Theory.Raw.Reflection.html#6907" class="Bound">fv</a> <a id="6910" class="Symbol">(</a><a id="6911" href="Reflection.Argument.html#1333" class="InductiveConstructor">iArg</a> <a id="6916" class="Symbol">_</a> <a id="6918" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="6920" href="SMT.Theory.Raw.Reflection.html#6920" class="Bound">ts</a><a id="6922" class="Symbol">)</a> <a id="6924" class="Symbol">=</a> <a id="6926" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="6943" href="SMT.Theory.Raw.Reflection.html#6900" class="Bound">fuel</a> <a id="6948" href="SMT.Theory.Raw.Reflection.html#6905" class="Bound">Γ</a> <a id="6950" href="SMT.Theory.Raw.Reflection.html#6907" class="Bound">fv</a> <a id="6953" href="SMT.Theory.Raw.Reflection.html#6920" class="Bound">ts</a>
  <a id="6958" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="6975" href="SMT.Theory.Raw.Reflection.html#6975" class="Bound">fuel</a> <a id="6980" href="SMT.Theory.Raw.Reflection.html#6980" class="Bound">Γ</a> <a id="6982" href="SMT.Theory.Raw.Reflection.html#6982" class="Bound">fv</a> <a id="6985" class="Symbol">(</a><a id="6986" href="Agda.Builtin.Reflection.html#3733" class="InductiveConstructor">arg</a> <a id="6990" class="Symbol">(</a><a id="6991" href="Agda.Builtin.Reflection.html#3638" class="InductiveConstructor">arg-info</a> <a id="7000" href="Agda.Builtin.Reflection.html#2763" class="InductiveConstructor">visible</a>   <a id="7010" class="Symbol">(</a><a id="7011" href="Agda.Builtin.Reflection.html#3464" class="InductiveConstructor">modality</a> <a id="7020" href="Agda.Builtin.Reflection.html#3029" class="InductiveConstructor">irrelevant</a> <a id="7031" class="Symbol">_))</a> <a id="7035" class="Symbol">_</a> <a id="7037" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="7039" href="SMT.Theory.Raw.Reflection.html#7039" class="Bound">ts</a><a id="7041" class="Symbol">)</a> <a id="7043" class="Symbol">=</a> <a id="7045" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="7062" href="SMT.Theory.Raw.Reflection.html#6975" class="Bound">fuel</a> <a id="7067" href="SMT.Theory.Raw.Reflection.html#6980" class="Bound">Γ</a> <a id="7069" href="SMT.Theory.Raw.Reflection.html#6982" class="Bound">fv</a> <a id="7072" href="SMT.Theory.Raw.Reflection.html#7039" class="Bound">ts</a>
  <a id="7077" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="7094" href="SMT.Theory.Raw.Reflection.html#7094" class="Bound">fuel</a> <a id="7099" href="SMT.Theory.Raw.Reflection.html#7099" class="Bound">Γ</a> <a id="7101" href="SMT.Theory.Raw.Reflection.html#7101" class="Bound">fv</a> <a id="7104" class="Symbol">(</a><a id="7105" href="Agda.Builtin.Reflection.html#3733" class="InductiveConstructor">arg</a> <a id="7109" class="Symbol">(</a><a id="7110" href="Agda.Builtin.Reflection.html#3638" class="InductiveConstructor">arg-info</a> <a id="7119" href="Agda.Builtin.Reflection.html#2771" class="InductiveConstructor">hidden</a>    <a id="7129" class="Symbol">(</a><a id="7130" href="Agda.Builtin.Reflection.html#3464" class="InductiveConstructor">modality</a> <a id="7139" href="Agda.Builtin.Reflection.html#3029" class="InductiveConstructor">irrelevant</a> <a id="7150" class="Symbol">_))</a> <a id="7154" class="Symbol">_</a> <a id="7156" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="7158" href="SMT.Theory.Raw.Reflection.html#7158" class="Bound">ts</a><a id="7160" class="Symbol">)</a> <a id="7162" class="Symbol">=</a> <a id="7164" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="7181" href="SMT.Theory.Raw.Reflection.html#7094" class="Bound">fuel</a> <a id="7186" href="SMT.Theory.Raw.Reflection.html#7099" class="Bound">Γ</a> <a id="7188" href="SMT.Theory.Raw.Reflection.html#7101" class="Bound">fv</a> <a id="7191" href="SMT.Theory.Raw.Reflection.html#7158" class="Bound">ts</a>
  <a id="7196" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="7213" href="SMT.Theory.Raw.Reflection.html#7213" class="Bound">fuel</a> <a id="7218" href="SMT.Theory.Raw.Reflection.html#7218" class="Bound">Γ</a> <a id="7220" href="SMT.Theory.Raw.Reflection.html#7220" class="Bound">fv</a> <a id="7223" class="Symbol">(</a><a id="7224" href="Agda.Builtin.Reflection.html#3733" class="InductiveConstructor">arg</a> <a id="7228" class="Symbol">(</a><a id="7229" href="Agda.Builtin.Reflection.html#3638" class="InductiveConstructor">arg-info</a> <a id="7238" href="Agda.Builtin.Reflection.html#2778" class="InductiveConstructor">instance′</a> <a id="7248" class="Symbol">(</a><a id="7249" href="Agda.Builtin.Reflection.html#3464" class="InductiveConstructor">modality</a> <a id="7258" href="Agda.Builtin.Reflection.html#3029" class="InductiveConstructor">irrelevant</a> <a id="7269" class="Symbol">_))</a> <a id="7273" class="Symbol">_</a> <a id="7275" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="7277" href="SMT.Theory.Raw.Reflection.html#7277" class="Bound">ts</a><a id="7279" class="Symbol">)</a> <a id="7281" class="Symbol">=</a> <a id="7283" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="7300" href="SMT.Theory.Raw.Reflection.html#7213" class="Bound">fuel</a> <a id="7305" href="SMT.Theory.Raw.Reflection.html#7218" class="Bound">Γ</a> <a id="7307" href="SMT.Theory.Raw.Reflection.html#7220" class="Bound">fv</a> <a id="7310" href="SMT.Theory.Raw.Reflection.html#7277" class="Bound">ts</a>

  <a id="7316" class="Comment">-- TODO: @wenkokke added these cases after the release of Agda 2.6.2, but does not know if they&#39;re correct.</a>
  <a id="7426" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="7443" href="SMT.Theory.Raw.Reflection.html#7443" class="Bound">fuel</a> <a id="7448" href="SMT.Theory.Raw.Reflection.html#7448" class="Bound">Γ</a> <a id="7450" href="SMT.Theory.Raw.Reflection.html#7450" class="Bound">fv</a> <a id="7453" class="Symbol">(</a><a id="7454" href="Agda.Builtin.Reflection.html#3733" class="InductiveConstructor">arg</a> <a id="7458" class="Symbol">(</a><a id="7459" href="Agda.Builtin.Reflection.html#3638" class="InductiveConstructor">arg-info</a> <a id="7468" href="Agda.Builtin.Reflection.html#2763" class="InductiveConstructor">visible</a>   <a id="7478" class="Symbol">(</a><a id="7479" href="Agda.Builtin.Reflection.html#3464" class="InductiveConstructor">modality</a> <a id="7488" href="Agda.Builtin.Reflection.html#3020" class="InductiveConstructor">relevant</a> <a id="7497" href="Agda.Builtin.Reflection.html#3231" class="InductiveConstructor">quantity-0</a><a id="7507" class="Symbol">))</a> <a id="7510" class="Symbol">_</a> <a id="7512" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="7514" href="SMT.Theory.Raw.Reflection.html#7514" class="Bound">ts</a><a id="7516" class="Symbol">)</a> <a id="7518" class="Symbol">=</a> <a id="7520" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="7537" href="SMT.Theory.Raw.Reflection.html#7443" class="Bound">fuel</a> <a id="7542" href="SMT.Theory.Raw.Reflection.html#7448" class="Bound">Γ</a> <a id="7544" href="SMT.Theory.Raw.Reflection.html#7450" class="Bound">fv</a> <a id="7547" href="SMT.Theory.Raw.Reflection.html#7514" class="Bound">ts</a>
  <a id="7552" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="7569" href="SMT.Theory.Raw.Reflection.html#7569" class="Bound">fuel</a> <a id="7574" href="SMT.Theory.Raw.Reflection.html#7574" class="Bound">Γ</a> <a id="7576" href="SMT.Theory.Raw.Reflection.html#7576" class="Bound">fv</a> <a id="7579" class="Symbol">(</a><a id="7580" href="Agda.Builtin.Reflection.html#3733" class="InductiveConstructor">arg</a> <a id="7584" class="Symbol">(</a><a id="7585" href="Agda.Builtin.Reflection.html#3638" class="InductiveConstructor">arg-info</a> <a id="7594" href="Agda.Builtin.Reflection.html#2771" class="InductiveConstructor">hidden</a>    <a id="7604" class="Symbol">(</a><a id="7605" href="Agda.Builtin.Reflection.html#3464" class="InductiveConstructor">modality</a> <a id="7614" href="Agda.Builtin.Reflection.html#3020" class="InductiveConstructor">relevant</a> <a id="7623" href="Agda.Builtin.Reflection.html#3231" class="InductiveConstructor">quantity-0</a><a id="7633" class="Symbol">))</a> <a id="7636" class="Symbol">_</a> <a id="7638" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="7640" href="SMT.Theory.Raw.Reflection.html#7640" class="Bound">ts</a><a id="7642" class="Symbol">)</a> <a id="7644" class="Symbol">=</a> <a id="7646" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="7663" href="SMT.Theory.Raw.Reflection.html#7569" class="Bound">fuel</a> <a id="7668" href="SMT.Theory.Raw.Reflection.html#7574" class="Bound">Γ</a> <a id="7670" href="SMT.Theory.Raw.Reflection.html#7576" class="Bound">fv</a> <a id="7673" href="SMT.Theory.Raw.Reflection.html#7640" class="Bound">ts</a>
  <a id="7678" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="7695" href="SMT.Theory.Raw.Reflection.html#7695" class="Bound">fuel</a> <a id="7700" href="SMT.Theory.Raw.Reflection.html#7700" class="Bound">Γ</a> <a id="7702" href="SMT.Theory.Raw.Reflection.html#7702" class="Bound">fv</a> <a id="7705" class="Symbol">(</a><a id="7706" href="Agda.Builtin.Reflection.html#3733" class="InductiveConstructor">arg</a> <a id="7710" class="Symbol">(</a><a id="7711" href="Agda.Builtin.Reflection.html#3638" class="InductiveConstructor">arg-info</a> <a id="7720" href="Agda.Builtin.Reflection.html#2778" class="InductiveConstructor">instance′</a> <a id="7730" class="Symbol">(</a><a id="7731" href="Agda.Builtin.Reflection.html#3464" class="InductiveConstructor">modality</a> <a id="7740" href="Agda.Builtin.Reflection.html#3020" class="InductiveConstructor">relevant</a> <a id="7749" href="Agda.Builtin.Reflection.html#3231" class="InductiveConstructor">quantity-0</a><a id="7759" class="Symbol">))</a> <a id="7762" class="Symbol">_</a> <a id="7764" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="7766" href="SMT.Theory.Raw.Reflection.html#7766" class="Bound">ts</a><a id="7768" class="Symbol">)</a> <a id="7770" class="Symbol">=</a> <a id="7772" href="SMT.Theory.Raw.Reflection.html#6533" class="Function">reflectToRawArgs</a> <a id="7789" href="SMT.Theory.Raw.Reflection.html#7695" class="Bound">fuel</a> <a id="7794" href="SMT.Theory.Raw.Reflection.html#7700" class="Bound">Γ</a> <a id="7796" href="SMT.Theory.Raw.Reflection.html#7702" class="Bound">fv</a> <a id="7799" href="SMT.Theory.Raw.Reflection.html#7766" class="Bound">ts</a>

<a id="7803" class="Comment">-- |Decode a reflected Agda type to a raw SMT-LIB script.</a>
<a id="7861" class="Comment">--</a>
<a id="7864" class="Comment">--  Functions are decoded as a series of assertions, with the result type</a>
<a id="7938" class="Comment">--  negated. For instance, the type `(x y : ℤ) → x - y ≤ x + y → x ≡ y`</a>
<a id="8010" class="Comment">--  is decoded as:</a>
<a id="8029" class="Comment">--</a>
<a id="8032" class="Comment">--  @</a>
<a id="8038" class="Comment">--    (declare-const ⋆ x)</a>
<a id="8064" class="Comment">--    (declare-const ⋆ y)</a>
<a id="8090" class="Comment">--    (assert (≤ (- x y) (+ x y)))</a>
<a id="8125" class="Comment">--    (assert (not (= x y)))</a>
<a id="8154" class="Comment">--  @</a>
<a id="8160" class="Comment">--</a>
<a id="8163" class="Comment">--  Which corresponds to `∃[ x ] ∃[ y ] (x - y ≤ x + y × x ≢ y)`, i.e.,</a>
<a id="8235" class="Comment">--  the negation of the Agda type. If the solver can find an inhabitant</a>
<a id="8307" class="Comment">--  for this type, then we have a counter-example for the original type.</a>
<a id="8380" class="Comment">--</a>
<a id="reflectToRawScript"></a><a id="8383" href="SMT.Theory.Raw.Reflection.html#8383" class="Function">reflectToRawScript</a> <a id="8402" class="Symbol">:</a> <a id="8404" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="8409" class="Symbol">→</a> <a id="8411" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="8414" class="Symbol">(</a><a id="8415" href="Data.Product.html#1806" class="Function">∃[</a> <a id="8418" href="SMT.Theory.Raw.Reflection.html#8418" class="Bound">Γ</a> <a id="8420" href="Data.Product.html#1806" class="Function">]</a> <a id="8422" href="SMT.Theory.Raw.Base.html#3842" class="Datatype">RawScript</a> <a id="8432" class="InductiveConstructor">[]</a> <a id="8435" href="SMT.Theory.Raw.Reflection.html#8418" class="Bound">Γ</a> <a id="8437" class="InductiveConstructor">[]</a><a id="8439" class="Symbol">)</a>
<a id="8441" href="SMT.Theory.Raw.Reflection.html#8383" class="Function">reflectToRawScript</a> <a id="8460" class="Symbol">=</a> <a id="8462" href="SMT.Theory.Raw.Reflection.html#8500" class="Function">reflectToRawScript′</a> <a id="8482" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="8485" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
  <a id="8490" class="Keyword">where</a>
    <a id="8500" href="SMT.Theory.Raw.Reflection.html#8500" class="Function">reflectToRawScript′</a> <a id="8520" class="Symbol">:</a> <a id="8522" class="Symbol">(</a><a id="8523" href="SMT.Theory.Raw.Reflection.html#8523" class="Bound">Γ</a> <a id="8525" class="Symbol">:</a> <a id="8527" href="SMT.Theory.Raw.Base.html#3187" class="Function">RawCtxt</a><a id="8534" class="Symbol">)</a> <a id="8536" class="Symbol">(</a><a id="8537" href="SMT.Theory.Raw.Reflection.html#8537" class="Bound">fv</a> <a id="8540" class="Symbol">:</a> <a id="8542" href="SMT.Theory.Raw.Reflection.html#2677" class="Function">AllowedVars</a><a id="8553" class="Symbol">)</a> <a id="8555" class="Symbol">→</a> <a id="8557" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="8562" class="Symbol">→</a> <a id="8564" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="8567" class="Symbol">(</a><a id="8568" href="Data.Product.html#1806" class="Function">∃[</a> <a id="8571" href="SMT.Theory.Raw.Reflection.html#8571" class="Bound">Γ′</a> <a id="8574" href="Data.Product.html#1806" class="Function">]</a> <a id="8576" href="SMT.Theory.Raw.Base.html#3842" class="Datatype">RawScript</a> <a id="8586" href="SMT.Theory.Raw.Reflection.html#8523" class="Bound">Γ</a> <a id="8588" href="SMT.Theory.Raw.Reflection.html#8571" class="Bound">Γ′</a> <a id="8591" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="8593" class="Symbol">)</a>
    <a id="8599" href="SMT.Theory.Raw.Reflection.html#8500" class="Function">reflectToRawScript′</a> <a id="8619" href="SMT.Theory.Raw.Reflection.html#8619" class="Bound">Γ</a> <a id="8621" href="SMT.Theory.Raw.Reflection.html#8621" class="Bound">fv</a> <a id="8624" class="Symbol">(</a><a id="8625" href="Agda.Builtin.Reflection.html#5078" class="InductiveConstructor">pi</a> <a id="8628" href="SMT.Theory.Raw.Reflection.html#8628" class="Bound">dom</a><a id="8631" class="Symbol">@(</a><a id="8633" href="Agda.Builtin.Reflection.html#3733" class="InductiveConstructor">arg</a> <a id="8637" class="Symbol">_</a> <a id="8639" href="SMT.Theory.Raw.Reflection.html#8639" class="Bound">a</a><a id="8640" class="Symbol">)</a> <a id="8642" class="Symbol">(</a><a id="8643" href="Agda.Builtin.Reflection.html#3980" class="InductiveConstructor">abs</a> <a id="8647" href="SMT.Theory.Raw.Reflection.html#8647" class="Bound">x</a> <a id="8649" href="SMT.Theory.Raw.Reflection.html#8649" class="Bound">b</a><a id="8650" class="Symbol">))</a> <a id="8653" class="Symbol">=</a>
      <a id="8661" href="Function.Base.html#4121" class="Function Operator">case</a> <a id="8666" class="Number">0</a> <a id="8668" href="Reflection.DeBruijn.html#3921" class="Function Operator">∈FV</a> <a id="8672" href="SMT.Theory.Raw.Reflection.html#8649" class="Bound">b</a> <a id="8674" href="Function.Base.html#4121" class="Function Operator">of</a> <a id="8677" class="Symbol">λ</a> <a id="8679" class="Keyword">where</a>
        <a id="8693" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="8698" class="Symbol">→</a> <a id="8700" class="Keyword">do</a>
          <a id="8713" href="SMT.Theory.Raw.Reflection.html#8713" class="Bound">Γ′</a> <a id="8716" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8718" href="SMT.Theory.Raw.Reflection.html#8718" class="Bound">s</a> <a id="8720" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="8722" href="Agda.Builtin.Reflection.html#8901" class="Postulate">extendContext</a> <a id="8736" href="SMT.Theory.Raw.Reflection.html#8628" class="Bound">dom</a> <a id="8740" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="8742" href="SMT.Theory.Raw.Reflection.html#8500" class="Function">reflectToRawScript′</a> <a id="8762" class="Symbol">(</a><a id="8763" href="SMT.Theory.Raw.Base.html#1552" class="InductiveConstructor">TERM</a> <a id="8768" href="SMT.Theory.Raw.Reflection.html#8639" class="Bound">a</a> <a id="8770" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="8772" href="SMT.Theory.Raw.Reflection.html#8619" class="Bound">Γ</a><a id="8773" class="Symbol">)</a> <a id="8775" class="Symbol">(</a><a id="8776" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="8781" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="8783" href="SMT.Theory.Raw.Reflection.html#8621" class="Bound">fv</a><a id="8785" class="Symbol">)</a> <a id="8787" href="SMT.Theory.Raw.Reflection.html#8649" class="Bound">b</a>
          <a id="8799" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="8806" class="Symbol">(</a><a id="8807" href="SMT.Theory.Raw.Reflection.html#8713" class="Bound">Γ′</a> <a id="8810" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8812" href="SMT.Theory.Raw.Base.html#3665" class="InductiveConstructor">`declare-constᵣ</a> <a id="8828" href="SMT.Theory.Raw.Reflection.html#8647" class="Bound">x</a> <a id="8830" class="Symbol">(</a><a id="8831" href="SMT.Theory.Raw.Base.html#1552" class="InductiveConstructor">TERM</a> <a id="8836" href="SMT.Theory.Raw.Reflection.html#8639" class="Bound">a</a><a id="8837" class="Symbol">)</a> <a id="8839" href="SMT.Theory.Raw.Base.html#3920" class="InductiveConstructor Operator">∷ᵣ</a> <a id="8842" href="SMT.Theory.Raw.Reflection.html#8718" class="Bound">s</a><a id="8843" class="Symbol">)</a>
        <a id="8853" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="8859" class="Symbol">→</a> <a id="8861" class="Keyword">do</a>
          <a id="8874" href="SMT.Theory.Raw.Reflection.html#8874" class="Bound">t</a> <a id="8876" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="8878" href="SMT.Theory.Raw.Reflection.html#4353" class="Function">reflectToRawTerm</a> <a id="8895" href="SMT.Theory.Raw.Reflection.html#8619" class="Bound">Γ</a> <a id="8897" href="SMT.Theory.Raw.Reflection.html#8621" class="Bound">fv</a> <a id="8900" href="SMT.Theory.Raw.Reflection.html#8639" class="Bound">a</a>
          <a id="8912" href="SMT.Theory.Raw.Reflection.html#8912" class="Bound">Γ′</a> <a id="8915" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8917" href="SMT.Theory.Raw.Reflection.html#8917" class="Bound">s</a> <a id="8919" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="8921" href="Agda.Builtin.Reflection.html#8901" class="Postulate">extendContext</a> <a id="8935" href="SMT.Theory.Raw.Reflection.html#8628" class="Bound">dom</a> <a id="8939" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="8941" href="SMT.Theory.Raw.Reflection.html#8500" class="Function">reflectToRawScript′</a> <a id="8961" href="SMT.Theory.Raw.Reflection.html#8619" class="Bound">Γ</a> <a id="8963" class="Symbol">(</a><a id="8964" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="8970" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="8972" href="SMT.Theory.Raw.Reflection.html#8621" class="Bound">fv</a><a id="8974" class="Symbol">)</a> <a id="8976" href="SMT.Theory.Raw.Reflection.html#8649" class="Bound">b</a>
          <a id="8988" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="8995" class="Symbol">(</a><a id="8996" href="SMT.Theory.Raw.Reflection.html#8912" class="Bound">Γ′</a> <a id="8999" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="9001" href="SMT.Theory.Raw.Base.html#3713" class="InductiveConstructor">`assertᵣ</a> <a id="9010" href="SMT.Theory.Raw.Reflection.html#8874" class="Bound">t</a> <a id="9012" href="SMT.Theory.Raw.Base.html#3920" class="InductiveConstructor Operator">∷ᵣ</a> <a id="9015" href="SMT.Theory.Raw.Reflection.html#8917" class="Bound">s</a><a id="9016" class="Symbol">)</a>
    <a id="9022" href="SMT.Theory.Raw.Reflection.html#8500" class="CatchallClause Function">reflectToRawScript′</a><a id="9041" class="CatchallClause"> </a><a id="9042" href="SMT.Theory.Raw.Reflection.html#9042" class="CatchallClause Bound">Γ</a><a id="9043" class="CatchallClause"> </a><a id="9044" href="SMT.Theory.Raw.Reflection.html#9044" class="CatchallClause Bound">fv</a><a id="9046" class="CatchallClause"> </a><a id="9047" href="SMT.Theory.Raw.Reflection.html#9047" class="CatchallClause Bound">t</a> <a id="9049" class="Symbol">=</a> <a id="9051" class="Keyword">do</a>
      <a id="9060" href="SMT.Theory.Raw.Reflection.html#9060" class="Bound">t</a> <a id="9062" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="9064" href="SMT.Theory.Raw.Reflection.html#4353" class="Function">reflectToRawTerm</a> <a id="9081" href="SMT.Theory.Raw.Reflection.html#9042" class="Bound">Γ</a> <a id="9083" href="SMT.Theory.Raw.Reflection.html#9044" class="Bound">fv</a> <a id="9086" href="SMT.Theory.Raw.Reflection.html#9047" class="Bound">t</a>
      <a id="9094" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="9101" class="Symbol">(</a><a id="9102" href="SMT.Theory.Raw.Reflection.html#9042" class="Bound">Γ</a> <a id="9104" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="9106" href="SMT.Theory.Raw.Base.html#3713" class="InductiveConstructor">`assertᵣ</a> <a id="9115" class="Symbol">(</a><a id="9116" href="SMT.Theory.Raw.Base.html#3380" class="InductiveConstructor">`appᵣ</a> <a id="9122" class="Symbol">(</a><a id="9123" class="Keyword">quote</a> <a id="9129" href="Relation.Nullary.html#656" class="Function Operator">¬_</a><a id="9131" class="Symbol">)</a> <a id="9133" class="Symbol">(</a><a id="9134" href="SMT.Theory.Raw.Reflection.html#9060" class="Bound">t</a> <a id="9136" href="Data.List.Relation.Unary.All.html#1524" class="InductiveConstructor Operator">∷</a> <a id="9138" href="Data.List.Relation.Unary.All.html#1507" class="InductiveConstructor">[]</a><a id="9140" class="Symbol">))</a> <a id="9143" href="SMT.Theory.Raw.Base.html#3920" class="InductiveConstructor Operator">∷ᵣ</a> <a id="9146" href="SMT.Theory.Raw.Base.html#3884" class="InductiveConstructor">[]ᵣ</a><a id="9149" class="Symbol">)</a>
</pre></body></html>