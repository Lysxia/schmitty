<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SMT.Theory.Raw.Reflection</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">module</a> <a id="8" href="SMT.Theory.Raw.Reflection.html" class="Module">SMT.Theory.Raw.Reflection</a> <a id="34" class="Keyword">where</a>

<a id="41" class="Keyword">open</a> <a id="46" class="Keyword">import</a> <a id="53" href="Category.Monad.html" class="Module">Category.Monad</a>
<a id="68" class="Keyword">open</a> <a id="73" class="Keyword">import</a> <a id="80" href="Data.Bool.html" class="Module">Data.Bool</a> <a id="90" class="Symbol">as</a> <a id="93" class="Module">Bool</a> <a id="98" class="Keyword">using</a> <a id="104" class="Symbol">(</a><a id="105" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="109" class="Symbol">;</a> <a id="111" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="115" class="Symbol">;</a> <a id="117" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="122" class="Symbol">;</a> <a id="124" href="Data.Bool.Base.html#1044" class="Function Operator">_∨_</a><a id="127" class="Symbol">)</a>
<a id="129" class="Keyword">open</a> <a id="134" class="Keyword">import</a> <a id="141" href="Data.Fin.html" class="Module">Data.Fin</a> <a id="150" class="Symbol">as</a> <a id="153" class="Module">Fin</a> <a id="157" class="Keyword">using</a> <a id="163" class="Symbol">(</a><a id="164" href="Data.Fin.Base.html#1138" class="Datatype">Fin</a><a id="167" class="Symbol">;</a> <a id="169" href="Data.Fin.Base.html#1191" class="InductiveConstructor">suc</a><a id="172" class="Symbol">;</a> <a id="174" href="Data.Fin.Base.html#1160" class="InductiveConstructor">zero</a><a id="178" class="Symbol">)</a>
<a id="180" class="Keyword">open</a> <a id="185" class="Keyword">import</a> <a id="192" href="Data.Integer.html" class="Module">Data.Integer</a> <a id="205" class="Symbol">as</a> <a id="208" class="Module">Int</a> <a id="212" class="Keyword">using</a> <a id="218" class="Symbol">(</a><a id="219" href="Agda.Builtin.Int.html#246" class="Datatype">ℤ</a><a id="220" class="Symbol">;</a> <a id="222" href="Agda.Builtin.Int.html#264" class="InductiveConstructor">+_</a><a id="224" class="Symbol">;</a> <a id="226" href="Agda.Builtin.Int.html#291" class="InductiveConstructor">-[1+_]</a><a id="232" class="Symbol">)</a>
<a id="234" class="Keyword">open</a> <a id="239" class="Keyword">import</a> <a id="246" href="Data.List.html" class="Module">Data.List</a> <a id="256" class="Symbol">as</a> <a id="259" class="Module">List</a> <a id="264" class="Keyword">using</a> <a id="270" class="Symbol">(</a><a id="271" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="275" class="Symbol">;</a> <a id="277" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="280" class="Symbol">;</a> <a id="282" href="Data.List.Base.html#9981" class="InductiveConstructor">[]</a><a id="284" class="Symbol">;</a> <a id="286" href="Data.List.Base.html#4577" class="Function">length</a><a id="292" class="Symbol">)</a>
<a id="294" class="Keyword">open</a> <a id="299" class="Keyword">import</a> <a id="306" href="Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="335" class="Keyword">using</a> <a id="341" class="Symbol">(</a><a id="342" href="Data.List.Relation.Unary.All.html#1397" class="Datatype">All</a><a id="345" class="Symbol">;</a> <a id="347" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">_∷_</a><a id="350" class="Symbol">;</a> <a id="352" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="354" class="Symbol">)</a>
<a id="356" class="Keyword">open</a> <a id="361" class="Keyword">import</a> <a id="368" href="Data.List.NonEmpty.html" class="Module">Data.List.NonEmpty</a> <a id="387" class="Symbol">as</a> <a id="390" class="Module">List⁺</a> <a id="396" class="Keyword">using</a> <a id="402" class="Symbol">(</a><a id="403" href="Data.List.NonEmpty.html#1318" class="Record">List⁺</a><a id="408" class="Symbol">;</a> <a id="410" href="Data.List.NonEmpty.html#1364" class="InductiveConstructor Operator">_∷_</a><a id="413" class="Symbol">)</a>
<a id="415" class="Keyword">open</a> <a id="420" class="Keyword">import</a> <a id="427" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="436" class="Symbol">as</a> <a id="439" class="Module">Nat</a> <a id="443" class="Keyword">using</a> <a id="449" class="Symbol">(</a><a id="450" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="451" class="Symbol">;</a> <a id="453" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="457" class="Symbol">;</a> <a id="459" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="462" class="Symbol">;</a> <a id="464" href="Data.Nat.Base.html#2735" class="Primitive Operator">_∸_</a><a id="467" class="Symbol">)</a>
<a id="469" class="Keyword">open</a> <a id="474" class="Keyword">import</a> <a id="481" href="Data.Product.html" class="Module">Data.Product</a> <a id="494" class="Symbol">as</a> <a id="497" class="Module">Prod</a> <a id="502" class="Keyword">using</a> <a id="508" class="Symbol">(</a><a id="509" href="Data.Product.html#1788" class="Function">∃-syntax</a><a id="517" class="Symbol">;</a> <a id="519" href="Data.Product.html#1167" class="Function Operator">_×_</a><a id="522" class="Symbol">;</a> <a id="524" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="527" class="Symbol">;</a> <a id="529" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="534" class="Symbol">;</a> <a id="536" href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="541" class="Symbol">)</a>
<a id="543" class="Keyword">open</a> <a id="548" class="Keyword">import</a> <a id="555" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="565" class="Symbol">as</a> <a id="568" class="Module">Unit</a> <a id="573" class="Keyword">using</a> <a id="579" class="Symbol">(</a><a id="580" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="581" class="Symbol">)</a>
<a id="583" class="Keyword">open</a> <a id="588" class="Keyword">import</a> <a id="595" href="Function.html" class="Module">Function</a>
<a id="604" class="Keyword">open</a> <a id="609" class="Keyword">import</a> <a id="616" href="Level.html" class="Module">Level</a> <a id="622" class="Keyword">using</a> <a id="628" class="Symbol">(</a><a id="629" href="Agda.Primitive.html#597" class="Postulate">Level</a><a id="634" class="Symbol">)</a>
<a id="636" class="Keyword">open</a> <a id="641" class="Keyword">import</a> <a id="648" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="686" class="Symbol">as</a> <a id="689" class="Module">PropEq</a> <a id="696" class="Keyword">using</a> <a id="702" class="Symbol">(</a><a id="703" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="706" class="Symbol">;</a> <a id="708" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="712" class="Symbol">)</a>
<a id="714" class="Keyword">open</a> <a id="719" class="Keyword">import</a> <a id="726" href="Reflection.html" class="Module">Reflection</a> <a id="737" class="Symbol">as</a> <a id="740" class="Module">Rfl</a> <a id="744" class="Keyword">hiding</a> <a id="751" class="Symbol">(</a><a id="752" href="Agda.Builtin.Reflection.html#7543" class="Postulate">return</a><a id="758" class="Symbol">;</a> <a id="760" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">_&gt;&gt;=_</a><a id="765" class="Symbol">)</a>
<a id="767" class="Keyword">import</a> <a id="774" href="Reflection.TypeChecking.Monad.Categorical.html" class="Module">Reflection.TypeChecking.Monad.Categorical</a> <a id="816" class="Symbol">as</a> <a id="819" class="Module">TC</a>
<a id="822" class="Keyword">open</a> <a id="827" class="Keyword">import</a> <a id="834" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="851" class="Keyword">using</a> <a id="857" class="Symbol">(</a><a id="858" href="Relation.Nullary.html#653" class="Function Operator">¬_</a><a id="860" class="Symbol">;</a> <a id="862" href="Relation.Nullary.html#1508" class="Record">Dec</a><a id="865" class="Symbol">;</a> <a id="867" href="Relation.Nullary.html#1645" class="InductiveConstructor">yes</a><a id="870" class="Symbol">;</a> <a id="872" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a><a id="874" class="Symbol">)</a>
<a id="876" class="Keyword">open</a> <a id="881" class="Keyword">import</a> <a id="888" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a> <a id="915" class="Keyword">using</a> <a id="921" class="Symbol">(</a><a id="922" href="Relation.Nullary.Decidable.Core.html#1027" class="Function">isYes</a><a id="927" class="Symbol">)</a>
<a id="929" class="Keyword">open</a> <a id="934" class="Keyword">import</a> <a id="941" href="SMT.Theory.html" class="Module">SMT.Theory</a>
<a id="952" class="Keyword">open</a> <a id="957" class="Keyword">import</a> <a id="964" href="SMT.Theory.Raw.Base.html" class="Module">SMT.Theory.Raw.Base</a>

<a id="985" class="Keyword">private</a>
  <a id="995" class="Keyword">open</a> <a id="1000" class="Keyword">module</a> <a id="TCMonad"></a><a id="1007" href="SMT.Theory.Raw.Reflection.html#1007" class="Module">TCMonad</a> <a id="1015" class="Symbol">{</a><a id="1016" href="SMT.Theory.Raw.Reflection.html#1016" class="Bound">ℓ</a><a id="1017" class="Symbol">}</a> <a id="1019" class="Symbol">=</a> <a id="1021" href="Category.Monad.html#832" class="Module">Category.Monad.RawMonad</a> <a id="1045" class="Symbol">{</a><a id="1046" href="SMT.Theory.Raw.Reflection.html#1016" class="Bound">ℓ</a><a id="1047" class="Symbol">}</a> <a id="1049" href="Reflection.TypeChecking.Monad.Categorical.html#1061" class="Function">TC.monad</a> <a id="1058" class="Keyword">renaming</a> <a id="1067" class="Symbol">(</a><a id="1068" href="Category.Applicative.Indexed.html#1034" class="Function Operator">_⊛_</a> <a id="1072" class="Symbol">to</a> <a id="TCMonad._⊛_"></a><a id="1075" href="SMT.Theory.Raw.Reflection.html#1075" class="Function Operator">_&lt;*&gt;_</a><a id="1080" class="Symbol">)</a>

<a id="1083" class="Keyword">private</a>
  <a id="1093" class="Keyword">variable</a>
    <a id="1106" href="SMT.Theory.Raw.Reflection.html#1106" class="Generalizable">ℓ</a> <a id="1108" class="Symbol">:</a> <a id="1110" href="Agda.Primitive.html#597" class="Postulate">Level</a>
    <a id="1120" href="SMT.Theory.Raw.Reflection.html#1120" class="Generalizable">A</a> <a id="1122" class="Symbol">:</a> <a id="1124" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="1128" href="SMT.Theory.Raw.Reflection.html#1106" class="Generalizable">ℓ</a>


<a id="1132" class="Keyword">private</a>
  <a id="1142" class="Comment">-- We don&#39;t know the type of raw function symbols, so just look at</a>
  <a id="1211" class="Comment">-- the arguments. Design decision: only keep visible arguments.</a>
  <a id="argTypes"></a><a id="1277" href="SMT.Theory.Raw.Reflection.html#1277" class="Function">argTypes</a> <a id="1286" class="Symbol">:</a> <a id="1288" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="1293" class="Symbol">(</a><a id="1294" href="Agda.Builtin.Reflection.html#3255" class="Datatype">Arg</a> <a id="1298" href="SMT.Theory.Raw.Reflection.html#1120" class="Generalizable">A</a><a id="1299" class="Symbol">)</a> <a id="1301" class="Symbol">→</a> <a id="1303" href="SMT.Theory.Base.html#489" class="Record">Signature</a> <a id="1313" href="SMT.Theory.Raw.Base.html#1032" class="InductiveConstructor">⋆</a>
  <a id="1317" href="SMT.Theory.Raw.Reflection.html#1277" class="Function">argTypes</a> <a id="1326" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>              <a id="1342" class="Symbol">.</a><a id="1343" href="SMT.Theory.Base.html#547" class="Field">ArgSorts</a> <a id="1352" class="Symbol">=</a> <a id="1354" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
  <a id="1359" href="SMT.Theory.Raw.Reflection.html#1277" class="Function">argTypes</a> <a id="1368" class="Symbol">(</a><a id="1369" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="1374" class="Symbol">_</a> <a id="1376" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1378" href="SMT.Theory.Raw.Reflection.html#1378" class="Bound">args</a><a id="1382" class="Symbol">)</a> <a id="1384" class="Symbol">.</a><a id="1385" href="SMT.Theory.Base.html#547" class="Field">ArgSorts</a> <a id="1394" class="Symbol">=</a> <a id="1396" href="SMT.Theory.Raw.Base.html#1032" class="InductiveConstructor">⋆</a> <a id="1398" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1400" href="SMT.Theory.Raw.Reflection.html#1277" class="Function">argTypes</a> <a id="1409" href="SMT.Theory.Raw.Reflection.html#1378" class="Bound">args</a> <a id="1414" class="Symbol">.</a><a id="1415" href="SMT.Theory.Base.html#547" class="Field">ArgSorts</a>
  <a id="1426" href="SMT.Theory.Raw.Reflection.html#1277" class="CatchallClause Function">argTypes</a><a id="1434" class="CatchallClause"> </a><a id="1435" class="CatchallClause Symbol">(_</a><a id="1437" class="CatchallClause">      </a><a id="1443" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="1444" class="CatchallClause"> </a><a id="1445" href="SMT.Theory.Raw.Reflection.html#1445" class="CatchallClause Bound">args</a><a id="1449" class="CatchallClause Symbol">)</a><a id="1450" class="CatchallClause"> </a><a id="1451" class="CatchallClause Symbol">.</a><a id="1452" href="SMT.Theory.Base.html#547" class="CatchallClause Field">ArgSorts</a> <a id="1461" class="Symbol">=</a>     <a id="1467" href="SMT.Theory.Raw.Reflection.html#1277" class="Function">argTypes</a> <a id="1476" href="SMT.Theory.Raw.Reflection.html#1445" class="Bound">args</a> <a id="1481" class="Symbol">.</a><a id="1482" href="SMT.Theory.Base.html#547" class="Field">ArgSorts</a>


<a id="reflectToRawVar"></a><a id="1493" href="SMT.Theory.Raw.Reflection.html#1493" class="Function">reflectToRawVar</a> <a id="1509" class="Symbol">:</a> <a id="1511" class="Symbol">(</a><a id="1512" href="SMT.Theory.Raw.Reflection.html#1512" class="Bound">Γ</a> <a id="1514" class="Symbol">:</a> <a id="1516" href="SMT.Theory.Raw.Base.html#2678" class="Function">RawCtxt</a><a id="1523" class="Symbol">)</a> <a id="1525" class="Symbol">(</a><a id="1526" href="SMT.Theory.Raw.Reflection.html#1526" class="Bound">n</a> <a id="1528" class="Symbol">:</a> <a id="1530" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="1531" class="Symbol">)</a> <a id="1533" class="Symbol">→</a> <a id="1535" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="1538" class="Symbol">(</a><a id="1539" href="Data.Product.html#1788" class="Function">∃[</a> <a id="1542" href="SMT.Theory.Raw.Reflection.html#1542" class="Bound">σ</a> <a id="1544" href="Data.Product.html#1788" class="Function">]</a> <a id="1546" class="Symbol">(</a><a id="1547" href="SMT.Theory.Raw.Reflection.html#1512" class="Bound">Γ</a> <a id="1549" href="SMT.Theory.Raw.Base.html#2716" class="Function Operator">∋ᵣ</a> <a id="1552" href="SMT.Theory.Raw.Reflection.html#1542" class="Bound">σ</a><a id="1553" class="Symbol">))</a>
<a id="1556" href="SMT.Theory.Raw.Reflection.html#1493" class="Function">reflectToRawVar</a> <a id="1572" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>      <a id="1580" href="SMT.Theory.Raw.Reflection.html#1580" class="Bound">n</a>       <a id="1588" class="Symbol">=</a> <a id="1590" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="1603" class="String">&quot;Variable out of bounds&quot;</a>
<a id="1628" href="SMT.Theory.Raw.Reflection.html#1493" class="Function">reflectToRawVar</a> <a id="1644" class="Symbol">(</a><a id="1645" href="SMT.Theory.Raw.Reflection.html#1645" class="Bound">x</a> <a id="1647" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1649" href="SMT.Theory.Raw.Reflection.html#1649" class="Bound">Γ</a><a id="1650" class="Symbol">)</a> <a id="1652" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="1660" class="Symbol">=</a> <a id="1662" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="1669" class="Symbol">(_</a> <a id="1672" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1674" href="Data.Fin.Base.html#1160" class="InductiveConstructor">zero</a> <a id="1679" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1681" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="1685" class="Symbol">)</a>
<a id="1687" href="SMT.Theory.Raw.Reflection.html#1493" class="Function">reflectToRawVar</a> <a id="1703" class="Symbol">(</a><a id="1704" href="SMT.Theory.Raw.Reflection.html#1704" class="Bound">x</a> <a id="1706" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1708" href="SMT.Theory.Raw.Reflection.html#1708" class="Bound">Γ</a><a id="1709" class="Symbol">)</a> <a id="1711" class="Symbol">(</a><a id="1712" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1716" href="SMT.Theory.Raw.Reflection.html#1716" class="Bound">n</a><a id="1717" class="Symbol">)</a> <a id="1719" class="Symbol">=</a> <a id="1721" class="Keyword">do</a>
  <a id="1726" href="SMT.Theory.Raw.Reflection.html#1726" class="Bound">σ</a> <a id="1728" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1730" href="SMT.Theory.Raw.Reflection.html#1730" class="Bound">i</a> <a id="1732" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1734" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="1739" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="1741" href="SMT.Theory.Raw.Reflection.html#1493" class="Function">reflectToRawVar</a> <a id="1757" href="SMT.Theory.Raw.Reflection.html#1708" class="Bound">Γ</a> <a id="1759" href="SMT.Theory.Raw.Reflection.html#1716" class="Bound">n</a>
  <a id="1763" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="1770" class="Symbol">(</a><a id="1771" href="SMT.Theory.Raw.Reflection.html#1726" class="Bound">σ</a> <a id="1773" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1775" href="Data.Fin.Base.html#1191" class="InductiveConstructor">suc</a> <a id="1779" href="SMT.Theory.Raw.Reflection.html#1730" class="Bound">i</a> <a id="1781" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1783" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="1787" class="Symbol">)</a>


<a id="strengthenVar"></a><a id="1791" href="SMT.Theory.Raw.Reflection.html#1791" class="Function">strengthenVar</a> <a id="1805" class="Symbol">:</a> <a id="1807" class="Symbol">(</a><a id="1808" href="SMT.Theory.Raw.Reflection.html#1808" class="Bound">fv</a> <a id="1811" href="SMT.Theory.Raw.Reflection.html#1811" class="Bound">n</a> <a id="1813" class="Symbol">:</a> <a id="1815" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="1816" class="Symbol">)</a> <a id="1818" class="Symbol">→</a> <a id="1820" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="1823" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="1825" href="SMT.Theory.Raw.Reflection.html#1791" class="Function">strengthenVar</a> <a id="1839" href="SMT.Theory.Raw.Reflection.html#1839" class="Bound">fv</a> <a id="1842" href="SMT.Theory.Raw.Reflection.html#1842" class="Bound">n</a> <a id="1844" class="Symbol">=</a>
  <a id="1848" href="Function.Base.html#4121" class="Function Operator">case</a> <a id="1853" href="SMT.Theory.Raw.Reflection.html#1842" class="Bound">n</a> <a id="1855" href="Data.Nat.Properties.html#8944" class="Function Operator">Nat.&lt;?</a> <a id="1862" href="SMT.Theory.Raw.Reflection.html#1839" class="Bound">fv</a> <a id="1865" href="Function.Base.html#4121" class="Function Operator">of</a> <a id="1868" class="Symbol">λ</a> <a id="1870" class="Keyword">where</a>
    <a id="1880" class="Symbol">(</a><a id="1881" href="Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="1885" class="Symbol">_)</a> <a id="1888" class="Symbol">→</a> <a id="1890" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="1903" class="String">&quot;Dependent quantification in term&quot;</a>
    <a id="1942" class="Symbol">(</a><a id="1943" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="1946" class="Symbol">_)</a>  <a id="1950" class="Symbol">→</a> <a id="1952" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="1959" class="Symbol">(</a><a id="1960" href="SMT.Theory.Raw.Reflection.html#1842" class="Bound">n</a> <a id="1962" href="Data.Nat.Base.html#2735" class="Primitive Operator">∸</a> <a id="1964" href="SMT.Theory.Raw.Reflection.html#1839" class="Bound">fv</a><a id="1966" class="Symbol">)</a>


<a id="1970" class="Keyword">private</a>
  <a id="_∈-FVArgs_"></a><a id="1980" href="SMT.Theory.Raw.Reflection.html#1980" class="Function Operator">_∈-FVArgs_</a>    <a id="1994" class="Symbol">:</a> <a id="1996" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="1998" class="Symbol">→</a> <a id="2000" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="2005" class="Symbol">(</a><a id="2006" href="Agda.Builtin.Reflection.html#3255" class="Datatype">Arg</a> <a id="2010" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a><a id="2014" class="Symbol">)</a> <a id="2016" class="Symbol">→</a> <a id="2018" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="_∈-FVClauses_"></a><a id="2025" href="SMT.Theory.Raw.Reflection.html#2025" class="Function Operator">_∈-FVClauses_</a> <a id="2039" class="Symbol">:</a> <a id="2041" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2043" class="Symbol">→</a> <a id="2045" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="2050" href="Agda.Builtin.Reflection.html#4303" class="Datatype">Clause</a> <a id="2057" class="Symbol">→</a> <a id="2059" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="_∈-FVClause_"></a><a id="2066" href="SMT.Theory.Raw.Reflection.html#2066" class="Function Operator">_∈-FVClause_</a>  <a id="2080" class="Symbol">:</a> <a id="2082" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2084" class="Symbol">→</a> <a id="2086" href="Agda.Builtin.Reflection.html#4303" class="Datatype">Clause</a> <a id="2093" class="Symbol">→</a> <a id="2095" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="_∈-FVSort_"></a><a id="2102" href="SMT.Theory.Raw.Reflection.html#2102" class="Function Operator">_∈-FVSort_</a>    <a id="2116" class="Symbol">:</a> <a id="2118" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2120" class="Symbol">→</a> <a id="2122" href="Agda.Builtin.Reflection.html#4265" class="Datatype">Sort</a> <a id="2127" class="Symbol">→</a> <a id="2129" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>

  <a id="_∈-FV_"></a><a id="2137" href="SMT.Theory.Raw.Reflection.html#2137" class="Function Operator">_∈-FV_</a> <a id="2144" class="Symbol">:</a> <a id="2146" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2148" class="Symbol">→</a> <a id="2150" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="2155" class="Symbol">→</a> <a id="2157" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="2164" href="SMT.Theory.Raw.Reflection.html#2164" class="Bound">x</a> <a id="2166" href="SMT.Theory.Raw.Reflection.html#2137" class="Function Operator">∈-FV</a> <a id="2171" href="Agda.Builtin.Reflection.html#4348" class="InductiveConstructor">var</a> <a id="2175" href="SMT.Theory.Raw.Reflection.html#2175" class="Bound">y</a> <a id="2177" href="SMT.Theory.Raw.Reflection.html#2177" class="Bound">args</a>             <a id="2194" class="Symbol">=</a> <a id="2196" href="Relation.Nullary.Decidable.Core.html#1027" class="Function">isYes</a> <a id="2202" class="Symbol">(</a><a id="2203" href="SMT.Theory.Raw.Reflection.html#2164" class="Bound">x</a> <a id="2205" href="Data.Nat.Properties.html#2284" class="Function Operator">Nat.≟</a> <a id="2211" href="SMT.Theory.Raw.Reflection.html#2175" class="Bound">y</a><a id="2212" class="Symbol">)</a> <a id="2214" href="Data.Bool.Base.html#1044" class="Function Operator">∨</a> <a id="2216" href="SMT.Theory.Raw.Reflection.html#2164" class="Bound">x</a> <a id="2218" href="SMT.Theory.Raw.Reflection.html#1980" class="Function Operator">∈-FVArgs</a> <a id="2227" href="SMT.Theory.Raw.Reflection.html#2177" class="Bound">args</a>
  <a id="2234" href="SMT.Theory.Raw.Reflection.html#2234" class="Bound">x</a> <a id="2236" href="SMT.Theory.Raw.Reflection.html#2137" class="Function Operator">∈-FV</a> <a id="2241" href="Agda.Builtin.Reflection.html#4404" class="InductiveConstructor">con</a> <a id="2245" class="Symbol">_</a> <a id="2247" href="SMT.Theory.Raw.Reflection.html#2247" class="Bound">args</a>             <a id="2264" class="Symbol">=</a> <a id="2266" href="SMT.Theory.Raw.Reflection.html#2234" class="Bound">x</a> <a id="2268" href="SMT.Theory.Raw.Reflection.html#1980" class="Function Operator">∈-FVArgs</a> <a id="2277" href="SMT.Theory.Raw.Reflection.html#2247" class="Bound">args</a>
  <a id="2284" href="SMT.Theory.Raw.Reflection.html#2284" class="Bound">x</a> <a id="2286" href="SMT.Theory.Raw.Reflection.html#2137" class="Function Operator">∈-FV</a> <a id="2291" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="2295" class="Symbol">_</a> <a id="2297" href="SMT.Theory.Raw.Reflection.html#2297" class="Bound">args</a>             <a id="2314" class="Symbol">=</a> <a id="2316" href="SMT.Theory.Raw.Reflection.html#2284" class="Bound">x</a> <a id="2318" href="SMT.Theory.Raw.Reflection.html#1980" class="Function Operator">∈-FVArgs</a> <a id="2327" href="SMT.Theory.Raw.Reflection.html#2297" class="Bound">args</a>
  <a id="2334" href="SMT.Theory.Raw.Reflection.html#2334" class="Bound">x</a> <a id="2336" href="SMT.Theory.Raw.Reflection.html#2137" class="Function Operator">∈-FV</a> <a id="2341" href="Agda.Builtin.Reflection.html#4518" class="InductiveConstructor">lam</a> <a id="2345" class="Symbol">_</a> <a id="2347" class="Symbol">(</a><a id="2348" href="Agda.Builtin.Reflection.html#3538" class="InductiveConstructor">abs</a> <a id="2352" class="Symbol">_</a> <a id="2354" href="SMT.Theory.Raw.Reflection.html#2354" class="Bound">t</a><a id="2355" class="Symbol">)</a>        <a id="2364" class="Symbol">=</a> <a id="2366" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2370" href="SMT.Theory.Raw.Reflection.html#2334" class="Bound">x</a> <a id="2372" href="SMT.Theory.Raw.Reflection.html#2137" class="Function Operator">∈-FV</a> <a id="2377" href="SMT.Theory.Raw.Reflection.html#2354" class="Bound">t</a>
  <a id="2381" href="SMT.Theory.Raw.Reflection.html#2381" class="Bound">x</a> <a id="2383" href="SMT.Theory.Raw.Reflection.html#2137" class="Function Operator">∈-FV</a> <a id="2388" href="Agda.Builtin.Reflection.html#4571" class="InductiveConstructor">pat-lam</a> <a id="2396" href="SMT.Theory.Raw.Reflection.html#2396" class="Bound">cs</a> <a id="2399" href="SMT.Theory.Raw.Reflection.html#2399" class="Bound">args</a>        <a id="2411" class="Symbol">=</a> <a id="2413" href="SMT.Theory.Raw.Reflection.html#2381" class="Bound">x</a> <a id="2415" href="SMT.Theory.Raw.Reflection.html#2025" class="Function Operator">∈-FVClauses</a> <a id="2427" href="SMT.Theory.Raw.Reflection.html#2396" class="Bound">cs</a> <a id="2430" href="Data.Bool.Base.html#1044" class="Function Operator">∨</a> <a id="2432" href="SMT.Theory.Raw.Reflection.html#2381" class="Bound">x</a> <a id="2434" href="SMT.Theory.Raw.Reflection.html#1980" class="Function Operator">∈-FVArgs</a> <a id="2443" href="SMT.Theory.Raw.Reflection.html#2399" class="Bound">args</a>
  <a id="2450" href="SMT.Theory.Raw.Reflection.html#2450" class="Bound">x</a> <a id="2452" href="SMT.Theory.Raw.Reflection.html#2137" class="Function Operator">∈-FV</a> <a id="2457" href="Agda.Builtin.Reflection.html#4636" class="InductiveConstructor">pi</a> <a id="2460" class="Symbol">(</a><a id="2461" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="2465" class="Symbol">_</a> <a id="2467" href="SMT.Theory.Raw.Reflection.html#2467" class="Bound">a</a><a id="2468" class="Symbol">)</a> <a id="2470" class="Symbol">(</a><a id="2471" href="Agda.Builtin.Reflection.html#3538" class="InductiveConstructor">abs</a> <a id="2475" class="Symbol">_</a> <a id="2477" href="SMT.Theory.Raw.Reflection.html#2477" class="Bound">b</a><a id="2478" class="Symbol">)</a> <a id="2480" class="Symbol">=</a> <a id="2482" href="SMT.Theory.Raw.Reflection.html#2450" class="Bound">x</a> <a id="2484" href="SMT.Theory.Raw.Reflection.html#2137" class="Function Operator">∈-FV</a> <a id="2489" href="SMT.Theory.Raw.Reflection.html#2467" class="Bound">a</a> <a id="2491" href="Data.Bool.Base.html#1044" class="Function Operator">∨</a> <a id="2493" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2497" href="SMT.Theory.Raw.Reflection.html#2450" class="Bound">x</a> <a id="2499" href="SMT.Theory.Raw.Reflection.html#2137" class="Function Operator">∈-FV</a> <a id="2504" href="SMT.Theory.Raw.Reflection.html#2477" class="Bound">b</a>
  <a id="2508" href="SMT.Theory.Raw.Reflection.html#2508" class="Bound">x</a> <a id="2510" href="SMT.Theory.Raw.Reflection.html#2137" class="Function Operator">∈-FV</a> <a id="2515" href="Reflection.Term.html#1396" class="InductiveConstructor">agda-sort</a> <a id="2525" href="SMT.Theory.Raw.Reflection.html#2525" class="Bound">s</a>            <a id="2538" class="Symbol">=</a> <a id="2540" href="SMT.Theory.Raw.Reflection.html#2508" class="Bound">x</a> <a id="2542" href="SMT.Theory.Raw.Reflection.html#2102" class="Function Operator">∈-FVSort</a> <a id="2551" href="SMT.Theory.Raw.Reflection.html#2525" class="Bound">s</a>
  <a id="2555" href="SMT.Theory.Raw.Reflection.html#2555" class="Bound">x</a> <a id="2557" href="SMT.Theory.Raw.Reflection.html#2137" class="Function Operator">∈-FV</a> <a id="2562" href="Agda.Builtin.Reflection.html#4719" class="InductiveConstructor">lit</a> <a id="2566" href="SMT.Theory.Raw.Reflection.html#2566" class="Bound">l</a>                  <a id="2585" class="Symbol">=</a> <a id="2587" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="2595" href="SMT.Theory.Raw.Reflection.html#2595" class="Bound">x</a> <a id="2597" href="SMT.Theory.Raw.Reflection.html#2137" class="Function Operator">∈-FV</a> <a id="2602" href="Agda.Builtin.Reflection.html#4754" class="InductiveConstructor">meta</a> <a id="2607" class="Symbol">_</a> <a id="2609" href="SMT.Theory.Raw.Reflection.html#2609" class="Bound">args</a>            <a id="2625" class="Symbol">=</a> <a id="2627" href="SMT.Theory.Raw.Reflection.html#2595" class="Bound">x</a> <a id="2629" href="SMT.Theory.Raw.Reflection.html#1980" class="Function Operator">∈-FVArgs</a> <a id="2638" href="SMT.Theory.Raw.Reflection.html#2609" class="Bound">args</a>
  <a id="2645" href="SMT.Theory.Raw.Reflection.html#2645" class="Bound">x</a> <a id="2647" href="SMT.Theory.Raw.Reflection.html#2137" class="Function Operator">∈-FV</a> <a id="2652" href="Agda.Builtin.Reflection.html#4804" class="InductiveConstructor">unknown</a>                <a id="2675" class="Symbol">=</a> <a id="2677" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>

  <a id="2686" class="Symbol">_</a> <a id="2688" href="SMT.Theory.Raw.Reflection.html#1980" class="Function Operator">∈-FVArgs</a> <a id="2697" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>             <a id="2712" class="Symbol">=</a> <a id="2714" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="2722" href="SMT.Theory.Raw.Reflection.html#2722" class="Bound">x</a> <a id="2724" href="SMT.Theory.Raw.Reflection.html#1980" class="Function Operator">∈-FVArgs</a> <a id="2733" class="Symbol">(</a><a id="2734" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="2738" class="Symbol">_</a> <a id="2740" href="SMT.Theory.Raw.Reflection.html#2740" class="Bound">t</a> <a id="2742" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2744" href="SMT.Theory.Raw.Reflection.html#2744" class="Bound">ts</a><a id="2746" class="Symbol">)</a> <a id="2748" class="Symbol">=</a> <a id="2750" href="SMT.Theory.Raw.Reflection.html#2722" class="Bound">x</a> <a id="2752" href="SMT.Theory.Raw.Reflection.html#2137" class="Function Operator">∈-FV</a> <a id="2757" href="SMT.Theory.Raw.Reflection.html#2740" class="Bound">t</a> <a id="2759" href="Data.Bool.Base.html#1044" class="Function Operator">∨</a> <a id="2761" href="SMT.Theory.Raw.Reflection.html#2722" class="Bound">x</a> <a id="2763" href="SMT.Theory.Raw.Reflection.html#1980" class="Function Operator">∈-FVArgs</a> <a id="2772" href="SMT.Theory.Raw.Reflection.html#2744" class="Bound">ts</a>

  <a id="2778" href="SMT.Theory.Raw.Reflection.html#2778" class="Bound">x</a> <a id="2780" href="SMT.Theory.Raw.Reflection.html#2025" class="Function Operator">∈-FVClauses</a> <a id="2792" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>       <a id="2801" class="Symbol">=</a> <a id="2803" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="2811" href="SMT.Theory.Raw.Reflection.html#2811" class="Bound">x</a> <a id="2813" href="SMT.Theory.Raw.Reflection.html#2025" class="Function Operator">∈-FVClauses</a> <a id="2825" class="Symbol">(</a><a id="2826" href="SMT.Theory.Raw.Reflection.html#2826" class="Bound">c</a> <a id="2828" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2830" href="SMT.Theory.Raw.Reflection.html#2830" class="Bound">cs</a><a id="2832" class="Symbol">)</a> <a id="2834" class="Symbol">=</a> <a id="2836" href="SMT.Theory.Raw.Reflection.html#2811" class="Bound">x</a> <a id="2838" href="SMT.Theory.Raw.Reflection.html#2066" class="Function Operator">∈-FVClause</a> <a id="2849" href="SMT.Theory.Raw.Reflection.html#2826" class="Bound">c</a> <a id="2851" href="Data.Bool.Base.html#1044" class="Function Operator">∨</a> <a id="2853" href="SMT.Theory.Raw.Reflection.html#2811" class="Bound">x</a> <a id="2855" href="SMT.Theory.Raw.Reflection.html#2025" class="Function Operator">∈-FVClauses</a> <a id="2867" href="SMT.Theory.Raw.Reflection.html#2830" class="Bound">cs</a>

  <a id="2873" class="Comment">-- Ignores types of bound variables</a>
  <a id="2911" href="SMT.Theory.Raw.Reflection.html#2911" class="Bound">x</a> <a id="2913" href="SMT.Theory.Raw.Reflection.html#2066" class="Function Operator">∈-FVClause</a> <a id="2924" href="Agda.Builtin.Reflection.html#5172" class="InductiveConstructor">Clause.clause</a>        <a id="2945" href="SMT.Theory.Raw.Reflection.html#2945" class="Bound">tel</a> <a id="2949" href="SMT.Theory.Raw.Reflection.html#2949" class="Bound">ps</a> <a id="2952" href="SMT.Theory.Raw.Reflection.html#2952" class="Bound">t</a> <a id="2954" class="Symbol">=</a> <a id="2956" class="Symbol">(</a><a id="2957" href="SMT.Theory.Raw.Reflection.html#2911" class="Bound">x</a> <a id="2959" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">Nat.+</a> <a id="2965" href="Data.List.Base.html#4577" class="Function">length</a> <a id="2972" href="SMT.Theory.Raw.Reflection.html#2945" class="Bound">tel</a><a id="2975" class="Symbol">)</a> <a id="2977" href="SMT.Theory.Raw.Reflection.html#2137" class="Function Operator">∈-FV</a> <a id="2982" href="SMT.Theory.Raw.Reflection.html#2952" class="Bound">t</a>
  <a id="2986" href="SMT.Theory.Raw.Reflection.html#2986" class="Bound">x</a> <a id="2988" href="SMT.Theory.Raw.Reflection.html#2066" class="Function Operator">∈-FVClause</a> <a id="2999" href="Agda.Builtin.Reflection.html#5275" class="InductiveConstructor">Clause.absurd-clause</a> <a id="3020" href="SMT.Theory.Raw.Reflection.html#3020" class="Bound">tel</a> <a id="3024" href="SMT.Theory.Raw.Reflection.html#3024" class="Bound">ps</a>   <a id="3029" class="Symbol">=</a> <a id="3031" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>

  <a id="3040" href="SMT.Theory.Raw.Reflection.html#3040" class="Bound">x</a> <a id="3042" href="SMT.Theory.Raw.Reflection.html#2102" class="Function Operator">∈-FVSort</a> <a id="3051" href="Agda.Builtin.Reflection.html#4840" class="InductiveConstructor">Sort.set</a> <a id="3060" href="SMT.Theory.Raw.Reflection.html#3060" class="Bound">t</a>   <a id="3064" class="Symbol">=</a> <a id="3066" href="SMT.Theory.Raw.Reflection.html#3040" class="Bound">x</a> <a id="3068" href="SMT.Theory.Raw.Reflection.html#2137" class="Function Operator">∈-FV</a> <a id="3073" href="SMT.Theory.Raw.Reflection.html#3060" class="Bound">t</a>
  <a id="3077" href="SMT.Theory.Raw.Reflection.html#3077" class="Bound">x</a> <a id="3079" href="SMT.Theory.Raw.Reflection.html#2102" class="Function Operator">∈-FVSort</a> <a id="3088" href="Agda.Builtin.Reflection.html#4870" class="InductiveConstructor">Sort.lit</a> <a id="3097" href="SMT.Theory.Raw.Reflection.html#3097" class="Bound">n</a>   <a id="3101" class="Symbol">=</a> <a id="3103" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="3111" href="SMT.Theory.Raw.Reflection.html#3111" class="Bound">x</a> <a id="3113" href="SMT.Theory.Raw.Reflection.html#2102" class="Function Operator">∈-FVSort</a> <a id="3122" href="Agda.Builtin.Reflection.html#4899" class="InductiveConstructor">Sort.unknown</a> <a id="3135" class="Symbol">=</a> <a id="3137" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>

<a id="3144" class="Keyword">private</a>
  <a id="3154" class="Keyword">pattern</a> <a id="`pos"></a><a id="3162" href="SMT.Theory.Raw.Reflection.html#3162" class="InductiveConstructor">`pos</a>    <a id="3170" href="SMT.Theory.Raw.Reflection.html#3199" class="Bound">a</a> <a id="3172" class="Symbol">=</a> <a id="3174" href="Agda.Builtin.Reflection.html#4404" class="InductiveConstructor">con</a> <a id="3178" class="Symbol">(</a><a id="3179" class="Keyword">quote</a> <a id="3185" href="Agda.Builtin.Int.html#264" class="InductiveConstructor Operator">Int.+_</a><a id="3191" class="Symbol">)</a> <a id="3193" class="Symbol">(</a><a id="3194" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="3199" href="SMT.Theory.Raw.Reflection.html#3199" class="Bound">a</a> <a id="3201" class="InductiveConstructor Operator">∷</a> <a id="3203" class="InductiveConstructor">[]</a><a id="3205" class="Symbol">)</a>
  <a id="3209" class="Comment">-- pattern `negsuc a = con (quote Int.-[1+_]) (vArg a ∷ [])</a>

<a id="3270" class="Comment">-- Dummy name used as a function symbol of type TERM _ → ⋆ to wrap variables.</a>
<a id="rawVar"></a><a id="3348" href="SMT.Theory.Raw.Reflection.html#3348" class="Function">rawVar</a> <a id="3355" class="Symbol">:</a> <a id="3357" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
<a id="3359" href="SMT.Theory.Raw.Reflection.html#3348" class="Function">rawVar</a> <a id="3366" class="Symbol">=</a> <a id="3368" class="Symbol">_</a>

<a id="3371" class="Keyword">mutual</a>
  <a id="reflectToRawTerm"></a><a id="3380" href="SMT.Theory.Raw.Reflection.html#3380" class="Function">reflectToRawTerm</a> <a id="3397" class="Symbol">:</a> <a id="3399" class="Symbol">(</a><a id="3400" href="SMT.Theory.Raw.Reflection.html#3400" class="Bound">Γ</a> <a id="3402" class="Symbol">:</a> <a id="3404" href="SMT.Theory.Raw.Base.html#2678" class="Function">RawCtxt</a><a id="3411" class="Symbol">)</a> <a id="3413" class="Symbol">(</a><a id="3414" href="SMT.Theory.Raw.Reflection.html#3414" class="Bound">fv</a> <a id="3417" class="Symbol">:</a> <a id="3419" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="3420" class="Symbol">)</a> <a id="3422" class="Symbol">→</a> <a id="3424" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="3429" class="Symbol">→</a> <a id="3431" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="3434" class="Symbol">(</a><a id="3435" href="SMT.Theory.Raw.Base.html#2751" class="Datatype">RawTerm</a> <a id="3443" href="SMT.Theory.Raw.Reflection.html#3400" class="Bound">Γ</a> <a id="3445" href="SMT.Theory.Raw.Base.html#1032" class="InductiveConstructor">⋆</a><a id="3446" class="Symbol">)</a>
  <a id="3450" href="SMT.Theory.Raw.Reflection.html#3380" class="Function">reflectToRawTerm</a> <a id="3467" href="SMT.Theory.Raw.Reflection.html#3467" class="Bound">Γ</a> <a id="3469" href="SMT.Theory.Raw.Reflection.html#3469" class="Bound">fv</a> <a id="3472" class="Symbol">(</a><a id="3473" href="Agda.Builtin.Reflection.html#4348" class="InductiveConstructor">var</a> <a id="3477" href="SMT.Theory.Raw.Reflection.html#3477" class="Bound">x</a> <a id="3479" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3481" class="Symbol">)</a> <a id="3483" class="Symbol">=</a> <a id="3485" class="Keyword">do</a>
    <a id="3492" href="SMT.Theory.Raw.Reflection.html#3492" class="Bound">σ</a> <a id="3494" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3496" href="SMT.Theory.Raw.Reflection.html#3496" class="Bound">y</a> <a id="3498" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3500" href="SMT.Theory.Raw.Reflection.html#1493" class="Function">reflectToRawVar</a> <a id="3516" href="SMT.Theory.Raw.Reflection.html#3467" class="Bound">Γ</a> <a id="3518" href="Category.Monad.Indexed.html#814" class="Function Operator">=&lt;&lt;</a> <a id="3522" href="SMT.Theory.Raw.Reflection.html#1791" class="Function">strengthenVar</a> <a id="3536" href="SMT.Theory.Raw.Reflection.html#3469" class="Bound">fv</a> <a id="3539" href="SMT.Theory.Raw.Reflection.html#3477" class="Bound">x</a>
    <a id="3545" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="3552" class="Symbol">(</a><a id="3553" href="SMT.Theory.Raw.Base.html#2859" class="InductiveConstructor">appᵣ</a> <a id="3558" class="Symbol">{</a><a id="3559" class="Argument">Σ</a> <a id="3561" class="Symbol">=</a> <a id="3563" class="Keyword">record</a><a id="3569" class="Symbol">{</a><a id="3570" href="SMT.Theory.Base.html#547" class="Field">ArgSorts</a> <a id="3579" class="Symbol">=</a> <a id="3581" href="SMT.Theory.Raw.Reflection.html#3492" class="Bound">σ</a> <a id="3583" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3585" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3587" class="Symbol">}}</a> <a id="3590" class="Symbol">(</a><a id="3591" class="Keyword">quote</a> <a id="3597" href="SMT.Theory.Raw.Reflection.html#3348" class="Function">rawVar</a><a id="3603" class="Symbol">)</a> <a id="3605" class="Symbol">(</a><a id="3606" href="SMT.Theory.Raw.Base.html#2789" class="InductiveConstructor">varᵣ</a> <a id="3611" href="SMT.Theory.Raw.Reflection.html#3496" class="Bound">y</a> <a id="3613" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="3615" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="3617" class="Symbol">))</a>
  <a id="3622" href="SMT.Theory.Raw.Reflection.html#3380" class="CatchallClause Function">reflectToRawTerm</a><a id="3638" class="CatchallClause"> </a><a id="3639" href="SMT.Theory.Raw.Reflection.html#3639" class="CatchallClause Bound">Γ</a><a id="3640" class="CatchallClause"> </a><a id="3641" class="CatchallClause Symbol">_</a><a id="3642" class="CatchallClause">  </a><a id="3644" class="CatchallClause Symbol">(</a><a id="3645" href="Agda.Builtin.Reflection.html#4348" class="CatchallClause InductiveConstructor">var</a><a id="3648" class="CatchallClause"> </a><a id="3649" class="CatchallClause Symbol">_</a><a id="3650" class="CatchallClause"> </a><a id="3651" class="CatchallClause Symbol">_)</a>  <a id="3655" class="Symbol">=</a> <a id="3657" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="3670" class="String">&quot;Higher-order variable&quot;</a>
  <a id="3696" href="SMT.Theory.Raw.Reflection.html#3380" class="Function">reflectToRawTerm</a> <a id="3713" href="SMT.Theory.Raw.Reflection.html#3713" class="Bound">Γ</a> <a id="3715" class="Symbol">_</a>  <a id="3718" class="Symbol">(</a><a id="3719" href="Agda.Builtin.Reflection.html#4719" class="InductiveConstructor">lit</a> <a id="3723" href="SMT.Theory.Raw.Reflection.html#3723" class="Bound">l</a><a id="3724" class="Symbol">)</a>    <a id="3729" class="Symbol">=</a> <a id="3731" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="3738" class="Symbol">(</a><a id="3739" href="SMT.Theory.Raw.Base.html#2824" class="InductiveConstructor">litᵣ</a> <a id="3744" href="SMT.Theory.Raw.Reflection.html#3723" class="Bound">l</a><a id="3745" class="Symbol">)</a>
  <a id="3749" href="SMT.Theory.Raw.Reflection.html#3380" class="Function">reflectToRawTerm</a> <a id="3766" href="SMT.Theory.Raw.Reflection.html#3766" class="Bound">Γ</a> <a id="3768" href="SMT.Theory.Raw.Reflection.html#3768" class="Bound">fv</a> <a id="3771" class="Symbol">(</a><a id="3772" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="3776" href="SMT.Theory.Raw.Reflection.html#3776" class="Bound">f</a> <a id="3778" href="SMT.Theory.Raw.Reflection.html#3778" class="Bound">ts</a><a id="3780" class="Symbol">)</a> <a id="3782" class="Symbol">=</a> <a id="3784" href="SMT.Theory.Raw.Base.html#2859" class="InductiveConstructor">appᵣ</a> <a id="3789" class="Symbol">{</a><a id="3790" class="Argument">Σ</a> <a id="3792" class="Symbol">=</a> <a id="3794" href="SMT.Theory.Raw.Reflection.html#1277" class="Function">argTypes</a> <a id="3803" href="SMT.Theory.Raw.Reflection.html#3778" class="Bound">ts</a><a id="3805" class="Symbol">}</a> <a id="3807" href="SMT.Theory.Raw.Reflection.html#3776" class="Bound">f</a> <a id="3809" href="Category.Functor.html#608" class="Function Operator">&lt;$&gt;</a> <a id="3813" href="SMT.Theory.Raw.Reflection.html#4259" class="Function">reflectToRawArgs</a> <a id="3830" href="SMT.Theory.Raw.Reflection.html#3766" class="Bound">Γ</a> <a id="3832" href="SMT.Theory.Raw.Reflection.html#3768" class="Bound">fv</a> <a id="3835" href="SMT.Theory.Raw.Reflection.html#3778" class="Bound">ts</a>
  <a id="3840" href="SMT.Theory.Raw.Reflection.html#3380" class="Function">reflectToRawTerm</a> <a id="3857" href="SMT.Theory.Raw.Reflection.html#3857" class="Bound">Γ</a> <a id="3859" href="SMT.Theory.Raw.Reflection.html#3859" class="Bound">fv</a> <a id="3862" class="Symbol">(</a><a id="3863" href="Agda.Builtin.Reflection.html#4404" class="InductiveConstructor">con</a> <a id="3867" href="SMT.Theory.Raw.Reflection.html#3867" class="Bound">c</a> <a id="3869" href="SMT.Theory.Raw.Reflection.html#3869" class="Bound">ts</a><a id="3871" class="Symbol">)</a> <a id="3873" class="Symbol">=</a> <a id="3875" href="SMT.Theory.Raw.Base.html#2859" class="InductiveConstructor">appᵣ</a> <a id="3880" class="Symbol">{</a><a id="3881" class="Argument">Σ</a> <a id="3883" class="Symbol">=</a> <a id="3885" href="SMT.Theory.Raw.Reflection.html#1277" class="Function">argTypes</a> <a id="3894" href="SMT.Theory.Raw.Reflection.html#3869" class="Bound">ts</a><a id="3896" class="Symbol">}</a> <a id="3898" href="SMT.Theory.Raw.Reflection.html#3867" class="Bound">c</a> <a id="3900" href="Category.Functor.html#608" class="Function Operator">&lt;$&gt;</a> <a id="3904" href="SMT.Theory.Raw.Reflection.html#4259" class="Function">reflectToRawArgs</a> <a id="3921" href="SMT.Theory.Raw.Reflection.html#3857" class="Bound">Γ</a> <a id="3923" href="SMT.Theory.Raw.Reflection.html#3859" class="Bound">fv</a> <a id="3926" href="SMT.Theory.Raw.Reflection.html#3869" class="Bound">ts</a>
  <a id="3931" href="SMT.Theory.Raw.Reflection.html#3380" class="Function">reflectToRawTerm</a> <a id="3948" href="SMT.Theory.Raw.Reflection.html#3948" class="Bound">Γ</a> <a id="3950" href="SMT.Theory.Raw.Reflection.html#3950" class="Bound">fv</a> <a id="3953" class="Symbol">(</a><a id="3954" href="Agda.Builtin.Reflection.html#4636" class="InductiveConstructor">pi</a> <a id="3957" class="Symbol">(</a><a id="3958" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="3962" class="Symbol">_</a> <a id="3964" href="SMT.Theory.Raw.Reflection.html#3964" class="Bound">a</a><a id="3965" class="Symbol">)</a> <a id="3967" class="Symbol">(</a><a id="3968" href="Agda.Builtin.Reflection.html#3538" class="InductiveConstructor">abs</a> <a id="3972" class="Symbol">_</a> <a id="3974" href="SMT.Theory.Raw.Reflection.html#3974" class="Bound">b</a><a id="3975" class="Symbol">))</a> <a id="3978" class="Symbol">=</a> <a id="3980" class="Keyword">do</a>
    <a id="3987" href="SMT.Theory.Raw.Reflection.html#3987" class="Bound">a</a> <a id="3989" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3991" href="SMT.Theory.Raw.Reflection.html#3380" class="Function">reflectToRawTerm</a> <a id="4008" href="SMT.Theory.Raw.Reflection.html#3948" class="Bound">Γ</a> <a id="4010" href="SMT.Theory.Raw.Reflection.html#3950" class="Bound">fv</a> <a id="4013" href="SMT.Theory.Raw.Reflection.html#3964" class="Bound">a</a>
    <a id="4019" href="SMT.Theory.Raw.Reflection.html#4019" class="Bound">b</a> <a id="4021" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="4023" href="SMT.Theory.Raw.Reflection.html#3380" class="Function">reflectToRawTerm</a> <a id="4040" href="SMT.Theory.Raw.Reflection.html#3948" class="Bound">Γ</a> <a id="4042" class="Symbol">(</a><a id="4043" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="4047" href="SMT.Theory.Raw.Reflection.html#3950" class="Bound">fv</a><a id="4049" class="Symbol">)</a> <a id="4051" href="SMT.Theory.Raw.Reflection.html#3974" class="Bound">b</a>
    <a id="4057" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="4064" class="Symbol">(</a><a id="4065" href="SMT.Theory.Raw.Base.html#2859" class="InductiveConstructor">appᵣ</a> <a id="4070" class="Symbol">{</a><a id="4071" class="Argument">Σ</a> <a id="4073" class="Symbol">=</a> <a id="4075" class="Keyword">record</a> <a id="4082" class="Symbol">{</a><a id="4083" href="SMT.Theory.Base.html#547" class="Field">ArgSorts</a> <a id="4092" class="Symbol">=</a> <a id="4094" href="SMT.Theory.Raw.Base.html#1032" class="InductiveConstructor">⋆</a> <a id="4096" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4098" href="SMT.Theory.Raw.Base.html#1032" class="InductiveConstructor">⋆</a> <a id="4100" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4102" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4104" class="Symbol">}}</a> <a id="4107" class="Symbol">(</a><a id="4108" class="Keyword">quote</a> <a id="4114" href="Function.Core.html#646" class="Function">Morphism</a><a id="4122" class="Symbol">)</a> <a id="4124" class="Symbol">(</a><a id="4125" href="SMT.Theory.Raw.Reflection.html#3987" class="Bound">a</a> <a id="4127" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="4129" href="SMT.Theory.Raw.Reflection.html#4019" class="Bound">b</a> <a id="4131" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="4133" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="4135" class="Symbol">))</a>
  <a id="4140" href="SMT.Theory.Raw.Reflection.html#3380" class="Function">reflectToRawTerm</a> <a id="4157" href="SMT.Theory.Raw.Reflection.html#4157" class="Bound">Γ</a> <a id="4159" href="SMT.Theory.Raw.Reflection.html#4159" class="Bound">fv</a> <a id="4162" class="Symbol">(</a><a id="4163" href="Agda.Builtin.Reflection.html#4754" class="InductiveConstructor">meta</a> <a id="4168" href="SMT.Theory.Raw.Reflection.html#4168" class="Bound">x</a> <a id="4170" class="Symbol">_)</a> <a id="4173" class="Symbol">=</a> <a id="4175" href="Agda.Builtin.Reflection.html#8569" class="Postulate">blockOnMeta</a> <a id="4187" href="SMT.Theory.Raw.Reflection.html#4168" class="Bound">x</a>
  <a id="4191" href="SMT.Theory.Raw.Reflection.html#3380" class="CatchallClause Function">reflectToRawTerm</a><a id="4207" class="CatchallClause"> </a><a id="4208" href="SMT.Theory.Raw.Reflection.html#4208" class="CatchallClause Bound">Γ</a><a id="4209" class="CatchallClause"> </a><a id="4210" href="SMT.Theory.Raw.Reflection.html#4210" class="CatchallClause Bound">fv</a><a id="4212" class="CatchallClause"> </a><a id="4213" href="SMT.Theory.Raw.Reflection.html#4213" class="CatchallClause Bound">t</a> <a id="4215" class="Symbol">=</a> <a id="4217" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="4230" class="String">&quot;reflectToRawTerm failed&quot;</a>

  <a id="reflectToRawArgs"></a><a id="4259" href="SMT.Theory.Raw.Reflection.html#4259" class="Function">reflectToRawArgs</a> <a id="4276" class="Symbol">:</a> <a id="4278" class="Symbol">∀</a> <a id="4280" href="SMT.Theory.Raw.Reflection.html#4280" class="Bound">Γ</a> <a id="4282" class="Symbol">(</a><a id="4283" href="SMT.Theory.Raw.Reflection.html#4283" class="Bound">fv</a> <a id="4286" class="Symbol">:</a> <a id="4288" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="4289" class="Symbol">)</a> <a id="4291" class="Symbol">(</a><a id="4292" href="SMT.Theory.Raw.Reflection.html#4292" class="Bound">ts</a> <a id="4295" class="Symbol">:</a> <a id="4297" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="4302" class="Symbol">(</a><a id="4303" href="Agda.Builtin.Reflection.html#3255" class="Datatype">Arg</a> <a id="4307" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a><a id="4311" class="Symbol">))</a> <a id="4314" class="Symbol">→</a> <a id="4316" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="4319" class="Symbol">(</a><a id="4320" href="SMT.Theory.Raw.Base.html#2970" class="Function">RawArgs</a> <a id="4328" href="SMT.Theory.Raw.Reflection.html#4280" class="Bound">Γ</a> <a id="4330" class="Symbol">(</a><a id="4331" href="SMT.Theory.Base.html#547" class="Field">ArgSorts</a> <a id="4340" class="Symbol">(</a><a id="4341" href="SMT.Theory.Raw.Reflection.html#1277" class="Function">argTypes</a> <a id="4350" href="SMT.Theory.Raw.Reflection.html#4292" class="Bound">ts</a><a id="4352" class="Symbol">)))</a>
  <a id="4358" href="SMT.Theory.Raw.Reflection.html#4259" class="Function">reflectToRawArgs</a> <a id="4375" href="SMT.Theory.Raw.Reflection.html#4375" class="Bound">Γ</a> <a id="4377" href="SMT.Theory.Raw.Reflection.html#4377" class="Bound">fv</a> <a id="4380" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="4383" class="Symbol">=</a> <a id="4385" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="4392" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a>
  <a id="4397" href="SMT.Theory.Raw.Reflection.html#4259" class="Function">reflectToRawArgs</a> <a id="4414" href="SMT.Theory.Raw.Reflection.html#4414" class="Bound">Γ</a> <a id="4416" href="SMT.Theory.Raw.Reflection.html#4416" class="Bound">fv</a> <a id="4419" class="Symbol">(</a><a id="4420" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="4425" href="SMT.Theory.Raw.Reflection.html#4425" class="Bound">t</a> <a id="4427" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4429" href="SMT.Theory.Raw.Reflection.html#4429" class="Bound">ts</a><a id="4431" class="Symbol">)</a> <a id="4433" class="Symbol">=</a> <a id="4435" class="Symbol">⦇</a> <a id="4437" href="SMT.Theory.Raw.Reflection.html#3380" class="Function">reflectToRawTerm</a> <a id="4454" href="SMT.Theory.Raw.Reflection.html#4414" class="Bound">Γ</a> <a id="4456" href="SMT.Theory.Raw.Reflection.html#4416" class="Bound">fv</a> <a id="4459" href="SMT.Theory.Raw.Reflection.html#4425" class="Bound">t</a> <a id="4461" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="4463" href="SMT.Theory.Raw.Reflection.html#4259" class="Function">reflectToRawArgs</a> <a id="4480" href="SMT.Theory.Raw.Reflection.html#4414" class="Bound">Γ</a> <a id="4482" href="SMT.Theory.Raw.Reflection.html#4416" class="Bound">fv</a> <a id="4485" href="SMT.Theory.Raw.Reflection.html#4429" class="Bound">ts</a> <a id="4488" class="Symbol">⦈</a>
  <a id="4492" href="SMT.Theory.Raw.Reflection.html#4259" class="Function">reflectToRawArgs</a> <a id="4509" href="SMT.Theory.Raw.Reflection.html#4509" class="Bound">Γ</a> <a id="4511" href="SMT.Theory.Raw.Reflection.html#4511" class="Bound">fv</a> <a id="4514" class="Symbol">(</a><a id="4515" href="Reflection.Argument.html#1126" class="InductiveConstructor">hArg</a> <a id="4520" class="Symbol">_</a> <a id="4522" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4524" href="SMT.Theory.Raw.Reflection.html#4524" class="Bound">ts</a><a id="4526" class="Symbol">)</a> <a id="4528" class="Symbol">=</a> <a id="4530" href="SMT.Theory.Raw.Reflection.html#4259" class="Function">reflectToRawArgs</a> <a id="4547" href="SMT.Theory.Raw.Reflection.html#4509" class="Bound">Γ</a> <a id="4549" href="SMT.Theory.Raw.Reflection.html#4511" class="Bound">fv</a> <a id="4552" href="SMT.Theory.Raw.Reflection.html#4524" class="Bound">ts</a>
  <a id="4557" href="SMT.Theory.Raw.Reflection.html#4259" class="Function">reflectToRawArgs</a> <a id="4574" href="SMT.Theory.Raw.Reflection.html#4574" class="Bound">Γ</a> <a id="4576" href="SMT.Theory.Raw.Reflection.html#4576" class="Bound">fv</a> <a id="4579" class="Symbol">(</a><a id="4580" href="Reflection.Argument.html#1181" class="InductiveConstructor">iArg</a> <a id="4585" class="Symbol">_</a> <a id="4587" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4589" href="SMT.Theory.Raw.Reflection.html#4589" class="Bound">ts</a><a id="4591" class="Symbol">)</a> <a id="4593" class="Symbol">=</a> <a id="4595" href="SMT.Theory.Raw.Reflection.html#4259" class="Function">reflectToRawArgs</a> <a id="4612" href="SMT.Theory.Raw.Reflection.html#4574" class="Bound">Γ</a> <a id="4614" href="SMT.Theory.Raw.Reflection.html#4576" class="Bound">fv</a> <a id="4617" href="SMT.Theory.Raw.Reflection.html#4589" class="Bound">ts</a>
  <a id="4622" href="SMT.Theory.Raw.Reflection.html#4259" class="Function">reflectToRawArgs</a> <a id="4639" href="SMT.Theory.Raw.Reflection.html#4639" class="Bound">Γ</a> <a id="4641" href="SMT.Theory.Raw.Reflection.html#4641" class="Bound">fv</a> <a id="4644" class="Symbol">(</a><a id="4645" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="4649" class="Symbol">(</a><a id="4650" href="Agda.Builtin.Reflection.html#3195" class="InductiveConstructor">arg-info</a> <a id="4659" href="Agda.Builtin.Reflection.html#2763" class="InductiveConstructor">visible</a>   <a id="4669" href="Agda.Builtin.Reflection.html#3029" class="InductiveConstructor">irrelevant</a><a id="4679" class="Symbol">)</a> <a id="4681" class="Symbol">_</a> <a id="4683" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4685" href="SMT.Theory.Raw.Reflection.html#4685" class="Bound">ts</a><a id="4687" class="Symbol">)</a> <a id="4689" class="Symbol">=</a> <a id="4691" href="SMT.Theory.Raw.Reflection.html#4259" class="Function">reflectToRawArgs</a> <a id="4708" href="SMT.Theory.Raw.Reflection.html#4639" class="Bound">Γ</a> <a id="4710" href="SMT.Theory.Raw.Reflection.html#4641" class="Bound">fv</a> <a id="4713" href="SMT.Theory.Raw.Reflection.html#4685" class="Bound">ts</a>
  <a id="4718" href="SMT.Theory.Raw.Reflection.html#4259" class="Function">reflectToRawArgs</a> <a id="4735" href="SMT.Theory.Raw.Reflection.html#4735" class="Bound">Γ</a> <a id="4737" href="SMT.Theory.Raw.Reflection.html#4737" class="Bound">fv</a> <a id="4740" class="Symbol">(</a><a id="4741" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="4745" class="Symbol">(</a><a id="4746" href="Agda.Builtin.Reflection.html#3195" class="InductiveConstructor">arg-info</a> <a id="4755" href="Agda.Builtin.Reflection.html#2771" class="InductiveConstructor">hidden</a>    <a id="4765" href="Agda.Builtin.Reflection.html#3029" class="InductiveConstructor">irrelevant</a><a id="4775" class="Symbol">)</a> <a id="4777" href="SMT.Theory.Raw.Reflection.html#4777" class="Bound">t</a> <a id="4779" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4781" href="SMT.Theory.Raw.Reflection.html#4781" class="Bound">ts</a><a id="4783" class="Symbol">)</a> <a id="4785" class="Symbol">=</a> <a id="4787" href="SMT.Theory.Raw.Reflection.html#4259" class="Function">reflectToRawArgs</a> <a id="4804" href="SMT.Theory.Raw.Reflection.html#4735" class="Bound">Γ</a> <a id="4806" href="SMT.Theory.Raw.Reflection.html#4737" class="Bound">fv</a> <a id="4809" href="SMT.Theory.Raw.Reflection.html#4781" class="Bound">ts</a>
  <a id="4814" href="SMT.Theory.Raw.Reflection.html#4259" class="Function">reflectToRawArgs</a> <a id="4831" href="SMT.Theory.Raw.Reflection.html#4831" class="Bound">Γ</a> <a id="4833" href="SMT.Theory.Raw.Reflection.html#4833" class="Bound">fv</a> <a id="4836" class="Symbol">(</a><a id="4837" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="4841" class="Symbol">(</a><a id="4842" href="Agda.Builtin.Reflection.html#3195" class="InductiveConstructor">arg-info</a> <a id="4851" href="Agda.Builtin.Reflection.html#2778" class="InductiveConstructor">instance′</a> <a id="4861" href="Agda.Builtin.Reflection.html#3029" class="InductiveConstructor">irrelevant</a><a id="4871" class="Symbol">)</a> <a id="4873" href="SMT.Theory.Raw.Reflection.html#4873" class="Bound">t</a> <a id="4875" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4877" href="SMT.Theory.Raw.Reflection.html#4877" class="Bound">ts</a><a id="4879" class="Symbol">)</a> <a id="4881" class="Symbol">=</a> <a id="4883" href="SMT.Theory.Raw.Reflection.html#4259" class="Function">reflectToRawArgs</a> <a id="4900" href="SMT.Theory.Raw.Reflection.html#4831" class="Bound">Γ</a> <a id="4902" href="SMT.Theory.Raw.Reflection.html#4833" class="Bound">fv</a> <a id="4905" href="SMT.Theory.Raw.Reflection.html#4877" class="Bound">ts</a>


<a id="4910" class="Comment">-- |Decode a reflected Agda type to a raw SMT-LIB script.</a>
<a id="4968" class="Comment">--</a>
<a id="4971" class="Comment">--  Functions are decoded as a series of assertions, with the result type</a>
<a id="5045" class="Comment">--  negated. For instance, the type `(x y : ℤ) → x - y ≤ x + y → x ≡ y`</a>
<a id="5117" class="Comment">--  is decoded as:</a>
<a id="5136" class="Comment">--</a>
<a id="5139" class="Comment">--  @</a>
<a id="5145" class="Comment">--    (declare-const ⋆ x)</a>
<a id="5171" class="Comment">--    (declare-const ⋆ y)</a>
<a id="5197" class="Comment">--    (assert (≤ (- x y) (+ x y)))</a>
<a id="5232" class="Comment">--    (assert (not (= x y)))</a>
<a id="5261" class="Comment">--  @</a>
<a id="5267" class="Comment">--</a>
<a id="5270" class="Comment">--  Which corresponds to `∃[ x ] ∃[ y ] (x - y ≤ x + y × x ≢ y)`, i.e.,</a>
<a id="5342" class="Comment">--  the negation of the Agda type. If the solver can find an inhabitant</a>
<a id="5414" class="Comment">--  for this type, then we have a counter-example for the original type.</a>
<a id="5487" class="Comment">--</a>
<a id="reflectToRawScript"></a><a id="5490" href="SMT.Theory.Raw.Reflection.html#5490" class="Function">reflectToRawScript</a> <a id="5509" class="Symbol">:</a> <a id="5511" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="5516" class="Symbol">→</a> <a id="5518" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="5521" class="Symbol">(</a><a id="5522" href="Data.Product.html#1788" class="Function">∃[</a> <a id="5525" href="SMT.Theory.Raw.Reflection.html#5525" class="Bound">Γ</a> <a id="5527" href="Data.Product.html#1788" class="Function">]</a> <a id="5529" href="SMT.Theory.Raw.Base.html#3255" class="Datatype">RawScript</a> <a id="5539" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="5542" href="SMT.Theory.Raw.Reflection.html#5525" class="Bound">Γ</a> <a id="5544" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="5546" class="Symbol">)</a>
<a id="5548" href="SMT.Theory.Raw.Reflection.html#5490" class="Function">reflectToRawScript</a> <a id="5567" class="Symbol">=</a> <a id="5569" href="SMT.Theory.Raw.Reflection.html#5606" class="Function">reflectToRawScript′</a> <a id="5589" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="5592" class="Number">0</a>
  <a id="5596" class="Keyword">where</a>
    <a id="5606" href="SMT.Theory.Raw.Reflection.html#5606" class="Function">reflectToRawScript′</a> <a id="5626" class="Symbol">:</a> <a id="5628" class="Symbol">(</a><a id="5629" href="SMT.Theory.Raw.Reflection.html#5629" class="Bound">Γ</a> <a id="5631" class="Symbol">:</a> <a id="5633" href="SMT.Theory.Raw.Base.html#2678" class="Function">RawCtxt</a><a id="5640" class="Symbol">)</a> <a id="5642" class="Symbol">(</a><a id="5643" href="SMT.Theory.Raw.Reflection.html#5643" class="Bound">fv</a> <a id="5646" class="Symbol">:</a> <a id="5648" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="5649" class="Symbol">)</a> <a id="5651" class="Symbol">→</a> <a id="5653" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="5658" class="Symbol">→</a> <a id="5660" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="5663" class="Symbol">(</a><a id="5664" href="Data.Product.html#1788" class="Function">∃[</a> <a id="5667" href="SMT.Theory.Raw.Reflection.html#5667" class="Bound">Γ′</a> <a id="5670" href="Data.Product.html#1788" class="Function">]</a> <a id="5672" href="SMT.Theory.Raw.Base.html#3255" class="Datatype">RawScript</a> <a id="5682" href="SMT.Theory.Raw.Reflection.html#5629" class="Bound">Γ</a> <a id="5684" href="SMT.Theory.Raw.Reflection.html#5667" class="Bound">Γ′</a> <a id="5687" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="5689" class="Symbol">)</a>
    <a id="5695" href="SMT.Theory.Raw.Reflection.html#5606" class="Function">reflectToRawScript′</a> <a id="5715" href="SMT.Theory.Raw.Reflection.html#5715" class="Bound">Γ</a> <a id="5717" href="SMT.Theory.Raw.Reflection.html#5717" class="Bound">fv</a> <a id="5720" class="Symbol">(</a><a id="5721" href="Agda.Builtin.Reflection.html#4636" class="InductiveConstructor">pi</a> <a id="5724" class="Symbol">(</a><a id="5725" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="5729" class="Symbol">_</a> <a id="5731" href="SMT.Theory.Raw.Reflection.html#5731" class="Bound">a</a><a id="5732" class="Symbol">)</a> <a id="5734" class="Symbol">(</a><a id="5735" href="Agda.Builtin.Reflection.html#3538" class="InductiveConstructor">abs</a> <a id="5739" href="SMT.Theory.Raw.Reflection.html#5739" class="Bound">x</a> <a id="5741" href="SMT.Theory.Raw.Reflection.html#5741" class="Bound">b</a><a id="5742" class="Symbol">))</a> <a id="5745" class="Symbol">=</a>
      <a id="5753" href="Function.Base.html#4121" class="Function Operator">case</a> <a id="5758" class="Number">0</a> <a id="5760" href="SMT.Theory.Raw.Reflection.html#2137" class="Function Operator">∈-FV</a> <a id="5765" href="SMT.Theory.Raw.Reflection.html#5741" class="Bound">b</a> <a id="5767" href="Function.Base.html#4121" class="Function Operator">of</a> <a id="5770" class="Symbol">λ</a> <a id="5772" class="Keyword">where</a>
        <a id="5786" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="5791" class="Symbol">→</a> <a id="5793" class="Keyword">do</a>
          <a id="5806" href="SMT.Theory.Raw.Reflection.html#5806" class="Bound">Γ′</a> <a id="5809" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5811" href="SMT.Theory.Raw.Reflection.html#5811" class="Bound">s</a> <a id="5813" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="5815" href="SMT.Theory.Raw.Reflection.html#5606" class="Function">reflectToRawScript′</a> <a id="5835" class="Symbol">(</a><a id="5836" href="SMT.Theory.Raw.Base.html#1049" class="InductiveConstructor">TERM</a> <a id="5841" href="SMT.Theory.Raw.Reflection.html#5731" class="Bound">a</a> <a id="5843" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="5845" href="SMT.Theory.Raw.Reflection.html#5715" class="Bound">Γ</a><a id="5846" class="Symbol">)</a> <a id="5848" href="SMT.Theory.Raw.Reflection.html#5717" class="Bound">fv</a> <a id="5851" href="SMT.Theory.Raw.Reflection.html#5741" class="Bound">b</a>
          <a id="5863" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="5870" class="Symbol">(</a><a id="5871" href="SMT.Theory.Raw.Reflection.html#5806" class="Bound">Γ′</a> <a id="5874" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5876" href="SMT.Theory.Raw.Base.html#3090" class="InductiveConstructor">declare-constᵣ</a> <a id="5891" href="SMT.Theory.Raw.Reflection.html#5739" class="Bound">x</a> <a id="5893" class="Symbol">(</a><a id="5894" href="SMT.Theory.Raw.Base.html#1049" class="InductiveConstructor">TERM</a> <a id="5899" href="SMT.Theory.Raw.Reflection.html#5731" class="Bound">a</a><a id="5900" class="Symbol">)</a> <a id="5902" href="SMT.Theory.Raw.Base.html#3329" class="InductiveConstructor Operator">∷ᵣ</a> <a id="5905" href="SMT.Theory.Raw.Reflection.html#5811" class="Bound">s</a><a id="5906" class="Symbol">)</a>
        <a id="5916" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="5922" class="Symbol">→</a> <a id="5924" class="Keyword">do</a>
          <a id="5937" href="SMT.Theory.Raw.Reflection.html#5937" class="Bound">t</a> <a id="5939" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="5941" href="SMT.Theory.Raw.Reflection.html#3380" class="Function">reflectToRawTerm</a> <a id="5958" href="SMT.Theory.Raw.Reflection.html#5715" class="Bound">Γ</a> <a id="5960" href="SMT.Theory.Raw.Reflection.html#5717" class="Bound">fv</a> <a id="5963" href="SMT.Theory.Raw.Reflection.html#5731" class="Bound">a</a>
          <a id="5975" href="SMT.Theory.Raw.Reflection.html#5975" class="Bound">Γ′</a> <a id="5978" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5980" href="SMT.Theory.Raw.Reflection.html#5980" class="Bound">s</a> <a id="5982" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="5984" href="SMT.Theory.Raw.Reflection.html#5606" class="Function">reflectToRawScript′</a> <a id="6004" href="SMT.Theory.Raw.Reflection.html#5715" class="Bound">Γ</a> <a id="6006" class="Symbol">(</a><a id="6007" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="6011" href="SMT.Theory.Raw.Reflection.html#5717" class="Bound">fv</a><a id="6013" class="Symbol">)</a> <a id="6015" href="SMT.Theory.Raw.Reflection.html#5741" class="Bound">b</a>
          <a id="6027" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="6034" class="Symbol">(</a><a id="6035" href="SMT.Theory.Raw.Reflection.html#5975" class="Bound">Γ′</a> <a id="6038" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6040" href="SMT.Theory.Raw.Base.html#3135" class="InductiveConstructor">assertᵣ</a> <a id="6048" href="SMT.Theory.Raw.Reflection.html#5937" class="Bound">t</a> <a id="6050" href="SMT.Theory.Raw.Base.html#3329" class="InductiveConstructor Operator">∷ᵣ</a> <a id="6053" href="SMT.Theory.Raw.Reflection.html#5980" class="Bound">s</a><a id="6054" class="Symbol">)</a>
    <a id="6060" href="SMT.Theory.Raw.Reflection.html#5606" class="CatchallClause Function">reflectToRawScript′</a><a id="6079" class="CatchallClause"> </a><a id="6080" href="SMT.Theory.Raw.Reflection.html#6080" class="CatchallClause Bound">Γ</a><a id="6081" class="CatchallClause"> </a><a id="6082" href="SMT.Theory.Raw.Reflection.html#6082" class="CatchallClause Bound">fv</a><a id="6084" class="CatchallClause"> </a><a id="6085" href="SMT.Theory.Raw.Reflection.html#6085" class="CatchallClause Bound">t</a> <a id="6087" class="Symbol">=</a> <a id="6089" class="Keyword">do</a>
      <a id="6098" href="SMT.Theory.Raw.Reflection.html#6098" class="Bound">t</a> <a id="6100" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="6102" href="SMT.Theory.Raw.Reflection.html#3380" class="Function">reflectToRawTerm</a> <a id="6119" href="SMT.Theory.Raw.Reflection.html#6080" class="Bound">Γ</a> <a id="6121" href="SMT.Theory.Raw.Reflection.html#6082" class="Bound">fv</a> <a id="6124" href="SMT.Theory.Raw.Reflection.html#6085" class="Bound">t</a>
      <a id="6132" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="6139" class="Symbol">(</a><a id="6140" href="SMT.Theory.Raw.Reflection.html#6080" class="Bound">Γ</a> <a id="6142" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6144" href="SMT.Theory.Raw.Base.html#3135" class="InductiveConstructor">assertᵣ</a> <a id="6152" class="Symbol">(</a><a id="6153" href="SMT.Theory.Raw.Base.html#2859" class="InductiveConstructor">appᵣ</a> <a id="6158" class="Symbol">(</a><a id="6159" class="Keyword">quote</a> <a id="6165" href="Relation.Nullary.html#653" class="Function Operator">¬_</a><a id="6167" class="Symbol">)</a> <a id="6169" class="Symbol">(</a><a id="6170" href="SMT.Theory.Raw.Reflection.html#6098" class="Bound">t</a> <a id="6172" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="6174" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="6176" class="Symbol">))</a> <a id="6179" href="SMT.Theory.Raw.Base.html#3329" class="InductiveConstructor Operator">∷ᵣ</a> <a id="6182" href="SMT.Theory.Raw.Base.html#3295" class="InductiveConstructor">[]ᵣ</a><a id="6185" class="Symbol">)</a>
</pre></body></html>