<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SMT.Theories.Raw.Reflection</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">module</a> <a id="8" href="SMT.Theories.Raw.Reflection.html" class="Module">SMT.Theories.Raw.Reflection</a> <a id="36" class="Keyword">where</a>

<a id="43" class="Keyword">open</a> <a id="48" class="Keyword">import</a> <a id="55" href="Category.Monad.html" class="Module">Category.Monad</a>
<a id="70" class="Keyword">open</a> <a id="75" class="Keyword">import</a> <a id="82" href="Data.Bool.html" class="Module">Data.Bool</a> <a id="92" class="Symbol">as</a> <a id="95" class="Module">Bool</a> <a id="100" class="Keyword">using</a> <a id="106" class="Symbol">(</a><a id="107" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="111" class="Symbol">;</a> <a id="113" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="117" class="Symbol">;</a> <a id="119" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="124" class="Symbol">;</a> <a id="126" href="Data.Bool.Base.html#1044" class="Function Operator">_∨_</a><a id="129" class="Symbol">)</a>
<a id="131" class="Keyword">open</a> <a id="136" class="Keyword">import</a> <a id="143" href="Data.Fin.html" class="Module">Data.Fin</a> <a id="152" class="Symbol">as</a> <a id="155" class="Module">Fin</a> <a id="159" class="Keyword">using</a> <a id="165" class="Symbol">(</a><a id="166" href="Data.Fin.Base.html#1138" class="Datatype">Fin</a><a id="169" class="Symbol">;</a> <a id="171" href="Data.Fin.Base.html#1191" class="InductiveConstructor">suc</a><a id="174" class="Symbol">;</a> <a id="176" href="Data.Fin.Base.html#1160" class="InductiveConstructor">zero</a><a id="180" class="Symbol">)</a>
<a id="182" class="Keyword">open</a> <a id="187" class="Keyword">import</a> <a id="194" href="Data.Integer.html" class="Module">Data.Integer</a> <a id="207" class="Symbol">as</a> <a id="210" class="Module">Int</a> <a id="214" class="Keyword">using</a> <a id="220" class="Symbol">(</a><a id="221" href="Agda.Builtin.Int.html#246" class="Datatype">ℤ</a><a id="222" class="Symbol">;</a> <a id="224" href="Agda.Builtin.Int.html#264" class="InductiveConstructor">+_</a><a id="226" class="Symbol">;</a> <a id="228" href="Agda.Builtin.Int.html#291" class="InductiveConstructor">-[1+_]</a><a id="234" class="Symbol">)</a>
<a id="236" class="Keyword">open</a> <a id="241" class="Keyword">import</a> <a id="248" href="Data.List.html" class="Module">Data.List</a> <a id="258" class="Symbol">as</a> <a id="261" class="Module">List</a> <a id="266" class="Keyword">using</a> <a id="272" class="Symbol">(</a><a id="273" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="277" class="Symbol">;</a> <a id="279" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="282" class="Symbol">;</a> <a id="284" href="Data.List.Base.html#9981" class="InductiveConstructor">[]</a><a id="286" class="Symbol">;</a> <a id="288" href="Data.List.Base.html#4577" class="Function">length</a><a id="294" class="Symbol">)</a>
<a id="296" class="Keyword">open</a> <a id="301" class="Keyword">import</a> <a id="308" href="Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="337" class="Keyword">using</a> <a id="343" class="Symbol">(</a><a id="344" href="Data.List.Relation.Unary.All.html#1397" class="Datatype">All</a><a id="347" class="Symbol">;</a> <a id="349" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">_∷_</a><a id="352" class="Symbol">;</a> <a id="354" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="356" class="Symbol">)</a>
<a id="358" class="Keyword">open</a> <a id="363" class="Keyword">import</a> <a id="370" href="Data.List.NonEmpty.html" class="Module">Data.List.NonEmpty</a> <a id="389" class="Symbol">as</a> <a id="392" class="Module">List⁺</a> <a id="398" class="Keyword">using</a> <a id="404" class="Symbol">(</a><a id="405" href="Data.List.NonEmpty.html#1318" class="Record">List⁺</a><a id="410" class="Symbol">;</a> <a id="412" href="Data.List.NonEmpty.html#1364" class="InductiveConstructor Operator">_∷_</a><a id="415" class="Symbol">)</a>
<a id="417" class="Keyword">open</a> <a id="422" class="Keyword">import</a> <a id="429" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="438" class="Symbol">as</a> <a id="441" class="Module">Nat</a> <a id="445" class="Keyword">using</a> <a id="451" class="Symbol">(</a><a id="452" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="453" class="Symbol">;</a> <a id="455" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="459" class="Symbol">;</a> <a id="461" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="464" class="Symbol">;</a> <a id="466" href="Data.Nat.Base.html#2735" class="Primitive Operator">_∸_</a><a id="469" class="Symbol">)</a>
<a id="471" class="Keyword">open</a> <a id="476" class="Keyword">import</a> <a id="483" href="Data.Product.html" class="Module">Data.Product</a> <a id="496" class="Symbol">as</a> <a id="499" class="Module">Prod</a> <a id="504" class="Keyword">using</a> <a id="510" class="Symbol">(</a><a id="511" href="Data.Product.html#1788" class="Function">∃-syntax</a><a id="519" class="Symbol">;</a> <a id="521" href="Data.Product.html#1167" class="Function Operator">_×_</a><a id="524" class="Symbol">;</a> <a id="526" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="529" class="Symbol">;</a> <a id="531" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="536" class="Symbol">;</a> <a id="538" href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="543" class="Symbol">)</a>
<a id="545" class="Keyword">open</a> <a id="550" class="Keyword">import</a> <a id="557" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="567" class="Symbol">as</a> <a id="570" class="Module">Unit</a> <a id="575" class="Keyword">using</a> <a id="581" class="Symbol">(</a><a id="582" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="583" class="Symbol">)</a>
<a id="585" class="Keyword">open</a> <a id="590" class="Keyword">import</a> <a id="597" href="Function.html" class="Module">Function</a>
<a id="606" class="Keyword">open</a> <a id="611" class="Keyword">import</a> <a id="618" href="Level.html" class="Module">Level</a> <a id="624" class="Keyword">using</a> <a id="630" class="Symbol">(</a><a id="631" href="Agda.Primitive.html#597" class="Postulate">Level</a><a id="636" class="Symbol">)</a>
<a id="638" class="Keyword">open</a> <a id="643" class="Keyword">import</a> <a id="650" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="688" class="Symbol">as</a> <a id="691" class="Module">PropEq</a> <a id="698" class="Keyword">using</a> <a id="704" class="Symbol">(</a><a id="705" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="708" class="Symbol">;</a> <a id="710" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="714" class="Symbol">)</a>
<a id="716" class="Keyword">open</a> <a id="721" class="Keyword">import</a> <a id="728" href="Reflection.html" class="Module">Reflection</a> <a id="739" class="Symbol">as</a> <a id="742" class="Module">Rfl</a> <a id="746" class="Keyword">hiding</a> <a id="753" class="Symbol">(</a><a id="754" href="Agda.Builtin.Reflection.html#7543" class="Postulate">return</a><a id="760" class="Symbol">;</a> <a id="762" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">_&gt;&gt;=_</a><a id="767" class="Symbol">)</a>
<a id="769" class="Keyword">import</a> <a id="776" href="Reflection.TypeChecking.Monad.Categorical.html" class="Module">Reflection.TypeChecking.Monad.Categorical</a> <a id="818" class="Symbol">as</a> <a id="821" class="Module">TC</a>
<a id="824" class="Keyword">open</a> <a id="829" class="Keyword">import</a> <a id="836" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="853" class="Keyword">using</a> <a id="859" class="Symbol">(</a><a id="860" href="Relation.Nullary.html#653" class="Function Operator">¬_</a><a id="862" class="Symbol">;</a> <a id="864" href="Relation.Nullary.html#1508" class="Record">Dec</a><a id="867" class="Symbol">;</a> <a id="869" href="Relation.Nullary.html#1645" class="InductiveConstructor">yes</a><a id="872" class="Symbol">;</a> <a id="874" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a><a id="876" class="Symbol">)</a>
<a id="878" class="Keyword">open</a> <a id="883" class="Keyword">import</a> <a id="890" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a> <a id="917" class="Keyword">using</a> <a id="923" class="Symbol">(</a><a id="924" href="Relation.Nullary.Decidable.Core.html#1027" class="Function">isYes</a><a id="929" class="Symbol">)</a>
<a id="931" class="Keyword">open</a> <a id="936" class="Keyword">import</a> <a id="943" href="SMT.Theory.html" class="Module">SMT.Theory</a>
<a id="954" class="Keyword">open</a> <a id="959" class="Keyword">import</a> <a id="966" href="SMT.Theories.Raw.Base.html" class="Module">SMT.Theories.Raw.Base</a>

<a id="989" class="Keyword">private</a>
  <a id="999" class="Keyword">open</a> <a id="1004" class="Keyword">module</a> <a id="TCMonad"></a><a id="1011" href="SMT.Theories.Raw.Reflection.html#1011" class="Module">TCMonad</a> <a id="1019" class="Symbol">{</a><a id="1020" href="SMT.Theories.Raw.Reflection.html#1020" class="Bound">ℓ</a><a id="1021" class="Symbol">}</a> <a id="1023" class="Symbol">=</a> <a id="1025" href="Category.Monad.html#832" class="Module">Category.Monad.RawMonad</a> <a id="1049" class="Symbol">{</a><a id="1050" href="SMT.Theories.Raw.Reflection.html#1020" class="Bound">ℓ</a><a id="1051" class="Symbol">}</a> <a id="1053" href="Reflection.TypeChecking.Monad.Categorical.html#1061" class="Function">TC.monad</a> <a id="1062" class="Keyword">renaming</a> <a id="1071" class="Symbol">(</a><a id="1072" href="Category.Applicative.Indexed.html#1034" class="Function Operator">_⊛_</a> <a id="1076" class="Symbol">to</a> <a id="TCMonad._⊛_"></a><a id="1079" href="SMT.Theories.Raw.Reflection.html#1079" class="Function Operator">_&lt;*&gt;_</a><a id="1084" class="Symbol">)</a>

<a id="1087" class="Keyword">private</a>
  <a id="1097" class="Keyword">variable</a>
    <a id="1110" href="SMT.Theories.Raw.Reflection.html#1110" class="Generalizable">ℓ</a> <a id="1112" class="Symbol">:</a> <a id="1114" href="Agda.Primitive.html#597" class="Postulate">Level</a>
    <a id="1124" href="SMT.Theories.Raw.Reflection.html#1124" class="Generalizable">A</a> <a id="1126" class="Symbol">:</a> <a id="1128" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="1132" href="SMT.Theories.Raw.Reflection.html#1110" class="Generalizable">ℓ</a>


<a id="1136" class="Keyword">private</a>
  <a id="1146" class="Comment">-- We don&#39;t know the type of raw function symbols, so just look at</a>
  <a id="1215" class="Comment">-- the arguments. Design decision: only keep visible arguments.</a>
  <a id="argTypes"></a><a id="1281" href="SMT.Theories.Raw.Reflection.html#1281" class="Function">argTypes</a> <a id="1290" class="Symbol">:</a> <a id="1292" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="1297" class="Symbol">(</a><a id="1298" href="Agda.Builtin.Reflection.html#3255" class="Datatype">Arg</a> <a id="1302" href="SMT.Theories.Raw.Reflection.html#1124" class="Generalizable">A</a><a id="1303" class="Symbol">)</a> <a id="1305" class="Symbol">→</a> <a id="1307" href="SMT.Theory.html#484" class="Record">Signature</a> <a id="1317" href="SMT.Theories.Raw.Base.html#1029" class="InductiveConstructor">⋆</a>
  <a id="1321" href="SMT.Theories.Raw.Reflection.html#1281" class="Function">argTypes</a> <a id="1330" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>              <a id="1346" class="Symbol">.</a><a id="1347" href="SMT.Theory.html#542" class="Field">ArgSorts</a> <a id="1356" class="Symbol">=</a> <a id="1358" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
  <a id="1363" href="SMT.Theories.Raw.Reflection.html#1281" class="Function">argTypes</a> <a id="1372" class="Symbol">(</a><a id="1373" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="1378" class="Symbol">_</a> <a id="1380" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1382" href="SMT.Theories.Raw.Reflection.html#1382" class="Bound">args</a><a id="1386" class="Symbol">)</a> <a id="1388" class="Symbol">.</a><a id="1389" href="SMT.Theory.html#542" class="Field">ArgSorts</a> <a id="1398" class="Symbol">=</a> <a id="1400" href="SMT.Theories.Raw.Base.html#1029" class="InductiveConstructor">⋆</a> <a id="1402" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1404" href="SMT.Theories.Raw.Reflection.html#1281" class="Function">argTypes</a> <a id="1413" href="SMT.Theories.Raw.Reflection.html#1382" class="Bound">args</a> <a id="1418" class="Symbol">.</a><a id="1419" href="SMT.Theory.html#542" class="Field">ArgSorts</a>
  <a id="1430" href="SMT.Theories.Raw.Reflection.html#1281" class="CatchallClause Function">argTypes</a><a id="1438" class="CatchallClause"> </a><a id="1439" class="CatchallClause Symbol">(_</a><a id="1441" class="CatchallClause">      </a><a id="1447" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="1448" class="CatchallClause"> </a><a id="1449" href="SMT.Theories.Raw.Reflection.html#1449" class="CatchallClause Bound">args</a><a id="1453" class="CatchallClause Symbol">)</a><a id="1454" class="CatchallClause"> </a><a id="1455" class="CatchallClause Symbol">.</a><a id="1456" href="SMT.Theory.html#542" class="CatchallClause Field">ArgSorts</a> <a id="1465" class="Symbol">=</a>     <a id="1471" href="SMT.Theories.Raw.Reflection.html#1281" class="Function">argTypes</a> <a id="1480" href="SMT.Theories.Raw.Reflection.html#1449" class="Bound">args</a> <a id="1485" class="Symbol">.</a><a id="1486" href="SMT.Theory.html#542" class="Field">ArgSorts</a>


<a id="reflectToRawVar"></a><a id="1497" href="SMT.Theories.Raw.Reflection.html#1497" class="Function">reflectToRawVar</a> <a id="1513" class="Symbol">:</a> <a id="1515" class="Symbol">(</a><a id="1516" href="SMT.Theories.Raw.Reflection.html#1516" class="Bound">Γ</a> <a id="1518" class="Symbol">:</a> <a id="1520" href="SMT.Theories.Raw.Base.html#2675" class="Function">RawCtxt</a><a id="1527" class="Symbol">)</a> <a id="1529" class="Symbol">(</a><a id="1530" href="SMT.Theories.Raw.Reflection.html#1530" class="Bound">n</a> <a id="1532" class="Symbol">:</a> <a id="1534" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="1535" class="Symbol">)</a> <a id="1537" class="Symbol">→</a> <a id="1539" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="1542" class="Symbol">(</a><a id="1543" href="Data.Product.html#1788" class="Function">∃[</a> <a id="1546" href="SMT.Theories.Raw.Reflection.html#1546" class="Bound">σ</a> <a id="1548" href="Data.Product.html#1788" class="Function">]</a> <a id="1550" class="Symbol">(</a><a id="1551" href="SMT.Theories.Raw.Reflection.html#1516" class="Bound">Γ</a> <a id="1553" href="SMT.Theories.Raw.Base.html#2713" class="Function Operator">∋ᵣ</a> <a id="1556" href="SMT.Theories.Raw.Reflection.html#1546" class="Bound">σ</a><a id="1557" class="Symbol">))</a>
<a id="1560" href="SMT.Theories.Raw.Reflection.html#1497" class="Function">reflectToRawVar</a> <a id="1576" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>      <a id="1584" href="SMT.Theories.Raw.Reflection.html#1584" class="Bound">n</a>       <a id="1592" class="Symbol">=</a> <a id="1594" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="1607" class="String">&quot;Variable out of bounds&quot;</a>
<a id="1632" href="SMT.Theories.Raw.Reflection.html#1497" class="Function">reflectToRawVar</a> <a id="1648" class="Symbol">(</a><a id="1649" href="SMT.Theories.Raw.Reflection.html#1649" class="Bound">x</a> <a id="1651" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1653" href="SMT.Theories.Raw.Reflection.html#1653" class="Bound">Γ</a><a id="1654" class="Symbol">)</a> <a id="1656" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="1664" class="Symbol">=</a> <a id="1666" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="1673" class="Symbol">(_</a> <a id="1676" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1678" href="Data.Fin.Base.html#1160" class="InductiveConstructor">zero</a> <a id="1683" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1685" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="1689" class="Symbol">)</a>
<a id="1691" href="SMT.Theories.Raw.Reflection.html#1497" class="Function">reflectToRawVar</a> <a id="1707" class="Symbol">(</a><a id="1708" href="SMT.Theories.Raw.Reflection.html#1708" class="Bound">x</a> <a id="1710" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1712" href="SMT.Theories.Raw.Reflection.html#1712" class="Bound">Γ</a><a id="1713" class="Symbol">)</a> <a id="1715" class="Symbol">(</a><a id="1716" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1720" href="SMT.Theories.Raw.Reflection.html#1720" class="Bound">n</a><a id="1721" class="Symbol">)</a> <a id="1723" class="Symbol">=</a> <a id="1725" class="Keyword">do</a>
  <a id="1730" href="SMT.Theories.Raw.Reflection.html#1730" class="Bound">σ</a> <a id="1732" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1734" href="SMT.Theories.Raw.Reflection.html#1734" class="Bound">i</a> <a id="1736" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1738" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="1743" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="1745" href="SMT.Theories.Raw.Reflection.html#1497" class="Function">reflectToRawVar</a> <a id="1761" href="SMT.Theories.Raw.Reflection.html#1712" class="Bound">Γ</a> <a id="1763" href="SMT.Theories.Raw.Reflection.html#1720" class="Bound">n</a>
  <a id="1767" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="1774" class="Symbol">(</a><a id="1775" href="SMT.Theories.Raw.Reflection.html#1730" class="Bound">σ</a> <a id="1777" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1779" href="Data.Fin.Base.html#1191" class="InductiveConstructor">suc</a> <a id="1783" href="SMT.Theories.Raw.Reflection.html#1734" class="Bound">i</a> <a id="1785" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1787" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="1791" class="Symbol">)</a>


<a id="strengthenVar"></a><a id="1795" href="SMT.Theories.Raw.Reflection.html#1795" class="Function">strengthenVar</a> <a id="1809" class="Symbol">:</a> <a id="1811" class="Symbol">(</a><a id="1812" href="SMT.Theories.Raw.Reflection.html#1812" class="Bound">fv</a> <a id="1815" href="SMT.Theories.Raw.Reflection.html#1815" class="Bound">n</a> <a id="1817" class="Symbol">:</a> <a id="1819" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="1820" class="Symbol">)</a> <a id="1822" class="Symbol">→</a> <a id="1824" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="1827" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="1829" href="SMT.Theories.Raw.Reflection.html#1795" class="Function">strengthenVar</a> <a id="1843" href="SMT.Theories.Raw.Reflection.html#1843" class="Bound">fv</a> <a id="1846" href="SMT.Theories.Raw.Reflection.html#1846" class="Bound">n</a> <a id="1848" class="Symbol">=</a>
  <a id="1852" href="Function.Base.html#4121" class="Function Operator">case</a> <a id="1857" href="SMT.Theories.Raw.Reflection.html#1846" class="Bound">n</a> <a id="1859" href="Data.Nat.Properties.html#8944" class="Function Operator">Nat.&lt;?</a> <a id="1866" href="SMT.Theories.Raw.Reflection.html#1843" class="Bound">fv</a> <a id="1869" href="Function.Base.html#4121" class="Function Operator">of</a> <a id="1872" class="Symbol">λ</a> <a id="1874" class="Keyword">where</a>
    <a id="1884" class="Symbol">(</a><a id="1885" href="Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="1889" class="Symbol">_)</a> <a id="1892" class="Symbol">→</a> <a id="1894" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="1907" class="String">&quot;Dependent quantification in term&quot;</a>
    <a id="1946" class="Symbol">(</a><a id="1947" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="1950" class="Symbol">_)</a>  <a id="1954" class="Symbol">→</a> <a id="1956" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="1963" class="Symbol">(</a><a id="1964" href="SMT.Theories.Raw.Reflection.html#1846" class="Bound">n</a> <a id="1966" href="Data.Nat.Base.html#2735" class="Primitive Operator">∸</a> <a id="1968" href="SMT.Theories.Raw.Reflection.html#1843" class="Bound">fv</a><a id="1970" class="Symbol">)</a>


<a id="1974" class="Keyword">private</a>
  <a id="_∈-FVArgs_"></a><a id="1984" href="SMT.Theories.Raw.Reflection.html#1984" class="Function Operator">_∈-FVArgs_</a>    <a id="1998" class="Symbol">:</a> <a id="2000" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2002" class="Symbol">→</a> <a id="2004" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="2009" class="Symbol">(</a><a id="2010" href="Agda.Builtin.Reflection.html#3255" class="Datatype">Arg</a> <a id="2014" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a><a id="2018" class="Symbol">)</a> <a id="2020" class="Symbol">→</a> <a id="2022" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="_∈-FVClauses_"></a><a id="2029" href="SMT.Theories.Raw.Reflection.html#2029" class="Function Operator">_∈-FVClauses_</a> <a id="2043" class="Symbol">:</a> <a id="2045" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2047" class="Symbol">→</a> <a id="2049" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="2054" href="Agda.Builtin.Reflection.html#4303" class="Datatype">Clause</a> <a id="2061" class="Symbol">→</a> <a id="2063" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="_∈-FVClause_"></a><a id="2070" href="SMT.Theories.Raw.Reflection.html#2070" class="Function Operator">_∈-FVClause_</a>  <a id="2084" class="Symbol">:</a> <a id="2086" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2088" class="Symbol">→</a> <a id="2090" href="Agda.Builtin.Reflection.html#4303" class="Datatype">Clause</a> <a id="2097" class="Symbol">→</a> <a id="2099" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="_∈-FVSort_"></a><a id="2106" href="SMT.Theories.Raw.Reflection.html#2106" class="Function Operator">_∈-FVSort_</a>    <a id="2120" class="Symbol">:</a> <a id="2122" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2124" class="Symbol">→</a> <a id="2126" href="Agda.Builtin.Reflection.html#4265" class="Datatype">Sort</a> <a id="2131" class="Symbol">→</a> <a id="2133" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>

  <a id="_∈-FV_"></a><a id="2141" href="SMT.Theories.Raw.Reflection.html#2141" class="Function Operator">_∈-FV_</a> <a id="2148" class="Symbol">:</a> <a id="2150" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2152" class="Symbol">→</a> <a id="2154" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="2159" class="Symbol">→</a> <a id="2161" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="2168" href="SMT.Theories.Raw.Reflection.html#2168" class="Bound">x</a> <a id="2170" href="SMT.Theories.Raw.Reflection.html#2141" class="Function Operator">∈-FV</a> <a id="2175" href="Agda.Builtin.Reflection.html#4348" class="InductiveConstructor">var</a> <a id="2179" href="SMT.Theories.Raw.Reflection.html#2179" class="Bound">y</a> <a id="2181" href="SMT.Theories.Raw.Reflection.html#2181" class="Bound">args</a>             <a id="2198" class="Symbol">=</a> <a id="2200" href="Relation.Nullary.Decidable.Core.html#1027" class="Function">isYes</a> <a id="2206" class="Symbol">(</a><a id="2207" href="SMT.Theories.Raw.Reflection.html#2168" class="Bound">x</a> <a id="2209" href="Data.Nat.Properties.html#2284" class="Function Operator">Nat.≟</a> <a id="2215" href="SMT.Theories.Raw.Reflection.html#2179" class="Bound">y</a><a id="2216" class="Symbol">)</a> <a id="2218" href="Data.Bool.Base.html#1044" class="Function Operator">∨</a> <a id="2220" href="SMT.Theories.Raw.Reflection.html#2168" class="Bound">x</a> <a id="2222" href="SMT.Theories.Raw.Reflection.html#1984" class="Function Operator">∈-FVArgs</a> <a id="2231" href="SMT.Theories.Raw.Reflection.html#2181" class="Bound">args</a>
  <a id="2238" href="SMT.Theories.Raw.Reflection.html#2238" class="Bound">x</a> <a id="2240" href="SMT.Theories.Raw.Reflection.html#2141" class="Function Operator">∈-FV</a> <a id="2245" href="Agda.Builtin.Reflection.html#4404" class="InductiveConstructor">con</a> <a id="2249" class="Symbol">_</a> <a id="2251" href="SMT.Theories.Raw.Reflection.html#2251" class="Bound">args</a>             <a id="2268" class="Symbol">=</a> <a id="2270" href="SMT.Theories.Raw.Reflection.html#2238" class="Bound">x</a> <a id="2272" href="SMT.Theories.Raw.Reflection.html#1984" class="Function Operator">∈-FVArgs</a> <a id="2281" href="SMT.Theories.Raw.Reflection.html#2251" class="Bound">args</a>
  <a id="2288" href="SMT.Theories.Raw.Reflection.html#2288" class="Bound">x</a> <a id="2290" href="SMT.Theories.Raw.Reflection.html#2141" class="Function Operator">∈-FV</a> <a id="2295" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="2299" class="Symbol">_</a> <a id="2301" href="SMT.Theories.Raw.Reflection.html#2301" class="Bound">args</a>             <a id="2318" class="Symbol">=</a> <a id="2320" href="SMT.Theories.Raw.Reflection.html#2288" class="Bound">x</a> <a id="2322" href="SMT.Theories.Raw.Reflection.html#1984" class="Function Operator">∈-FVArgs</a> <a id="2331" href="SMT.Theories.Raw.Reflection.html#2301" class="Bound">args</a>
  <a id="2338" href="SMT.Theories.Raw.Reflection.html#2338" class="Bound">x</a> <a id="2340" href="SMT.Theories.Raw.Reflection.html#2141" class="Function Operator">∈-FV</a> <a id="2345" href="Agda.Builtin.Reflection.html#4518" class="InductiveConstructor">lam</a> <a id="2349" class="Symbol">_</a> <a id="2351" class="Symbol">(</a><a id="2352" href="Agda.Builtin.Reflection.html#3538" class="InductiveConstructor">abs</a> <a id="2356" class="Symbol">_</a> <a id="2358" href="SMT.Theories.Raw.Reflection.html#2358" class="Bound">t</a><a id="2359" class="Symbol">)</a>        <a id="2368" class="Symbol">=</a> <a id="2370" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2374" href="SMT.Theories.Raw.Reflection.html#2338" class="Bound">x</a> <a id="2376" href="SMT.Theories.Raw.Reflection.html#2141" class="Function Operator">∈-FV</a> <a id="2381" href="SMT.Theories.Raw.Reflection.html#2358" class="Bound">t</a>
  <a id="2385" href="SMT.Theories.Raw.Reflection.html#2385" class="Bound">x</a> <a id="2387" href="SMT.Theories.Raw.Reflection.html#2141" class="Function Operator">∈-FV</a> <a id="2392" href="Agda.Builtin.Reflection.html#4571" class="InductiveConstructor">pat-lam</a> <a id="2400" href="SMT.Theories.Raw.Reflection.html#2400" class="Bound">cs</a> <a id="2403" href="SMT.Theories.Raw.Reflection.html#2403" class="Bound">args</a>        <a id="2415" class="Symbol">=</a> <a id="2417" href="SMT.Theories.Raw.Reflection.html#2385" class="Bound">x</a> <a id="2419" href="SMT.Theories.Raw.Reflection.html#2029" class="Function Operator">∈-FVClauses</a> <a id="2431" href="SMT.Theories.Raw.Reflection.html#2400" class="Bound">cs</a> <a id="2434" href="Data.Bool.Base.html#1044" class="Function Operator">∨</a> <a id="2436" href="SMT.Theories.Raw.Reflection.html#2385" class="Bound">x</a> <a id="2438" href="SMT.Theories.Raw.Reflection.html#1984" class="Function Operator">∈-FVArgs</a> <a id="2447" href="SMT.Theories.Raw.Reflection.html#2403" class="Bound">args</a>
  <a id="2454" href="SMT.Theories.Raw.Reflection.html#2454" class="Bound">x</a> <a id="2456" href="SMT.Theories.Raw.Reflection.html#2141" class="Function Operator">∈-FV</a> <a id="2461" href="Agda.Builtin.Reflection.html#4636" class="InductiveConstructor">pi</a> <a id="2464" class="Symbol">(</a><a id="2465" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="2469" class="Symbol">_</a> <a id="2471" href="SMT.Theories.Raw.Reflection.html#2471" class="Bound">a</a><a id="2472" class="Symbol">)</a> <a id="2474" class="Symbol">(</a><a id="2475" href="Agda.Builtin.Reflection.html#3538" class="InductiveConstructor">abs</a> <a id="2479" class="Symbol">_</a> <a id="2481" href="SMT.Theories.Raw.Reflection.html#2481" class="Bound">b</a><a id="2482" class="Symbol">)</a> <a id="2484" class="Symbol">=</a> <a id="2486" href="SMT.Theories.Raw.Reflection.html#2454" class="Bound">x</a> <a id="2488" href="SMT.Theories.Raw.Reflection.html#2141" class="Function Operator">∈-FV</a> <a id="2493" href="SMT.Theories.Raw.Reflection.html#2471" class="Bound">a</a> <a id="2495" href="Data.Bool.Base.html#1044" class="Function Operator">∨</a> <a id="2497" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2501" href="SMT.Theories.Raw.Reflection.html#2454" class="Bound">x</a> <a id="2503" href="SMT.Theories.Raw.Reflection.html#2141" class="Function Operator">∈-FV</a> <a id="2508" href="SMT.Theories.Raw.Reflection.html#2481" class="Bound">b</a>
  <a id="2512" href="SMT.Theories.Raw.Reflection.html#2512" class="Bound">x</a> <a id="2514" href="SMT.Theories.Raw.Reflection.html#2141" class="Function Operator">∈-FV</a> <a id="2519" href="Reflection.Term.html#1396" class="InductiveConstructor">agda-sort</a> <a id="2529" href="SMT.Theories.Raw.Reflection.html#2529" class="Bound">s</a>            <a id="2542" class="Symbol">=</a> <a id="2544" href="SMT.Theories.Raw.Reflection.html#2512" class="Bound">x</a> <a id="2546" href="SMT.Theories.Raw.Reflection.html#2106" class="Function Operator">∈-FVSort</a> <a id="2555" href="SMT.Theories.Raw.Reflection.html#2529" class="Bound">s</a>
  <a id="2559" href="SMT.Theories.Raw.Reflection.html#2559" class="Bound">x</a> <a id="2561" href="SMT.Theories.Raw.Reflection.html#2141" class="Function Operator">∈-FV</a> <a id="2566" href="Agda.Builtin.Reflection.html#4719" class="InductiveConstructor">lit</a> <a id="2570" href="SMT.Theories.Raw.Reflection.html#2570" class="Bound">l</a>                  <a id="2589" class="Symbol">=</a> <a id="2591" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="2599" href="SMT.Theories.Raw.Reflection.html#2599" class="Bound">x</a> <a id="2601" href="SMT.Theories.Raw.Reflection.html#2141" class="Function Operator">∈-FV</a> <a id="2606" href="Agda.Builtin.Reflection.html#4754" class="InductiveConstructor">meta</a> <a id="2611" class="Symbol">_</a> <a id="2613" href="SMT.Theories.Raw.Reflection.html#2613" class="Bound">args</a>            <a id="2629" class="Symbol">=</a> <a id="2631" href="SMT.Theories.Raw.Reflection.html#2599" class="Bound">x</a> <a id="2633" href="SMT.Theories.Raw.Reflection.html#1984" class="Function Operator">∈-FVArgs</a> <a id="2642" href="SMT.Theories.Raw.Reflection.html#2613" class="Bound">args</a>
  <a id="2649" href="SMT.Theories.Raw.Reflection.html#2649" class="Bound">x</a> <a id="2651" href="SMT.Theories.Raw.Reflection.html#2141" class="Function Operator">∈-FV</a> <a id="2656" href="Agda.Builtin.Reflection.html#4804" class="InductiveConstructor">unknown</a>                <a id="2679" class="Symbol">=</a> <a id="2681" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>

  <a id="2690" class="Symbol">_</a> <a id="2692" href="SMT.Theories.Raw.Reflection.html#1984" class="Function Operator">∈-FVArgs</a> <a id="2701" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>             <a id="2716" class="Symbol">=</a> <a id="2718" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="2726" href="SMT.Theories.Raw.Reflection.html#2726" class="Bound">x</a> <a id="2728" href="SMT.Theories.Raw.Reflection.html#1984" class="Function Operator">∈-FVArgs</a> <a id="2737" class="Symbol">(</a><a id="2738" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="2742" class="Symbol">_</a> <a id="2744" href="SMT.Theories.Raw.Reflection.html#2744" class="Bound">t</a> <a id="2746" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2748" href="SMT.Theories.Raw.Reflection.html#2748" class="Bound">ts</a><a id="2750" class="Symbol">)</a> <a id="2752" class="Symbol">=</a> <a id="2754" href="SMT.Theories.Raw.Reflection.html#2726" class="Bound">x</a> <a id="2756" href="SMT.Theories.Raw.Reflection.html#2141" class="Function Operator">∈-FV</a> <a id="2761" href="SMT.Theories.Raw.Reflection.html#2744" class="Bound">t</a> <a id="2763" href="Data.Bool.Base.html#1044" class="Function Operator">∨</a> <a id="2765" href="SMT.Theories.Raw.Reflection.html#2726" class="Bound">x</a> <a id="2767" href="SMT.Theories.Raw.Reflection.html#1984" class="Function Operator">∈-FVArgs</a> <a id="2776" href="SMT.Theories.Raw.Reflection.html#2748" class="Bound">ts</a>

  <a id="2782" href="SMT.Theories.Raw.Reflection.html#2782" class="Bound">x</a> <a id="2784" href="SMT.Theories.Raw.Reflection.html#2029" class="Function Operator">∈-FVClauses</a> <a id="2796" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>       <a id="2805" class="Symbol">=</a> <a id="2807" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="2815" href="SMT.Theories.Raw.Reflection.html#2815" class="Bound">x</a> <a id="2817" href="SMT.Theories.Raw.Reflection.html#2029" class="Function Operator">∈-FVClauses</a> <a id="2829" class="Symbol">(</a><a id="2830" href="SMT.Theories.Raw.Reflection.html#2830" class="Bound">c</a> <a id="2832" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2834" href="SMT.Theories.Raw.Reflection.html#2834" class="Bound">cs</a><a id="2836" class="Symbol">)</a> <a id="2838" class="Symbol">=</a> <a id="2840" href="SMT.Theories.Raw.Reflection.html#2815" class="Bound">x</a> <a id="2842" href="SMT.Theories.Raw.Reflection.html#2070" class="Function Operator">∈-FVClause</a> <a id="2853" href="SMT.Theories.Raw.Reflection.html#2830" class="Bound">c</a> <a id="2855" href="Data.Bool.Base.html#1044" class="Function Operator">∨</a> <a id="2857" href="SMT.Theories.Raw.Reflection.html#2815" class="Bound">x</a> <a id="2859" href="SMT.Theories.Raw.Reflection.html#2029" class="Function Operator">∈-FVClauses</a> <a id="2871" href="SMT.Theories.Raw.Reflection.html#2834" class="Bound">cs</a>

  <a id="2877" class="Comment">-- Ignores types of bound variables</a>
  <a id="2915" href="SMT.Theories.Raw.Reflection.html#2915" class="Bound">x</a> <a id="2917" href="SMT.Theories.Raw.Reflection.html#2070" class="Function Operator">∈-FVClause</a> <a id="2928" href="Agda.Builtin.Reflection.html#5172" class="InductiveConstructor">Clause.clause</a>        <a id="2949" href="SMT.Theories.Raw.Reflection.html#2949" class="Bound">tel</a> <a id="2953" href="SMT.Theories.Raw.Reflection.html#2953" class="Bound">ps</a> <a id="2956" href="SMT.Theories.Raw.Reflection.html#2956" class="Bound">t</a> <a id="2958" class="Symbol">=</a> <a id="2960" class="Symbol">(</a><a id="2961" href="SMT.Theories.Raw.Reflection.html#2915" class="Bound">x</a> <a id="2963" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">Nat.+</a> <a id="2969" href="Data.List.Base.html#4577" class="Function">length</a> <a id="2976" href="SMT.Theories.Raw.Reflection.html#2949" class="Bound">tel</a><a id="2979" class="Symbol">)</a> <a id="2981" href="SMT.Theories.Raw.Reflection.html#2141" class="Function Operator">∈-FV</a> <a id="2986" href="SMT.Theories.Raw.Reflection.html#2956" class="Bound">t</a>
  <a id="2990" href="SMT.Theories.Raw.Reflection.html#2990" class="Bound">x</a> <a id="2992" href="SMT.Theories.Raw.Reflection.html#2070" class="Function Operator">∈-FVClause</a> <a id="3003" href="Agda.Builtin.Reflection.html#5275" class="InductiveConstructor">Clause.absurd-clause</a> <a id="3024" href="SMT.Theories.Raw.Reflection.html#3024" class="Bound">tel</a> <a id="3028" href="SMT.Theories.Raw.Reflection.html#3028" class="Bound">ps</a>   <a id="3033" class="Symbol">=</a> <a id="3035" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>

  <a id="3044" href="SMT.Theories.Raw.Reflection.html#3044" class="Bound">x</a> <a id="3046" href="SMT.Theories.Raw.Reflection.html#2106" class="Function Operator">∈-FVSort</a> <a id="3055" href="Agda.Builtin.Reflection.html#4840" class="InductiveConstructor">Sort.set</a> <a id="3064" href="SMT.Theories.Raw.Reflection.html#3064" class="Bound">t</a>   <a id="3068" class="Symbol">=</a> <a id="3070" href="SMT.Theories.Raw.Reflection.html#3044" class="Bound">x</a> <a id="3072" href="SMT.Theories.Raw.Reflection.html#2141" class="Function Operator">∈-FV</a> <a id="3077" href="SMT.Theories.Raw.Reflection.html#3064" class="Bound">t</a>
  <a id="3081" href="SMT.Theories.Raw.Reflection.html#3081" class="Bound">x</a> <a id="3083" href="SMT.Theories.Raw.Reflection.html#2106" class="Function Operator">∈-FVSort</a> <a id="3092" href="Agda.Builtin.Reflection.html#4870" class="InductiveConstructor">Sort.lit</a> <a id="3101" href="SMT.Theories.Raw.Reflection.html#3101" class="Bound">n</a>   <a id="3105" class="Symbol">=</a> <a id="3107" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="3115" href="SMT.Theories.Raw.Reflection.html#3115" class="Bound">x</a> <a id="3117" href="SMT.Theories.Raw.Reflection.html#2106" class="Function Operator">∈-FVSort</a> <a id="3126" href="Agda.Builtin.Reflection.html#4899" class="InductiveConstructor">Sort.unknown</a> <a id="3139" class="Symbol">=</a> <a id="3141" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>

<a id="3148" class="Keyword">private</a>
  <a id="3158" class="Keyword">pattern</a> <a id="`pos"></a><a id="3166" href="SMT.Theories.Raw.Reflection.html#3166" class="InductiveConstructor">`pos</a>    <a id="3174" href="SMT.Theories.Raw.Reflection.html#3203" class="Bound">a</a> <a id="3176" class="Symbol">=</a> <a id="3178" href="Agda.Builtin.Reflection.html#4404" class="InductiveConstructor">con</a> <a id="3182" class="Symbol">(</a><a id="3183" class="Keyword">quote</a> <a id="3189" href="Agda.Builtin.Int.html#264" class="InductiveConstructor Operator">Int.+_</a><a id="3195" class="Symbol">)</a> <a id="3197" class="Symbol">(</a><a id="3198" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="3203" href="SMT.Theories.Raw.Reflection.html#3203" class="Bound">a</a> <a id="3205" class="InductiveConstructor Operator">∷</a> <a id="3207" class="InductiveConstructor">[]</a><a id="3209" class="Symbol">)</a>
  <a id="3213" class="Comment">-- pattern `negsuc a = con (quote Int.-[1+_]) (vArg a ∷ [])</a>

<a id="3274" class="Comment">-- Dummy name used as a function symbol of type TERM _ → ⋆ to wrap variables.</a>
<a id="rawVar"></a><a id="3352" href="SMT.Theories.Raw.Reflection.html#3352" class="Function">rawVar</a> <a id="3359" class="Symbol">:</a> <a id="3361" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
<a id="3363" href="SMT.Theories.Raw.Reflection.html#3352" class="Function">rawVar</a> <a id="3370" class="Symbol">=</a> <a id="3372" class="Symbol">_</a>

<a id="3375" class="Keyword">mutual</a>
  <a id="reflectToRawTerm"></a><a id="3384" href="SMT.Theories.Raw.Reflection.html#3384" class="Function">reflectToRawTerm</a> <a id="3401" class="Symbol">:</a> <a id="3403" class="Symbol">(</a><a id="3404" href="SMT.Theories.Raw.Reflection.html#3404" class="Bound">Γ</a> <a id="3406" class="Symbol">:</a> <a id="3408" href="SMT.Theories.Raw.Base.html#2675" class="Function">RawCtxt</a><a id="3415" class="Symbol">)</a> <a id="3417" class="Symbol">(</a><a id="3418" href="SMT.Theories.Raw.Reflection.html#3418" class="Bound">fv</a> <a id="3421" class="Symbol">:</a> <a id="3423" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="3424" class="Symbol">)</a> <a id="3426" class="Symbol">→</a> <a id="3428" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="3433" class="Symbol">→</a> <a id="3435" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="3438" class="Symbol">(</a><a id="3439" href="SMT.Theories.Raw.Base.html#2748" class="Datatype">RawTerm</a> <a id="3447" href="SMT.Theories.Raw.Reflection.html#3404" class="Bound">Γ</a> <a id="3449" href="SMT.Theories.Raw.Base.html#1029" class="InductiveConstructor">⋆</a><a id="3450" class="Symbol">)</a>
  <a id="3454" href="SMT.Theories.Raw.Reflection.html#3384" class="Function">reflectToRawTerm</a> <a id="3471" href="SMT.Theories.Raw.Reflection.html#3471" class="Bound">Γ</a> <a id="3473" href="SMT.Theories.Raw.Reflection.html#3473" class="Bound">fv</a> <a id="3476" class="Symbol">(</a><a id="3477" href="Agda.Builtin.Reflection.html#4348" class="InductiveConstructor">var</a> <a id="3481" href="SMT.Theories.Raw.Reflection.html#3481" class="Bound">x</a> <a id="3483" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3485" class="Symbol">)</a> <a id="3487" class="Symbol">=</a> <a id="3489" class="Keyword">do</a>
    <a id="3496" href="SMT.Theories.Raw.Reflection.html#3496" class="Bound">σ</a> <a id="3498" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3500" href="SMT.Theories.Raw.Reflection.html#3500" class="Bound">y</a> <a id="3502" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3504" href="SMT.Theories.Raw.Reflection.html#1497" class="Function">reflectToRawVar</a> <a id="3520" href="SMT.Theories.Raw.Reflection.html#3471" class="Bound">Γ</a> <a id="3522" href="Category.Monad.Indexed.html#814" class="Function Operator">=&lt;&lt;</a> <a id="3526" href="SMT.Theories.Raw.Reflection.html#1795" class="Function">strengthenVar</a> <a id="3540" href="SMT.Theories.Raw.Reflection.html#3473" class="Bound">fv</a> <a id="3543" href="SMT.Theories.Raw.Reflection.html#3481" class="Bound">x</a>
    <a id="3549" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="3556" class="Symbol">(</a><a id="3557" href="SMT.Theories.Raw.Base.html#2856" class="InductiveConstructor">appᵣ</a> <a id="3562" class="Symbol">{</a><a id="3563" class="Argument">Σ</a> <a id="3565" class="Symbol">=</a> <a id="3567" class="Keyword">record</a><a id="3573" class="Symbol">{</a><a id="3574" href="SMT.Theory.html#542" class="Field">ArgSorts</a> <a id="3583" class="Symbol">=</a> <a id="3585" href="SMT.Theories.Raw.Reflection.html#3496" class="Bound">σ</a> <a id="3587" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3589" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3591" class="Symbol">}}</a> <a id="3594" class="Symbol">(</a><a id="3595" class="Keyword">quote</a> <a id="3601" href="SMT.Theories.Raw.Reflection.html#3352" class="Function">rawVar</a><a id="3607" class="Symbol">)</a> <a id="3609" class="Symbol">(</a><a id="3610" href="SMT.Theories.Raw.Base.html#2786" class="InductiveConstructor">varᵣ</a> <a id="3615" href="SMT.Theories.Raw.Reflection.html#3500" class="Bound">y</a> <a id="3617" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="3619" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="3621" class="Symbol">))</a>
  <a id="3626" href="SMT.Theories.Raw.Reflection.html#3384" class="CatchallClause Function">reflectToRawTerm</a><a id="3642" class="CatchallClause"> </a><a id="3643" href="SMT.Theories.Raw.Reflection.html#3643" class="CatchallClause Bound">Γ</a><a id="3644" class="CatchallClause"> </a><a id="3645" class="CatchallClause Symbol">_</a><a id="3646" class="CatchallClause">  </a><a id="3648" class="CatchallClause Symbol">(</a><a id="3649" href="Agda.Builtin.Reflection.html#4348" class="CatchallClause InductiveConstructor">var</a><a id="3652" class="CatchallClause"> </a><a id="3653" class="CatchallClause Symbol">_</a><a id="3654" class="CatchallClause"> </a><a id="3655" class="CatchallClause Symbol">_)</a>  <a id="3659" class="Symbol">=</a> <a id="3661" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="3674" class="String">&quot;Higher-order variable&quot;</a>
  <a id="3700" href="SMT.Theories.Raw.Reflection.html#3384" class="Function">reflectToRawTerm</a> <a id="3717" href="SMT.Theories.Raw.Reflection.html#3717" class="Bound">Γ</a> <a id="3719" class="Symbol">_</a>  <a id="3722" class="Symbol">(</a><a id="3723" href="Agda.Builtin.Reflection.html#4719" class="InductiveConstructor">lit</a> <a id="3727" href="SMT.Theories.Raw.Reflection.html#3727" class="Bound">l</a><a id="3728" class="Symbol">)</a>    <a id="3733" class="Symbol">=</a> <a id="3735" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="3742" class="Symbol">(</a><a id="3743" href="SMT.Theories.Raw.Base.html#2821" class="InductiveConstructor">litᵣ</a> <a id="3748" href="SMT.Theories.Raw.Reflection.html#3727" class="Bound">l</a><a id="3749" class="Symbol">)</a>
  <a id="3753" href="SMT.Theories.Raw.Reflection.html#3384" class="Function">reflectToRawTerm</a> <a id="3770" href="SMT.Theories.Raw.Reflection.html#3770" class="Bound">Γ</a> <a id="3772" href="SMT.Theories.Raw.Reflection.html#3772" class="Bound">fv</a> <a id="3775" class="Symbol">(</a><a id="3776" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="3780" href="SMT.Theories.Raw.Reflection.html#3780" class="Bound">f</a> <a id="3782" href="SMT.Theories.Raw.Reflection.html#3782" class="Bound">ts</a><a id="3784" class="Symbol">)</a> <a id="3786" class="Symbol">=</a> <a id="3788" href="SMT.Theories.Raw.Base.html#2856" class="InductiveConstructor">appᵣ</a> <a id="3793" class="Symbol">{</a><a id="3794" class="Argument">Σ</a> <a id="3796" class="Symbol">=</a> <a id="3798" href="SMT.Theories.Raw.Reflection.html#1281" class="Function">argTypes</a> <a id="3807" href="SMT.Theories.Raw.Reflection.html#3782" class="Bound">ts</a><a id="3809" class="Symbol">}</a> <a id="3811" href="SMT.Theories.Raw.Reflection.html#3780" class="Bound">f</a> <a id="3813" href="Category.Functor.html#608" class="Function Operator">&lt;$&gt;</a> <a id="3817" href="SMT.Theories.Raw.Reflection.html#4263" class="Function">reflectToRawArgs</a> <a id="3834" href="SMT.Theories.Raw.Reflection.html#3770" class="Bound">Γ</a> <a id="3836" href="SMT.Theories.Raw.Reflection.html#3772" class="Bound">fv</a> <a id="3839" href="SMT.Theories.Raw.Reflection.html#3782" class="Bound">ts</a>
  <a id="3844" href="SMT.Theories.Raw.Reflection.html#3384" class="Function">reflectToRawTerm</a> <a id="3861" href="SMT.Theories.Raw.Reflection.html#3861" class="Bound">Γ</a> <a id="3863" href="SMT.Theories.Raw.Reflection.html#3863" class="Bound">fv</a> <a id="3866" class="Symbol">(</a><a id="3867" href="Agda.Builtin.Reflection.html#4404" class="InductiveConstructor">con</a> <a id="3871" href="SMT.Theories.Raw.Reflection.html#3871" class="Bound">c</a> <a id="3873" href="SMT.Theories.Raw.Reflection.html#3873" class="Bound">ts</a><a id="3875" class="Symbol">)</a> <a id="3877" class="Symbol">=</a> <a id="3879" href="SMT.Theories.Raw.Base.html#2856" class="InductiveConstructor">appᵣ</a> <a id="3884" class="Symbol">{</a><a id="3885" class="Argument">Σ</a> <a id="3887" class="Symbol">=</a> <a id="3889" href="SMT.Theories.Raw.Reflection.html#1281" class="Function">argTypes</a> <a id="3898" href="SMT.Theories.Raw.Reflection.html#3873" class="Bound">ts</a><a id="3900" class="Symbol">}</a> <a id="3902" href="SMT.Theories.Raw.Reflection.html#3871" class="Bound">c</a> <a id="3904" href="Category.Functor.html#608" class="Function Operator">&lt;$&gt;</a> <a id="3908" href="SMT.Theories.Raw.Reflection.html#4263" class="Function">reflectToRawArgs</a> <a id="3925" href="SMT.Theories.Raw.Reflection.html#3861" class="Bound">Γ</a> <a id="3927" href="SMT.Theories.Raw.Reflection.html#3863" class="Bound">fv</a> <a id="3930" href="SMT.Theories.Raw.Reflection.html#3873" class="Bound">ts</a>
  <a id="3935" href="SMT.Theories.Raw.Reflection.html#3384" class="Function">reflectToRawTerm</a> <a id="3952" href="SMT.Theories.Raw.Reflection.html#3952" class="Bound">Γ</a> <a id="3954" href="SMT.Theories.Raw.Reflection.html#3954" class="Bound">fv</a> <a id="3957" class="Symbol">(</a><a id="3958" href="Agda.Builtin.Reflection.html#4636" class="InductiveConstructor">pi</a> <a id="3961" class="Symbol">(</a><a id="3962" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="3966" class="Symbol">_</a> <a id="3968" href="SMT.Theories.Raw.Reflection.html#3968" class="Bound">a</a><a id="3969" class="Symbol">)</a> <a id="3971" class="Symbol">(</a><a id="3972" href="Agda.Builtin.Reflection.html#3538" class="InductiveConstructor">abs</a> <a id="3976" class="Symbol">_</a> <a id="3978" href="SMT.Theories.Raw.Reflection.html#3978" class="Bound">b</a><a id="3979" class="Symbol">))</a> <a id="3982" class="Symbol">=</a> <a id="3984" class="Keyword">do</a>
    <a id="3991" href="SMT.Theories.Raw.Reflection.html#3991" class="Bound">a</a> <a id="3993" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3995" href="SMT.Theories.Raw.Reflection.html#3384" class="Function">reflectToRawTerm</a> <a id="4012" href="SMT.Theories.Raw.Reflection.html#3952" class="Bound">Γ</a> <a id="4014" href="SMT.Theories.Raw.Reflection.html#3954" class="Bound">fv</a> <a id="4017" href="SMT.Theories.Raw.Reflection.html#3968" class="Bound">a</a>
    <a id="4023" href="SMT.Theories.Raw.Reflection.html#4023" class="Bound">b</a> <a id="4025" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="4027" href="SMT.Theories.Raw.Reflection.html#3384" class="Function">reflectToRawTerm</a> <a id="4044" href="SMT.Theories.Raw.Reflection.html#3952" class="Bound">Γ</a> <a id="4046" class="Symbol">(</a><a id="4047" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="4051" href="SMT.Theories.Raw.Reflection.html#3954" class="Bound">fv</a><a id="4053" class="Symbol">)</a> <a id="4055" href="SMT.Theories.Raw.Reflection.html#3978" class="Bound">b</a>
    <a id="4061" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="4068" class="Symbol">(</a><a id="4069" href="SMT.Theories.Raw.Base.html#2856" class="InductiveConstructor">appᵣ</a> <a id="4074" class="Symbol">{</a><a id="4075" class="Argument">Σ</a> <a id="4077" class="Symbol">=</a> <a id="4079" class="Keyword">record</a> <a id="4086" class="Symbol">{</a><a id="4087" href="SMT.Theory.html#542" class="Field">ArgSorts</a> <a id="4096" class="Symbol">=</a> <a id="4098" href="SMT.Theories.Raw.Base.html#1029" class="InductiveConstructor">⋆</a> <a id="4100" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4102" href="SMT.Theories.Raw.Base.html#1029" class="InductiveConstructor">⋆</a> <a id="4104" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4106" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4108" class="Symbol">}}</a> <a id="4111" class="Symbol">(</a><a id="4112" class="Keyword">quote</a> <a id="4118" href="Function.Core.html#646" class="Function">Morphism</a><a id="4126" class="Symbol">)</a> <a id="4128" class="Symbol">(</a><a id="4129" href="SMT.Theories.Raw.Reflection.html#3991" class="Bound">a</a> <a id="4131" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="4133" href="SMT.Theories.Raw.Reflection.html#4023" class="Bound">b</a> <a id="4135" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="4137" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="4139" class="Symbol">))</a>
  <a id="4144" href="SMT.Theories.Raw.Reflection.html#3384" class="Function">reflectToRawTerm</a> <a id="4161" href="SMT.Theories.Raw.Reflection.html#4161" class="Bound">Γ</a> <a id="4163" href="SMT.Theories.Raw.Reflection.html#4163" class="Bound">fv</a> <a id="4166" class="Symbol">(</a><a id="4167" href="Agda.Builtin.Reflection.html#4754" class="InductiveConstructor">meta</a> <a id="4172" href="SMT.Theories.Raw.Reflection.html#4172" class="Bound">x</a> <a id="4174" class="Symbol">_)</a> <a id="4177" class="Symbol">=</a> <a id="4179" href="Agda.Builtin.Reflection.html#8569" class="Postulate">blockOnMeta</a> <a id="4191" href="SMT.Theories.Raw.Reflection.html#4172" class="Bound">x</a>
  <a id="4195" href="SMT.Theories.Raw.Reflection.html#3384" class="CatchallClause Function">reflectToRawTerm</a><a id="4211" class="CatchallClause"> </a><a id="4212" href="SMT.Theories.Raw.Reflection.html#4212" class="CatchallClause Bound">Γ</a><a id="4213" class="CatchallClause"> </a><a id="4214" href="SMT.Theories.Raw.Reflection.html#4214" class="CatchallClause Bound">fv</a><a id="4216" class="CatchallClause"> </a><a id="4217" href="SMT.Theories.Raw.Reflection.html#4217" class="CatchallClause Bound">t</a> <a id="4219" class="Symbol">=</a> <a id="4221" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="4234" class="String">&quot;reflectToRawTerm failed&quot;</a>

  <a id="reflectToRawArgs"></a><a id="4263" href="SMT.Theories.Raw.Reflection.html#4263" class="Function">reflectToRawArgs</a> <a id="4280" class="Symbol">:</a> <a id="4282" class="Symbol">∀</a> <a id="4284" href="SMT.Theories.Raw.Reflection.html#4284" class="Bound">Γ</a> <a id="4286" class="Symbol">(</a><a id="4287" href="SMT.Theories.Raw.Reflection.html#4287" class="Bound">fv</a> <a id="4290" class="Symbol">:</a> <a id="4292" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="4293" class="Symbol">)</a> <a id="4295" class="Symbol">(</a><a id="4296" href="SMT.Theories.Raw.Reflection.html#4296" class="Bound">ts</a> <a id="4299" class="Symbol">:</a> <a id="4301" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="4306" class="Symbol">(</a><a id="4307" href="Agda.Builtin.Reflection.html#3255" class="Datatype">Arg</a> <a id="4311" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a><a id="4315" class="Symbol">))</a> <a id="4318" class="Symbol">→</a> <a id="4320" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="4323" class="Symbol">(</a><a id="4324" href="SMT.Theories.Raw.Base.html#2967" class="Function">RawArgs</a> <a id="4332" href="SMT.Theories.Raw.Reflection.html#4284" class="Bound">Γ</a> <a id="4334" class="Symbol">(</a><a id="4335" href="SMT.Theory.html#542" class="Field">ArgSorts</a> <a id="4344" class="Symbol">(</a><a id="4345" href="SMT.Theories.Raw.Reflection.html#1281" class="Function">argTypes</a> <a id="4354" href="SMT.Theories.Raw.Reflection.html#4296" class="Bound">ts</a><a id="4356" class="Symbol">)))</a>
  <a id="4362" href="SMT.Theories.Raw.Reflection.html#4263" class="Function">reflectToRawArgs</a> <a id="4379" href="SMT.Theories.Raw.Reflection.html#4379" class="Bound">Γ</a> <a id="4381" href="SMT.Theories.Raw.Reflection.html#4381" class="Bound">fv</a> <a id="4384" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="4387" class="Symbol">=</a> <a id="4389" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="4396" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a>
  <a id="4401" href="SMT.Theories.Raw.Reflection.html#4263" class="Function">reflectToRawArgs</a> <a id="4418" href="SMT.Theories.Raw.Reflection.html#4418" class="Bound">Γ</a> <a id="4420" href="SMT.Theories.Raw.Reflection.html#4420" class="Bound">fv</a> <a id="4423" class="Symbol">(</a><a id="4424" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="4429" href="SMT.Theories.Raw.Reflection.html#4429" class="Bound">t</a> <a id="4431" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4433" href="SMT.Theories.Raw.Reflection.html#4433" class="Bound">ts</a><a id="4435" class="Symbol">)</a> <a id="4437" class="Symbol">=</a> <a id="4439" class="Symbol">⦇</a> <a id="4441" href="SMT.Theories.Raw.Reflection.html#3384" class="Function">reflectToRawTerm</a> <a id="4458" href="SMT.Theories.Raw.Reflection.html#4418" class="Bound">Γ</a> <a id="4460" href="SMT.Theories.Raw.Reflection.html#4420" class="Bound">fv</a> <a id="4463" href="SMT.Theories.Raw.Reflection.html#4429" class="Bound">t</a> <a id="4465" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="4467" href="SMT.Theories.Raw.Reflection.html#4263" class="Function">reflectToRawArgs</a> <a id="4484" href="SMT.Theories.Raw.Reflection.html#4418" class="Bound">Γ</a> <a id="4486" href="SMT.Theories.Raw.Reflection.html#4420" class="Bound">fv</a> <a id="4489" href="SMT.Theories.Raw.Reflection.html#4433" class="Bound">ts</a> <a id="4492" class="Symbol">⦈</a>
  <a id="4496" href="SMT.Theories.Raw.Reflection.html#4263" class="Function">reflectToRawArgs</a> <a id="4513" href="SMT.Theories.Raw.Reflection.html#4513" class="Bound">Γ</a> <a id="4515" href="SMT.Theories.Raw.Reflection.html#4515" class="Bound">fv</a> <a id="4518" class="Symbol">(</a><a id="4519" href="Reflection.Argument.html#1126" class="InductiveConstructor">hArg</a> <a id="4524" class="Symbol">_</a> <a id="4526" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4528" href="SMT.Theories.Raw.Reflection.html#4528" class="Bound">ts</a><a id="4530" class="Symbol">)</a> <a id="4532" class="Symbol">=</a> <a id="4534" href="SMT.Theories.Raw.Reflection.html#4263" class="Function">reflectToRawArgs</a> <a id="4551" href="SMT.Theories.Raw.Reflection.html#4513" class="Bound">Γ</a> <a id="4553" href="SMT.Theories.Raw.Reflection.html#4515" class="Bound">fv</a> <a id="4556" href="SMT.Theories.Raw.Reflection.html#4528" class="Bound">ts</a>
  <a id="4561" href="SMT.Theories.Raw.Reflection.html#4263" class="Function">reflectToRawArgs</a> <a id="4578" href="SMT.Theories.Raw.Reflection.html#4578" class="Bound">Γ</a> <a id="4580" href="SMT.Theories.Raw.Reflection.html#4580" class="Bound">fv</a> <a id="4583" class="Symbol">(</a><a id="4584" href="Reflection.Argument.html#1181" class="InductiveConstructor">iArg</a> <a id="4589" class="Symbol">_</a> <a id="4591" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4593" href="SMT.Theories.Raw.Reflection.html#4593" class="Bound">ts</a><a id="4595" class="Symbol">)</a> <a id="4597" class="Symbol">=</a> <a id="4599" href="SMT.Theories.Raw.Reflection.html#4263" class="Function">reflectToRawArgs</a> <a id="4616" href="SMT.Theories.Raw.Reflection.html#4578" class="Bound">Γ</a> <a id="4618" href="SMT.Theories.Raw.Reflection.html#4580" class="Bound">fv</a> <a id="4621" href="SMT.Theories.Raw.Reflection.html#4593" class="Bound">ts</a>
  <a id="4626" href="SMT.Theories.Raw.Reflection.html#4263" class="Function">reflectToRawArgs</a> <a id="4643" href="SMT.Theories.Raw.Reflection.html#4643" class="Bound">Γ</a> <a id="4645" href="SMT.Theories.Raw.Reflection.html#4645" class="Bound">fv</a> <a id="4648" class="Symbol">(</a><a id="4649" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="4653" class="Symbol">(</a><a id="4654" href="Agda.Builtin.Reflection.html#3195" class="InductiveConstructor">arg-info</a> <a id="4663" href="Agda.Builtin.Reflection.html#2763" class="InductiveConstructor">visible</a>   <a id="4673" href="Agda.Builtin.Reflection.html#3029" class="InductiveConstructor">irrelevant</a><a id="4683" class="Symbol">)</a> <a id="4685" class="Symbol">_</a> <a id="4687" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4689" href="SMT.Theories.Raw.Reflection.html#4689" class="Bound">ts</a><a id="4691" class="Symbol">)</a> <a id="4693" class="Symbol">=</a> <a id="4695" href="SMT.Theories.Raw.Reflection.html#4263" class="Function">reflectToRawArgs</a> <a id="4712" href="SMT.Theories.Raw.Reflection.html#4643" class="Bound">Γ</a> <a id="4714" href="SMT.Theories.Raw.Reflection.html#4645" class="Bound">fv</a> <a id="4717" href="SMT.Theories.Raw.Reflection.html#4689" class="Bound">ts</a>
  <a id="4722" href="SMT.Theories.Raw.Reflection.html#4263" class="Function">reflectToRawArgs</a> <a id="4739" href="SMT.Theories.Raw.Reflection.html#4739" class="Bound">Γ</a> <a id="4741" href="SMT.Theories.Raw.Reflection.html#4741" class="Bound">fv</a> <a id="4744" class="Symbol">(</a><a id="4745" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="4749" class="Symbol">(</a><a id="4750" href="Agda.Builtin.Reflection.html#3195" class="InductiveConstructor">arg-info</a> <a id="4759" href="Agda.Builtin.Reflection.html#2771" class="InductiveConstructor">hidden</a>    <a id="4769" href="Agda.Builtin.Reflection.html#3029" class="InductiveConstructor">irrelevant</a><a id="4779" class="Symbol">)</a> <a id="4781" href="SMT.Theories.Raw.Reflection.html#4781" class="Bound">t</a> <a id="4783" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4785" href="SMT.Theories.Raw.Reflection.html#4785" class="Bound">ts</a><a id="4787" class="Symbol">)</a> <a id="4789" class="Symbol">=</a> <a id="4791" href="SMT.Theories.Raw.Reflection.html#4263" class="Function">reflectToRawArgs</a> <a id="4808" href="SMT.Theories.Raw.Reflection.html#4739" class="Bound">Γ</a> <a id="4810" href="SMT.Theories.Raw.Reflection.html#4741" class="Bound">fv</a> <a id="4813" href="SMT.Theories.Raw.Reflection.html#4785" class="Bound">ts</a>
  <a id="4818" href="SMT.Theories.Raw.Reflection.html#4263" class="Function">reflectToRawArgs</a> <a id="4835" href="SMT.Theories.Raw.Reflection.html#4835" class="Bound">Γ</a> <a id="4837" href="SMT.Theories.Raw.Reflection.html#4837" class="Bound">fv</a> <a id="4840" class="Symbol">(</a><a id="4841" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="4845" class="Symbol">(</a><a id="4846" href="Agda.Builtin.Reflection.html#3195" class="InductiveConstructor">arg-info</a> <a id="4855" href="Agda.Builtin.Reflection.html#2778" class="InductiveConstructor">instance′</a> <a id="4865" href="Agda.Builtin.Reflection.html#3029" class="InductiveConstructor">irrelevant</a><a id="4875" class="Symbol">)</a> <a id="4877" href="SMT.Theories.Raw.Reflection.html#4877" class="Bound">t</a> <a id="4879" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4881" href="SMT.Theories.Raw.Reflection.html#4881" class="Bound">ts</a><a id="4883" class="Symbol">)</a> <a id="4885" class="Symbol">=</a> <a id="4887" href="SMT.Theories.Raw.Reflection.html#4263" class="Function">reflectToRawArgs</a> <a id="4904" href="SMT.Theories.Raw.Reflection.html#4835" class="Bound">Γ</a> <a id="4906" href="SMT.Theories.Raw.Reflection.html#4837" class="Bound">fv</a> <a id="4909" href="SMT.Theories.Raw.Reflection.html#4881" class="Bound">ts</a>


<a id="4914" class="Comment">-- |Decode a reflected Agda type to a raw SMT-LIB script.</a>
<a id="4972" class="Comment">--</a>
<a id="4975" class="Comment">--  Functions are decoded as a series of assertions, with the result type</a>
<a id="5049" class="Comment">--  negated. For instance, the type `(x y : ℤ) → x - y ≤ x + y → x ≡ y`</a>
<a id="5121" class="Comment">--  is decoded as:</a>
<a id="5140" class="Comment">--</a>
<a id="5143" class="Comment">--  @</a>
<a id="5149" class="Comment">--    (declare-const ⋆ x)</a>
<a id="5175" class="Comment">--    (declare-const ⋆ y)</a>
<a id="5201" class="Comment">--    (assert (≤ (- x y) (+ x y)))</a>
<a id="5236" class="Comment">--    (assert (not (= x y)))</a>
<a id="5265" class="Comment">--  @</a>
<a id="5271" class="Comment">--</a>
<a id="5274" class="Comment">--  Which corresponds to `∃[ x ] ∃[ y ] (x - y ≤ x + y × x ≢ y)`, i.e.,</a>
<a id="5346" class="Comment">--  the negation of the Agda type. If the solver can find an inhabitant</a>
<a id="5418" class="Comment">--  for this type, then we have a counter-example for the original type.</a>
<a id="5491" class="Comment">--</a>
<a id="reflectToRawScript"></a><a id="5494" href="SMT.Theories.Raw.Reflection.html#5494" class="Function">reflectToRawScript</a> <a id="5513" class="Symbol">:</a> <a id="5515" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="5520" class="Symbol">→</a> <a id="5522" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="5525" class="Symbol">(</a><a id="5526" href="Data.Product.html#1788" class="Function">∃[</a> <a id="5529" href="SMT.Theories.Raw.Reflection.html#5529" class="Bound">Γ</a> <a id="5531" href="Data.Product.html#1788" class="Function">]</a> <a id="5533" href="SMT.Theories.Raw.Base.html#3252" class="Datatype">RawScript</a> <a id="5543" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="5546" href="SMT.Theories.Raw.Reflection.html#5529" class="Bound">Γ</a> <a id="5548" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="5550" class="Symbol">)</a>
<a id="5552" href="SMT.Theories.Raw.Reflection.html#5494" class="Function">reflectToRawScript</a> <a id="5571" class="Symbol">=</a> <a id="5573" href="SMT.Theories.Raw.Reflection.html#5610" class="Function">reflectToRawScript′</a> <a id="5593" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="5596" class="Number">0</a>
  <a id="5600" class="Keyword">where</a>
    <a id="5610" href="SMT.Theories.Raw.Reflection.html#5610" class="Function">reflectToRawScript′</a> <a id="5630" class="Symbol">:</a> <a id="5632" class="Symbol">(</a><a id="5633" href="SMT.Theories.Raw.Reflection.html#5633" class="Bound">Γ</a> <a id="5635" class="Symbol">:</a> <a id="5637" href="SMT.Theories.Raw.Base.html#2675" class="Function">RawCtxt</a><a id="5644" class="Symbol">)</a> <a id="5646" class="Symbol">(</a><a id="5647" href="SMT.Theories.Raw.Reflection.html#5647" class="Bound">fv</a> <a id="5650" class="Symbol">:</a> <a id="5652" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="5653" class="Symbol">)</a> <a id="5655" class="Symbol">→</a> <a id="5657" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="5662" class="Symbol">→</a> <a id="5664" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="5667" class="Symbol">(</a><a id="5668" href="Data.Product.html#1788" class="Function">∃[</a> <a id="5671" href="SMT.Theories.Raw.Reflection.html#5671" class="Bound">Γ′</a> <a id="5674" href="Data.Product.html#1788" class="Function">]</a> <a id="5676" href="SMT.Theories.Raw.Base.html#3252" class="Datatype">RawScript</a> <a id="5686" href="SMT.Theories.Raw.Reflection.html#5633" class="Bound">Γ</a> <a id="5688" href="SMT.Theories.Raw.Reflection.html#5671" class="Bound">Γ′</a> <a id="5691" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="5693" class="Symbol">)</a>
    <a id="5699" href="SMT.Theories.Raw.Reflection.html#5610" class="Function">reflectToRawScript′</a> <a id="5719" href="SMT.Theories.Raw.Reflection.html#5719" class="Bound">Γ</a> <a id="5721" href="SMT.Theories.Raw.Reflection.html#5721" class="Bound">fv</a> <a id="5724" class="Symbol">(</a><a id="5725" href="Agda.Builtin.Reflection.html#4636" class="InductiveConstructor">pi</a> <a id="5728" class="Symbol">(</a><a id="5729" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="5733" class="Symbol">_</a> <a id="5735" href="SMT.Theories.Raw.Reflection.html#5735" class="Bound">a</a><a id="5736" class="Symbol">)</a> <a id="5738" class="Symbol">(</a><a id="5739" href="Agda.Builtin.Reflection.html#3538" class="InductiveConstructor">abs</a> <a id="5743" href="SMT.Theories.Raw.Reflection.html#5743" class="Bound">x</a> <a id="5745" href="SMT.Theories.Raw.Reflection.html#5745" class="Bound">b</a><a id="5746" class="Symbol">))</a> <a id="5749" class="Symbol">=</a>
      <a id="5757" href="Function.Base.html#4121" class="Function Operator">case</a> <a id="5762" class="Number">0</a> <a id="5764" href="SMT.Theories.Raw.Reflection.html#2141" class="Function Operator">∈-FV</a> <a id="5769" href="SMT.Theories.Raw.Reflection.html#5745" class="Bound">b</a> <a id="5771" href="Function.Base.html#4121" class="Function Operator">of</a> <a id="5774" class="Symbol">λ</a> <a id="5776" class="Keyword">where</a>
        <a id="5790" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="5795" class="Symbol">→</a> <a id="5797" class="Keyword">do</a>
          <a id="5810" href="SMT.Theories.Raw.Reflection.html#5810" class="Bound">Γ′</a> <a id="5813" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5815" href="SMT.Theories.Raw.Reflection.html#5815" class="Bound">s</a> <a id="5817" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="5819" href="SMT.Theories.Raw.Reflection.html#5610" class="Function">reflectToRawScript′</a> <a id="5839" class="Symbol">(</a><a id="5840" href="SMT.Theories.Raw.Base.html#1046" class="InductiveConstructor">TERM</a> <a id="5845" href="SMT.Theories.Raw.Reflection.html#5735" class="Bound">a</a> <a id="5847" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="5849" href="SMT.Theories.Raw.Reflection.html#5719" class="Bound">Γ</a><a id="5850" class="Symbol">)</a> <a id="5852" href="SMT.Theories.Raw.Reflection.html#5721" class="Bound">fv</a> <a id="5855" href="SMT.Theories.Raw.Reflection.html#5745" class="Bound">b</a>
          <a id="5867" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="5874" class="Symbol">(</a><a id="5875" href="SMT.Theories.Raw.Reflection.html#5810" class="Bound">Γ′</a> <a id="5878" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5880" href="SMT.Theories.Raw.Base.html#3087" class="InductiveConstructor">declare-constᵣ</a> <a id="5895" href="SMT.Theories.Raw.Reflection.html#5743" class="Bound">x</a> <a id="5897" class="Symbol">(</a><a id="5898" href="SMT.Theories.Raw.Base.html#1046" class="InductiveConstructor">TERM</a> <a id="5903" href="SMT.Theories.Raw.Reflection.html#5735" class="Bound">a</a><a id="5904" class="Symbol">)</a> <a id="5906" href="SMT.Theories.Raw.Base.html#3326" class="InductiveConstructor Operator">∷ᵣ</a> <a id="5909" href="SMT.Theories.Raw.Reflection.html#5815" class="Bound">s</a><a id="5910" class="Symbol">)</a>
        <a id="5920" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="5926" class="Symbol">→</a> <a id="5928" class="Keyword">do</a>
          <a id="5941" href="SMT.Theories.Raw.Reflection.html#5941" class="Bound">t</a> <a id="5943" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="5945" href="SMT.Theories.Raw.Reflection.html#3384" class="Function">reflectToRawTerm</a> <a id="5962" href="SMT.Theories.Raw.Reflection.html#5719" class="Bound">Γ</a> <a id="5964" href="SMT.Theories.Raw.Reflection.html#5721" class="Bound">fv</a> <a id="5967" href="SMT.Theories.Raw.Reflection.html#5735" class="Bound">a</a>
          <a id="5979" href="SMT.Theories.Raw.Reflection.html#5979" class="Bound">Γ′</a> <a id="5982" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5984" href="SMT.Theories.Raw.Reflection.html#5984" class="Bound">s</a> <a id="5986" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="5988" href="SMT.Theories.Raw.Reflection.html#5610" class="Function">reflectToRawScript′</a> <a id="6008" href="SMT.Theories.Raw.Reflection.html#5719" class="Bound">Γ</a> <a id="6010" class="Symbol">(</a><a id="6011" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="6015" href="SMT.Theories.Raw.Reflection.html#5721" class="Bound">fv</a><a id="6017" class="Symbol">)</a> <a id="6019" href="SMT.Theories.Raw.Reflection.html#5745" class="Bound">b</a>
          <a id="6031" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="6038" class="Symbol">(</a><a id="6039" href="SMT.Theories.Raw.Reflection.html#5979" class="Bound">Γ′</a> <a id="6042" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6044" href="SMT.Theories.Raw.Base.html#3132" class="InductiveConstructor">assertᵣ</a> <a id="6052" href="SMT.Theories.Raw.Reflection.html#5941" class="Bound">t</a> <a id="6054" href="SMT.Theories.Raw.Base.html#3326" class="InductiveConstructor Operator">∷ᵣ</a> <a id="6057" href="SMT.Theories.Raw.Reflection.html#5984" class="Bound">s</a><a id="6058" class="Symbol">)</a>
    <a id="6064" href="SMT.Theories.Raw.Reflection.html#5610" class="CatchallClause Function">reflectToRawScript′</a><a id="6083" class="CatchallClause"> </a><a id="6084" href="SMT.Theories.Raw.Reflection.html#6084" class="CatchallClause Bound">Γ</a><a id="6085" class="CatchallClause"> </a><a id="6086" href="SMT.Theories.Raw.Reflection.html#6086" class="CatchallClause Bound">fv</a><a id="6088" class="CatchallClause"> </a><a id="6089" href="SMT.Theories.Raw.Reflection.html#6089" class="CatchallClause Bound">t</a> <a id="6091" class="Symbol">=</a> <a id="6093" class="Keyword">do</a>
      <a id="6102" href="SMT.Theories.Raw.Reflection.html#6102" class="Bound">t</a> <a id="6104" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="6106" href="SMT.Theories.Raw.Reflection.html#3384" class="Function">reflectToRawTerm</a> <a id="6123" href="SMT.Theories.Raw.Reflection.html#6084" class="Bound">Γ</a> <a id="6125" href="SMT.Theories.Raw.Reflection.html#6086" class="Bound">fv</a> <a id="6128" href="SMT.Theories.Raw.Reflection.html#6089" class="Bound">t</a>
      <a id="6136" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="6143" class="Symbol">(</a><a id="6144" href="SMT.Theories.Raw.Reflection.html#6084" class="Bound">Γ</a> <a id="6146" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6148" href="SMT.Theories.Raw.Base.html#3132" class="InductiveConstructor">assertᵣ</a> <a id="6156" class="Symbol">(</a><a id="6157" href="SMT.Theories.Raw.Base.html#2856" class="InductiveConstructor">appᵣ</a> <a id="6162" class="Symbol">(</a><a id="6163" class="Keyword">quote</a> <a id="6169" href="Relation.Nullary.html#653" class="Function Operator">¬_</a><a id="6171" class="Symbol">)</a> <a id="6173" class="Symbol">(</a><a id="6174" href="SMT.Theories.Raw.Reflection.html#6102" class="Bound">t</a> <a id="6176" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="6178" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="6180" class="Symbol">))</a> <a id="6183" href="SMT.Theories.Raw.Base.html#3326" class="InductiveConstructor Operator">∷ᵣ</a> <a id="6186" href="SMT.Theories.Raw.Base.html#3292" class="InductiveConstructor">[]ᵣ</a><a id="6189" class="Symbol">)</a>
</pre></body></html>