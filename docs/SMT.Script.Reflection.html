<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SMT.Script.Reflection</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">open</a> <a id="6" class="Keyword">import</a> <a id="13" href="SMT.Theory.html" class="Module">SMT.Theory</a>

<a id="25" class="Keyword">module</a> <a id="32" href="SMT.Script.Reflection.html" class="Module">SMT.Script.Reflection</a> <a id="54" class="Symbol">{</a><a id="55" href="SMT.Script.Reflection.html#55" class="Bound">theory</a> <a id="62" class="Symbol">:</a> <a id="64" href="SMT.Theory.Base.html#2395" class="Record">Theory</a><a id="70" class="Symbol">}</a> <a id="72" class="Symbol">(</a><a id="73" href="SMT.Script.Reflection.html#73" class="Bound">reflectable</a> <a id="85" class="Symbol">:</a> <a id="87" href="SMT.Theory.Reflectable.html#331" class="Record">Reflectable</a> <a id="99" href="SMT.Script.Reflection.html#55" class="Bound">theory</a><a id="105" class="Symbol">)</a> <a id="107" class="Keyword">where</a>

<a id="114" class="Keyword">open</a> <a id="119" href="SMT.Theory.Base.html#2395" class="Module">Theory</a> <a id="126" href="SMT.Script.Reflection.html#55" class="Bound">theory</a>
<a id="133" class="Keyword">open</a> <a id="138" href="SMT.Theory.Reflectable.html#331" class="Module">Reflectable</a> <a id="150" href="SMT.Script.Reflection.html#73" class="Bound">reflectable</a>

<a id="163" class="Keyword">open</a> <a id="168" class="Keyword">import</a> <a id="175" href="Category.Monad.html" class="Module">Category.Monad</a>
<a id="190" class="Keyword">open</a> <a id="195" class="Keyword">import</a> <a id="202" href="Data.Environment.html" class="Module">Data.Environment</a> <a id="219" class="Symbol">as</a> <a id="222" class="Module">Env</a> <a id="226" class="Keyword">using</a> <a id="232" class="Symbol">(</a><a id="233" href="Data.Environment.html#360" class="Datatype">Env</a><a id="236" class="Symbol">;</a> <a id="238" href="Data.Environment.html#427" class="InductiveConstructor Operator">_∷_</a><a id="241" class="Symbol">;</a> <a id="243" href="Data.Environment.html#410" class="InductiveConstructor">[]</a><a id="245" class="Symbol">)</a>
<a id="247" class="Keyword">open</a> <a id="252" class="Keyword">import</a> <a id="259" href="Data.Fin.html" class="Module">Data.Fin</a> <a id="268" class="Symbol">as</a> <a id="271" class="Module">Fin</a> <a id="275" class="Keyword">using</a> <a id="281" class="Symbol">(</a><a id="282" href="Data.Fin.Base.html#1138" class="Datatype">Fin</a><a id="285" class="Symbol">;</a> <a id="287" href="Data.Fin.Base.html#1191" class="InductiveConstructor">suc</a><a id="290" class="Symbol">;</a> <a id="292" href="Data.Fin.Base.html#1160" class="InductiveConstructor">zero</a><a id="296" class="Symbol">)</a>
<a id="298" class="Keyword">open</a> <a id="303" class="Keyword">import</a> <a id="310" href="Data.List.html" class="Module">Data.List</a> <a id="320" class="Symbol">as</a> <a id="323" class="Module">List</a> <a id="328" class="Keyword">using</a> <a id="334" class="Symbol">(</a><a id="335" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="339" class="Symbol">;</a> <a id="341" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="344" class="Symbol">;</a> <a id="346" href="Data.List.Base.html#9981" class="InductiveConstructor">[]</a><a id="348" class="Symbol">;</a> <a id="350" href="Data.List.Base.html#1763" class="Function Operator">_++_</a><a id="354" class="Symbol">;</a> <a id="356" href="Data.List.Base.html#4577" class="Function">length</a><a id="362" class="Symbol">)</a>
<a id="364" class="Keyword">open</a> <a id="369" class="Keyword">import</a> <a id="376" href="Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="405" class="Keyword">using</a> <a id="411" class="Symbol">(</a><a id="412" href="Data.List.Relation.Unary.All.html#1397" class="Datatype">All</a><a id="415" class="Symbol">;</a> <a id="417" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">_∷_</a><a id="420" class="Symbol">;</a> <a id="422" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="424" class="Symbol">)</a>
<a id="426" class="Keyword">open</a> <a id="431" class="Keyword">import</a> <a id="438" href="Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="467" class="Symbol">as</a> <a id="470" class="Module">Any</a> <a id="474" class="Keyword">using</a> <a id="480" class="Symbol">(</a><a id="481" href="Data.List.Relation.Unary.Any.html#1174" class="InductiveConstructor">here</a><a id="485" class="Symbol">;</a> <a id="487" href="Data.List.Relation.Unary.Any.html#1227" class="InductiveConstructor">there</a><a id="492" class="Symbol">)</a>
<a id="494" class="Keyword">open</a> <a id="499" class="Keyword">import</a> <a id="506" href="Data.Maybe.html" class="Module">Data.Maybe</a> <a id="517" class="Symbol">as</a> <a id="520" class="Module">Maybe</a> <a id="526" class="Keyword">using</a> <a id="532" class="Symbol">(</a><a id="533" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a><a id="538" class="Symbol">;</a> <a id="540" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a><a id="544" class="Symbol">;</a> <a id="546" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a><a id="553" class="Symbol">)</a>
<a id="555" class="Keyword">import</a> <a id="562" href="Data.Maybe.Categorical.html" class="Module">Data.Maybe.Categorical</a> <a id="585" class="Symbol">as</a> <a id="588" class="Module">MaybeCat</a>
<a id="597" class="Keyword">open</a> <a id="602" class="Keyword">import</a> <a id="609" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="618" class="Symbol">as</a> <a id="621" class="Module">Nat</a> <a id="625" class="Keyword">using</a> <a id="631" class="Symbol">(</a><a id="632" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="633" class="Symbol">;</a> <a id="635" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="638" class="Symbol">;</a> <a id="640" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="644" class="Symbol">)</a>
<a id="646" class="Keyword">open</a> <a id="651" class="Keyword">import</a> <a id="658" href="Data.Product.html" class="Module">Data.Product</a> <a id="671" class="Symbol">as</a> <a id="674" class="Module">Prod</a> <a id="679" class="Keyword">using</a> <a id="685" class="Symbol">(</a><a id="686" href="Data.Product.html#1369" class="Function">∃</a><a id="687" class="Symbol">;</a> <a id="689" href="Data.Product.html#1806" class="Function">∃-syntax</a><a id="697" class="Symbol">;</a> <a id="699" href="Data.Product.html#2247" class="Function Operator">-,_</a><a id="702" class="Symbol">;</a> <a id="704" href="Data.Product.html#1167" class="Function Operator">_×_</a><a id="707" class="Symbol">;</a> <a id="709" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="712" class="Symbol">;</a> <a id="714" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="719" class="Symbol">;</a> <a id="721" href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="726" class="Symbol">)</a>
<a id="728" class="Keyword">open</a> <a id="733" class="Keyword">import</a> <a id="740" href="Data.String.html" class="Module">Data.String</a> <a id="752" class="Symbol">as</a> <a id="755" class="Module">String</a> <a id="762" class="Keyword">using</a> <a id="768" class="Symbol">(</a><a id="769" href="Agda.Builtin.String.html#336" class="Postulate">String</a><a id="775" class="Symbol">)</a>
<a id="777" class="Keyword">open</a> <a id="782" class="Keyword">import</a> <a id="789" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="799" class="Symbol">as</a> <a id="802" class="Module">Unit</a> <a id="807" class="Keyword">using</a> <a id="813" class="Symbol">(</a><a id="814" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="815" class="Symbol">)</a>
<a id="817" class="Keyword">open</a> <a id="822" class="Keyword">import</a> <a id="829" href="Data.Vec.html" class="Module">Data.Vec</a> <a id="838" class="Symbol">as</a> <a id="841" class="Module">Vec</a> <a id="845" class="Keyword">using</a> <a id="851" class="Symbol">(</a><a id="852" href="Data.Vec.Base.html#959" class="Datatype">Vec</a><a id="855" class="Symbol">;</a> <a id="857" href="Data.Vec.Base.html#1014" class="InductiveConstructor Operator">_∷_</a><a id="860" class="Symbol">;</a> <a id="862" href="Data.Vec.Base.html#995" class="InductiveConstructor">[]</a><a id="864" class="Symbol">)</a>
<a id="866" class="Keyword">open</a> <a id="871" class="Keyword">import</a> <a id="878" href="Function.html" class="Module">Function</a> <a id="887" class="Keyword">using</a> <a id="893" class="Symbol">(</a><a id="894" href="Function.Base.html#1919" class="Function Operator">_$_</a><a id="897" class="Symbol">;</a> <a id="899" href="Function.Base.html#4121" class="Function Operator">case_of_</a><a id="907" class="Symbol">;</a> <a id="909" href="Function.Base.html#1031" class="Function Operator">_∘_</a><a id="912" class="Symbol">;</a> <a id="914" href="Function.Base.html#636" class="Function">const</a><a id="919" class="Symbol">;</a> <a id="921" href="Function.Base.html#1554" class="Function">flip</a><a id="925" class="Symbol">;</a> <a id="927" href="Function.Base.html#615" class="Function">id</a><a id="929" class="Symbol">)</a>
<a id="931" class="Keyword">import</a> <a id="938" href="Function.Identity.Categorical.html" class="Module">Function.Identity.Categorical</a> <a id="968" class="Symbol">as</a> <a id="971" class="Module">Identity</a>
<a id="980" class="Keyword">import</a> <a id="987" href="Level.html" class="Module">Level</a>
<a id="993" class="Keyword">import</a> <a id="1000" href="Reflection.html" class="Module">Reflection</a> <a id="1011" class="Symbol">as</a> <a id="1014" class="Module">Rfl</a>
<a id="1018" class="Keyword">open</a> <a id="1023" class="Keyword">import</a> <a id="1030" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="1047" class="Keyword">using</a> <a id="1053" class="Symbol">(</a><a id="1054" href="Relation.Nullary.html#1508" class="Record">Dec</a><a id="1057" class="Symbol">;</a> <a id="1059" href="Relation.Nullary.html#1645" class="InductiveConstructor">yes</a><a id="1062" class="Symbol">;</a> <a id="1064" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a><a id="1066" class="Symbol">)</a>
<a id="1068" class="Keyword">open</a> <a id="1073" class="Keyword">import</a> <a id="1080" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a> <a id="1107" class="Keyword">using</a> <a id="1113" class="Symbol">(</a><a id="1114" href="Relation.Nullary.Decidable.Core.html#1365" class="Function">True</a><a id="1118" class="Symbol">)</a>
<a id="1120" class="Keyword">open</a> <a id="1125" class="Keyword">import</a> <a id="1132" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1170" class="Keyword">using</a> <a id="1176" class="Symbol">(</a><a id="1177" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="1180" class="Symbol">;</a> <a id="1182" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="1186" class="Symbol">;</a> <a id="1188" href="Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a><a id="1191" class="Symbol">)</a>
<a id="1193" class="Keyword">open</a> <a id="1198" class="Keyword">import</a> <a id="1205" href="SMT.Script.Base.html" class="Module">SMT.Script.Base</a> <a id="1221" href="SMT.Theory.Base.html#2427" class="Function">baseTheory</a>
<a id="1232" class="Keyword">open</a> <a id="1237" class="Keyword">import</a> <a id="1244" href="SMT.Script.Show.html" class="Module">SMT.Script.Show</a> <a id="1260" href="SMT.Script.Reflection.html#55" class="Bound">theory</a>

<a id="1268" class="Keyword">private</a>
  <a id="1278" class="Keyword">variable</a>
    <a id="1291" href="SMT.Script.Reflection.html#1291" class="Generalizable">σ</a> <a id="1293" href="SMT.Script.Reflection.html#1293" class="Generalizable">σ′</a>    <a id="1299" class="Symbol">:</a> <a id="1301" href="SMT.Theory.Base.html#1096" class="Function">Sort</a>
    <a id="1310" href="SMT.Script.Reflection.html#1310" class="Generalizable">Γ</a> <a id="1312" href="SMT.Script.Reflection.html#1312" class="Generalizable">Γ′</a> <a id="1315" href="SMT.Script.Reflection.html#1315" class="Generalizable">δΓ</a> <a id="1318" class="Symbol">:</a> <a id="1320" href="SMT.Script.Base.html#1586" class="Function">Ctxt</a>
    <a id="1329" href="SMT.Script.Reflection.html#1329" class="Generalizable">Δ</a> <a id="1331" href="SMT.Script.Reflection.html#1331" class="Generalizable">Δ′</a>    <a id="1337" class="Symbol">:</a> <a id="1339" href="SMT.Script.Base.html#1586" class="Function">Ctxt</a>
    <a id="1348" href="SMT.Script.Reflection.html#1348" class="Generalizable">Σ</a>       <a id="1356" class="Symbol">:</a> <a id="1358" href="SMT.Theory.Base.html#489" class="Record">Signature</a> <a id="1368" href="SMT.Script.Reflection.html#1291" class="Generalizable">σ</a>
    <a id="1374" href="SMT.Script.Reflection.html#1374" class="Generalizable">Σ′</a>      <a id="1382" class="Symbol">:</a> <a id="1384" href="SMT.Theory.Base.html#489" class="Record">Signature</a> <a id="1394" href="SMT.Script.Reflection.html#1293" class="Generalizable">σ′</a>
    <a id="1401" href="SMT.Script.Reflection.html#1401" class="Generalizable">ξ</a> <a id="1403" href="SMT.Script.Reflection.html#1403" class="Generalizable">ξ′</a>    <a id="1409" class="Symbol">:</a> <a id="1411" href="SMT.Script.Base.html#4710" class="Datatype">OutputType</a>
    <a id="1426" href="SMT.Script.Reflection.html#1426" class="Generalizable">Ξ</a> <a id="1428" href="SMT.Script.Reflection.html#1428" class="Generalizable">Ξ′</a> <a id="1431" href="SMT.Script.Reflection.html#1431" class="Generalizable">δΞ</a> <a id="1434" class="Symbol">:</a> <a id="1436" href="SMT.Script.Base.html#4804" class="Function">OutputCtxt</a>

<a id="1448" class="Comment">-- * Reflection hooks</a>

<a id="1471" class="Comment">-- TODO: The checkRawTerm and checkRawCommand functions should be rewritten to</a>
<a id="1550" class="Comment">--       infer their argument sort, as opposed to just trying all sorts.</a>
<a id="1623" class="Comment">--       Premature optimisation and all that, but the current approach is</a>
<a id="1697" class="Comment">--       exponential.</a>
<a id="1719" class="Keyword">module</a> <a id="1726" href="SMT.Script.Reflection.html#1726" class="Module">_</a> <a id="1728" class="Keyword">where</a>

  <a id="1737" class="Keyword">open</a> <a id="1742" class="Keyword">import</a> <a id="1749" href="SMT.Theory.Raw.Reflection.html" class="Module">SMT.Theory.Raw.Reflection</a>

  <a id="1778" class="Keyword">private</a>
    <a id="1790" href="SMT.Script.Reflection.html#1790" class="Function">monadPlusMaybe</a> <a id="1805" class="Symbol">=</a> <a id="1807" href="Data.Maybe.Categorical.html#1616" class="Function">MaybeCat.monadPlus</a> <a id="1826" class="Symbol">{</a><a id="1827" href="Agda.Primitive.html#764" class="Primitive">Level.zero</a><a id="1837" class="Symbol">}</a>

  <a id="1842" class="Keyword">open</a> <a id="1847" href="Category.Monad.html#1023" class="Module">RawMonadPlus</a> <a id="1860" href="SMT.Script.Reflection.html#1790" class="Function">monadPlusMaybe</a> <a id="1875" class="Keyword">renaming</a> <a id="1884" class="Symbol">(</a><a id="1885" href="Category.Applicative.Indexed.html#1034" class="Function Operator">_⊛_</a> <a id="1889" class="Symbol">to</a> <a id="1892" href="SMT.Script.Reflection.html#1892" class="Function Operator">_&lt;*&gt;_</a><a id="1897" class="Symbol">)</a>


  <a id="1903" class="Keyword">private</a>
    <a id="1915" class="Keyword">variable</a>
      <a id="1930" href="SMT.Script.Reflection.html#1930" class="Generalizable">σᵣ</a>         <a id="1941" class="Symbol">:</a> <a id="1943" href="SMT.Theory.Raw.Base.html#1010" class="Datatype">RawSort</a>
      <a id="1957" href="SMT.Script.Reflection.html#1957" class="Generalizable">Γᵣ</a> <a id="1960" href="SMT.Script.Reflection.html#1960" class="Generalizable">Γᵣ′</a> <a id="1964" href="SMT.Script.Reflection.html#1964" class="Generalizable">δΓᵣ</a> <a id="1968" class="Symbol">:</a> <a id="1970" href="SMT.Theory.Raw.Base.html#2684" class="Function">RawCtxt</a>
      <a id="1984" href="SMT.Script.Reflection.html#1984" class="Generalizable">Ξᵣ</a> <a id="1987" href="SMT.Script.Reflection.html#1987" class="Generalizable">Ξᵣ′</a> <a id="1991" href="SMT.Script.Reflection.html#1991" class="Generalizable">δΞᵣ</a> <a id="1995" class="Symbol">:</a> <a id="1997" href="SMT.Theory.Raw.Base.html#2638" class="Function">RawOutputCtxt</a>
      <a id="2017" href="SMT.Script.Reflection.html#2017" class="Generalizable">Δᵣ</a> <a id="2020" href="SMT.Script.Reflection.html#2020" class="Generalizable">Δᵣ′</a>     <a id="2028" class="Symbol">:</a> <a id="2030" href="SMT.Theory.Raw.Base.html#2684" class="Function">RawCtxt</a>

  <a id="2041" href="SMT.Script.Reflection.html#2041" class="Function">checkRawSort</a> <a id="2054" class="Symbol">:</a> <a id="2056" href="SMT.Theory.Raw.Base.html#1010" class="Datatype">RawSort</a> <a id="2064" class="Symbol">→</a> <a id="2066" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="2072" href="SMT.Theory.Base.html#1096" class="Function">Sort</a>
  <a id="2079" href="SMT.Script.Reflection.html#2041" class="Function">checkRawSort</a> <a id="2092" href="SMT.Theory.Raw.Base.html#1032" class="InductiveConstructor">⋆</a>        <a id="2101" class="Symbol">=</a> <a id="2103" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="2108" href="SMT.Theory.Base.html#1169" class="Function">BOOL</a>
  <a id="2115" href="SMT.Script.Reflection.html#2041" class="Function">checkRawSort</a> <a id="2128" class="Symbol">(</a><a id="2129" href="SMT.Theory.Raw.Base.html#1049" class="InductiveConstructor">TERM</a> <a id="2134" href="SMT.Script.Reflection.html#2134" class="Bound">x</a><a id="2135" class="Symbol">)</a> <a id="2137" class="Symbol">=</a> <a id="2139" href="SMT.Theory.Reflectable.html#399" class="Field">checkSort</a> <a id="2149" href="SMT.Script.Reflection.html#2134" class="Bound">x</a>

  <a id="2154" href="SMT.Script.Reflection.html#2154" class="Function">checkRawVar</a> <a id="2166" class="Symbol">:</a> <a id="2168" class="Symbol">(</a><a id="2169" href="SMT.Script.Reflection.html#2169" class="Bound">Γ</a> <a id="2171" class="Symbol">:</a> <a id="2173" href="SMT.Script.Base.html#1586" class="Function">Ctxt</a><a id="2177" class="Symbol">)</a> <a id="2179" class="Symbol">(</a><a id="2180" href="SMT.Script.Reflection.html#2180" class="Bound">σ</a> <a id="2182" class="Symbol">:</a> <a id="2184" href="SMT.Theory.Base.html#1096" class="Function">Sort</a><a id="2188" class="Symbol">)</a> <a id="2190" class="Symbol">(</a><a id="2191" href="SMT.Script.Reflection.html#2191" class="Bound">n</a> <a id="2193" class="Symbol">:</a> <a id="2195" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2196" class="Symbol">)</a> <a id="2198" class="Symbol">→</a> <a id="2200" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="2206" class="Symbol">(</a><a id="2207" href="SMT.Script.Reflection.html#2169" class="Bound">Γ</a> <a id="2209" href="SMT.Script.Base.html#1809" class="Function Operator">∋</a> <a id="2211" href="SMT.Script.Reflection.html#2180" class="Bound">σ</a><a id="2212" class="Symbol">)</a>
  <a id="2216" href="SMT.Script.Reflection.html#2154" class="Function">checkRawVar</a> <a id="2228" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>       <a id="2237" href="SMT.Script.Reflection.html#2237" class="Bound">σ</a> <a id="2239" href="SMT.Script.Reflection.html#2239" class="Bound">n</a>       <a id="2247" class="Symbol">=</a> <a id="2249" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>
  <a id="2259" href="SMT.Script.Reflection.html#2154" class="Function">checkRawVar</a> <a id="2271" class="Symbol">(</a><a id="2272" href="SMT.Script.Reflection.html#2272" class="Bound">σ′</a> <a id="2275" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2277" href="SMT.Script.Reflection.html#2277" class="Bound">Γ</a><a id="2278" class="Symbol">)</a> <a id="2280" href="SMT.Script.Reflection.html#2280" class="Bound">σ</a> <a id="2282" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="2290" class="Symbol">=</a> <a id="2292" class="Symbol">⦇</a> <a id="2294" class="Symbol">(</a><a id="2295" href="Data.List.Relation.Unary.Any.html#1174" class="InductiveConstructor">here</a> <a id="2300" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="2302" href="Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a><a id="2305" class="Symbol">)</a> <a id="2307" class="Symbol">(</a><a id="2308" href="Data.Maybe.Base.html#1212" class="Function">Maybe.decToMaybe</a> <a id="2325" class="Symbol">(</a><a id="2326" href="SMT.Script.Reflection.html#2272" class="Bound">σ′</a> <a id="2329" href="SMT.Theory.Base.html#1120" class="Function Operator">≟-Sort</a> <a id="2336" href="SMT.Script.Reflection.html#2280" class="Bound">σ</a><a id="2337" class="Symbol">))</a> <a id="2340" class="Symbol">⦈</a>
  <a id="2344" href="SMT.Script.Reflection.html#2154" class="Function">checkRawVar</a> <a id="2356" class="Symbol">(</a><a id="2357" href="SMT.Script.Reflection.html#2357" class="Bound">σ′</a> <a id="2360" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2362" href="SMT.Script.Reflection.html#2362" class="Bound">Γ</a><a id="2363" class="Symbol">)</a> <a id="2365" href="SMT.Script.Reflection.html#2365" class="Bound">σ</a> <a id="2367" class="Symbol">(</a><a id="2368" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2372" href="SMT.Script.Reflection.html#2372" class="Bound">n</a><a id="2373" class="Symbol">)</a> <a id="2375" class="Symbol">=</a> <a id="2377" class="Symbol">⦇</a> <a id="2379" href="SMT.Script.Base.html#1858" class="Function">extendVar</a> <a id="2389" class="Symbol">(</a><a id="2390" href="SMT.Script.Reflection.html#2154" class="Function">checkRawVar</a> <a id="2402" href="SMT.Script.Reflection.html#2362" class="Bound">Γ</a> <a id="2404" href="SMT.Script.Reflection.html#2365" class="Bound">σ</a> <a id="2406" href="SMT.Script.Reflection.html#2372" class="Bound">n</a><a id="2407" class="Symbol">)</a> <a id="2409" class="Symbol">⦈</a>

  <a id="2414" class="Keyword">mutual</a>
    <a id="2425" href="SMT.Script.Reflection.html#2425" class="Function">checkRawTerm</a> <a id="2438" class="Symbol">:</a> <a id="2440" class="Symbol">(</a><a id="2441" href="SMT.Script.Reflection.html#2441" class="Bound">Γ</a> <a id="2443" class="Symbol">:</a> <a id="2445" href="SMT.Script.Base.html#1586" class="Function">Ctxt</a><a id="2449" class="Symbol">)</a> <a id="2451" class="Symbol">(</a><a id="2452" href="SMT.Script.Reflection.html#2452" class="Bound">σ</a> <a id="2454" class="Symbol">:</a> <a id="2456" href="SMT.Theory.Base.html#1096" class="Function">Sort</a><a id="2460" class="Symbol">)</a> <a id="2462" class="Symbol">{</a><a id="2463" href="SMT.Script.Reflection.html#2463" class="Bound">σᵣ</a> <a id="2466" class="Symbol">:</a> <a id="2468" href="SMT.Theory.Raw.Base.html#1010" class="Datatype">RawSort</a><a id="2475" class="Symbol">}</a> <a id="2477" class="Symbol">→</a> <a id="2479" href="SMT.Theory.Raw.Base.html#2761" class="Datatype">RawTerm</a> <a id="2487" href="SMT.Script.Reflection.html#1957" class="Generalizable">Γᵣ</a> <a id="2490" href="SMT.Script.Reflection.html#2463" class="Bound">σᵣ</a> <a id="2493" class="Symbol">→</a> <a id="2495" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="2501" class="Symbol">(</a><a id="2502" href="SMT.Script.Base.html#2328" class="Datatype">Term</a> <a id="2507" href="SMT.Script.Reflection.html#2441" class="Bound">Γ</a> <a id="2509" href="SMT.Script.Reflection.html#2452" class="Bound">σ</a><a id="2510" class="Symbol">)</a>
    <a id="2516" href="SMT.Script.Reflection.html#2425" class="Function">checkRawTerm</a> <a id="2529" href="SMT.Script.Reflection.html#2529" class="Bound">Γ</a> <a id="2531" href="SMT.Script.Reflection.html#2531" class="Bound">σ</a> <a id="2533" class="Symbol">(</a><a id="2534" href="SMT.Theory.Raw.Base.html#2877" class="InductiveConstructor">`appᵣ</a> <a id="2540" class="Symbol">(</a><a id="2541" class="Keyword">quote</a> <a id="2547" href="SMT.Theory.Raw.Reflection.html#2998" class="Function">rawVar</a><a id="2553" class="Symbol">)</a> <a id="2555" class="Symbol">(</a><a id="2556" href="SMT.Theory.Raw.Base.html#2801" class="InductiveConstructor">`varᵣ</a> <a id="2562" href="SMT.Script.Reflection.html#2562" class="Bound">n</a> <a id="2564" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="2566" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="2568" class="Symbol">))</a> <a id="2571" class="Symbol">=</a> <a id="2573" class="Keyword">do</a>
      <a id="2582" href="SMT.Script.Reflection.html#2582" class="Bound">x</a> <a id="2584" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="2586" href="SMT.Script.Reflection.html#2154" class="Function">checkRawVar</a> <a id="2598" href="SMT.Script.Reflection.html#2529" class="Bound">Γ</a> <a id="2600" href="SMT.Script.Reflection.html#2531" class="Bound">σ</a> <a id="2602" class="Symbol">(</a><a id="2603" href="Data.Fin.Base.html#1264" class="Function">Fin.toℕ</a> <a id="2611" class="Symbol">(</a><a id="2612" href="Data.List.Relation.Unary.Any.html#1909" class="Function">Any.index</a> <a id="2622" href="SMT.Script.Reflection.html#2562" class="Bound">n</a><a id="2623" class="Symbol">))</a>
      <a id="2632" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="2639" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="2641" href="SMT.Script.Base.html#2373" class="InductiveConstructor">`var</a> <a id="2646" href="SMT.Script.Reflection.html#2582" class="Bound">x</a>
    <a id="2652" href="SMT.Script.Reflection.html#2425" class="Function">checkRawTerm</a> <a id="2665" href="SMT.Script.Reflection.html#2665" class="Bound">Γ</a> <a id="2667" href="SMT.Script.Reflection.html#2667" class="Bound">σ</a> <a id="2669" class="Symbol">(</a><a id="2670" href="SMT.Theory.Raw.Base.html#2801" class="InductiveConstructor">`varᵣ</a> <a id="2676" href="SMT.Script.Reflection.html#2676" class="Bound">n</a><a id="2677" class="Symbol">)</a> <a id="2679" class="Symbol">=</a> <a id="2681" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="2689" class="Comment">-- should be no naked variables</a>
    <a id="2725" href="SMT.Script.Reflection.html#2425" class="Function">checkRawTerm</a> <a id="2738" href="SMT.Script.Reflection.html#2738" class="Bound">Γ</a> <a id="2740" href="SMT.Script.Reflection.html#2740" class="Bound">σ</a> <a id="2742" class="Symbol">(</a><a id="2743" href="SMT.Theory.Raw.Base.html#2839" class="InductiveConstructor">`litᵣ</a> <a id="2749" href="SMT.Script.Reflection.html#2749" class="Bound">l</a><a id="2750" class="Symbol">)</a> <a id="2752" class="Symbol">=</a> <a id="2754" class="Keyword">do</a>
      <a id="2763" href="SMT.Script.Reflection.html#2763" class="Bound">l</a> <a id="2765" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="2767" href="SMT.Theory.Reflectable.html#443" class="Field">checkLiteral</a> <a id="2780" href="SMT.Script.Reflection.html#2740" class="Bound">σ</a> <a id="2782" href="SMT.Script.Reflection.html#2749" class="Bound">l</a>
      <a id="2790" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="2797" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="2799" href="SMT.Script.Base.html#2423" class="InductiveConstructor">`lit</a> <a id="2804" href="SMT.Script.Reflection.html#2763" class="Bound">l</a>
    <a id="2810" href="SMT.Script.Reflection.html#2425" class="CatchallClause Function">checkRawTerm</a><a id="2822" class="CatchallClause"> </a><a id="2823" href="SMT.Script.Reflection.html#2823" class="CatchallClause Bound">Γ</a><a id="2824" class="CatchallClause"> </a><a id="2825" href="SMT.Script.Reflection.html#2825" class="CatchallClause Bound">σ</a><a id="2826" class="CatchallClause"> </a><a id="2827" class="CatchallClause Symbol">(</a><a id="2828" href="SMT.Theory.Raw.Base.html#2877" class="CatchallClause InductiveConstructor">`appᵣ</a><a id="2833" class="CatchallClause"> </a><a id="2834" href="SMT.Script.Reflection.html#2834" class="CatchallClause Bound">f</a><a id="2835" class="CatchallClause"> </a><a id="2836" href="SMT.Script.Reflection.html#2836" class="CatchallClause Bound">args</a><a id="2840" class="CatchallClause Symbol">)</a> <a id="2842" class="Symbol">=</a> <a id="2844" class="Keyword">do</a>
      <a id="2853" class="Symbol">(</a><a id="2854" href="SMT.Script.Reflection.html#2854" class="Bound">Σ</a> <a id="2856" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2858" href="SMT.Script.Reflection.html#2858" class="Bound">f</a><a id="2859" class="Symbol">)</a> <a id="2861" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="2863" href="SMT.Theory.Reflectable.html#510" class="Field">checkIdentifier</a> <a id="2879" href="SMT.Script.Reflection.html#2825" class="Bound">σ</a> <a id="2881" href="SMT.Script.Reflection.html#2834" class="Bound">f</a>
      <a id="2889" href="SMT.Script.Reflection.html#2889" class="Bound">args</a> <a id="2894" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="2896" href="SMT.Script.Reflection.html#3507" class="Function">checkRawArgs</a> <a id="2909" href="SMT.Script.Reflection.html#2823" class="Bound">Γ</a> <a id="2911" class="Symbol">(</a><a id="2912" href="SMT.Theory.Base.html#547" class="Field">ArgSorts</a> <a id="2921" href="SMT.Script.Reflection.html#2854" class="Bound">Σ</a><a id="2922" class="Symbol">)</a> <a id="2924" href="SMT.Script.Reflection.html#2836" class="Bound">args</a>
      <a id="2935" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="2942" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="2944" href="SMT.Script.Reflection.html#2858" class="Bound">f</a> <a id="2946" href="SMT.Script.Reflection.html#2889" class="Bound">args</a>
    <a id="2955" href="SMT.Script.Reflection.html#2425" class="Function">checkRawTerm</a> <a id="2968" href="SMT.Script.Reflection.html#2968" class="Bound">Γ</a> <a id="2970" href="SMT.Script.Reflection.html#2970" class="Bound">σ</a> <a id="2972" class="Symbol">(</a><a id="2973" href="SMT.Theory.Raw.Base.html#2915" class="InductiveConstructor">`forallᵣ</a> <a id="2982" href="SMT.Script.Reflection.html#2982" class="Bound">n</a> <a id="2984" href="SMT.Script.Reflection.html#2984" class="Bound">σᵣ</a> <a id="2987" href="SMT.Script.Reflection.html#2987" class="Bound">x</a><a id="2988" class="Symbol">)</a> <a id="2990" class="Symbol">=</a> <a id="2992" class="Keyword">do</a>
      <a id="3001" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="3006" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3008" href="Data.Maybe.Base.html#1212" class="Function">Maybe.decToMaybe</a> <a id="3025" class="Symbol">(</a><a id="3026" href="SMT.Script.Reflection.html#2970" class="Bound">σ</a> <a id="3028" href="SMT.Theory.Base.html#1120" class="Function Operator">≟-Sort</a> <a id="3035" href="SMT.Theory.Base.html#1169" class="Function">BOOL</a><a id="3039" class="Symbol">)</a>
      <a id="3047" href="SMT.Script.Reflection.html#3047" class="Bound">σ′</a>   <a id="3052" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3054" href="SMT.Script.Reflection.html#2041" class="Function">checkRawSort</a> <a id="3067" href="SMT.Script.Reflection.html#2984" class="Bound">σᵣ</a>
      <a id="3076" href="SMT.Script.Reflection.html#3076" class="Bound">x</a>    <a id="3081" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3083" href="SMT.Script.Reflection.html#2425" class="Function">checkRawTerm</a> <a id="3096" class="Symbol">(</a><a id="3097" href="SMT.Script.Reflection.html#3047" class="Bound">σ′</a> <a id="3100" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3102" href="SMT.Script.Reflection.html#2968" class="Bound">Γ</a><a id="3103" class="Symbol">)</a> <a id="3105" href="SMT.Theory.Base.html#1169" class="Function">BOOL</a> <a id="3110" href="SMT.Script.Reflection.html#2987" class="Bound">x</a>
      <a id="3118" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="3125" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="3127" href="SMT.Script.Base.html#2579" class="InductiveConstructor">`forall</a> <a id="3135" href="SMT.Script.Reflection.html#2982" class="Bound">n</a> <a id="3137" href="SMT.Script.Reflection.html#3047" class="Bound">σ′</a> <a id="3140" href="SMT.Script.Reflection.html#3076" class="Bound">x</a>
    <a id="3146" href="SMT.Script.Reflection.html#2425" class="Function">checkRawTerm</a> <a id="3159" href="SMT.Script.Reflection.html#3159" class="Bound">Γ</a> <a id="3161" href="SMT.Script.Reflection.html#3161" class="Bound">σ</a> <a id="3163" class="Symbol">(</a><a id="3164" href="SMT.Theory.Raw.Base.html#2956" class="InductiveConstructor">`existsᵣ</a> <a id="3173" href="SMT.Script.Reflection.html#3173" class="Bound">n</a> <a id="3175" href="SMT.Script.Reflection.html#3175" class="Bound">σᵣ</a> <a id="3178" href="SMT.Script.Reflection.html#3178" class="Bound">x</a><a id="3179" class="Symbol">)</a> <a id="3181" class="Symbol">=</a> <a id="3183" class="Keyword">do</a>
      <a id="3192" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="3197" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3199" href="Data.Maybe.Base.html#1212" class="Function">Maybe.decToMaybe</a> <a id="3216" class="Symbol">(</a><a id="3217" href="SMT.Script.Reflection.html#3161" class="Bound">σ</a> <a id="3219" href="SMT.Theory.Base.html#1120" class="Function Operator">≟-Sort</a> <a id="3226" href="SMT.Theory.Base.html#1169" class="Function">BOOL</a><a id="3230" class="Symbol">)</a>
      <a id="3238" href="SMT.Script.Reflection.html#3238" class="Bound">σ′</a>   <a id="3243" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3245" href="SMT.Script.Reflection.html#2041" class="Function">checkRawSort</a> <a id="3258" href="SMT.Script.Reflection.html#3175" class="Bound">σᵣ</a>
      <a id="3267" href="SMT.Script.Reflection.html#3267" class="Bound">x</a>    <a id="3272" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3274" href="SMT.Script.Reflection.html#2425" class="Function">checkRawTerm</a> <a id="3287" class="Symbol">(</a><a id="3288" href="SMT.Script.Reflection.html#3238" class="Bound">σ′</a> <a id="3291" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3293" href="SMT.Script.Reflection.html#3159" class="Bound">Γ</a><a id="3294" class="Symbol">)</a> <a id="3296" href="SMT.Theory.Base.html#1169" class="Function">BOOL</a> <a id="3301" href="SMT.Script.Reflection.html#3178" class="Bound">x</a>
      <a id="3309" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="3316" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="3318" href="SMT.Script.Base.html#2664" class="InductiveConstructor">`exists</a> <a id="3326" href="SMT.Script.Reflection.html#3173" class="Bound">n</a> <a id="3328" href="SMT.Script.Reflection.html#3238" class="Bound">σ′</a> <a id="3331" href="SMT.Script.Reflection.html#3267" class="Bound">x</a>
    <a id="3337" href="SMT.Script.Reflection.html#2425" class="Function">checkRawTerm</a> <a id="3350" href="SMT.Script.Reflection.html#3350" class="Bound">Γ</a> <a id="3352" href="SMT.Script.Reflection.html#3352" class="Bound">σ</a> <a id="3354" class="Symbol">(</a><a id="3355" href="SMT.Theory.Raw.Base.html#2997" class="InductiveConstructor">`letᵣ</a> <a id="3361" href="SMT.Script.Reflection.html#3361" class="Bound">n</a> <a id="3363" href="SMT.Script.Reflection.html#3363" class="Bound">σᵣ</a> <a id="3366" href="SMT.Script.Reflection.html#3366" class="Bound">x</a> <a id="3368" href="SMT.Script.Reflection.html#3368" class="Bound">y</a><a id="3369" class="Symbol">)</a> <a id="3371" class="Symbol">=</a> <a id="3373" class="Keyword">do</a>
      <a id="3382" href="SMT.Script.Reflection.html#3382" class="Bound">σ′</a> <a id="3385" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3387" href="SMT.Script.Reflection.html#2041" class="Function">checkRawSort</a> <a id="3400" href="SMT.Script.Reflection.html#3363" class="Bound">σᵣ</a>
      <a id="3409" href="SMT.Script.Reflection.html#3409" class="Bound">x</a>  <a id="3412" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3414" href="SMT.Script.Reflection.html#2425" class="Function">checkRawTerm</a> <a id="3427" href="SMT.Script.Reflection.html#3350" class="Bound">Γ</a> <a id="3429" href="SMT.Script.Reflection.html#3382" class="Bound">σ′</a> <a id="3432" href="SMT.Script.Reflection.html#3366" class="Bound">x</a>
      <a id="3440" href="SMT.Script.Reflection.html#3440" class="Bound">y</a>  <a id="3443" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3445" href="SMT.Script.Reflection.html#2425" class="Function">checkRawTerm</a> <a id="3458" class="Symbol">(</a><a id="3459" href="SMT.Script.Reflection.html#3382" class="Bound">σ′</a> <a id="3462" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3464" href="SMT.Script.Reflection.html#3350" class="Bound">Γ</a><a id="3465" class="Symbol">)</a> <a id="3467" href="SMT.Script.Reflection.html#3352" class="Bound">σ</a> <a id="3469" href="SMT.Script.Reflection.html#3368" class="Bound">y</a>
      <a id="3477" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="3484" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="3486" class="Symbol">(</a><a id="3487" href="SMT.Script.Base.html#2749" class="InductiveConstructor">`let</a> <a id="3492" href="SMT.Script.Reflection.html#3361" class="Bound">n</a> <a id="3494" href="SMT.Script.Reflection.html#3382" class="Bound">σ′</a> <a id="3497" href="SMT.Script.Reflection.html#3409" class="Bound">x</a> <a id="3499" href="SMT.Script.Reflection.html#3440" class="Bound">y</a><a id="3500" class="Symbol">)</a>

    <a id="3507" href="SMT.Script.Reflection.html#3507" class="Function">checkRawArgs</a> <a id="3520" class="Symbol">:</a> <a id="3522" class="Symbol">(</a><a id="3523" href="SMT.Script.Reflection.html#3523" class="Bound">Γ</a> <a id="3525" href="SMT.Script.Reflection.html#3525" class="Bound">Δ</a> <a id="3527" class="Symbol">:</a> <a id="3529" href="SMT.Script.Base.html#1586" class="Function">Ctxt</a><a id="3533" class="Symbol">)</a> <a id="3535" class="Symbol">→</a> <a id="3537" href="SMT.Theory.Raw.Base.html#3035" class="Function">RawArgs</a> <a id="3545" href="SMT.Script.Reflection.html#1957" class="Generalizable">Γᵣ</a> <a id="3548" href="SMT.Script.Reflection.html#2017" class="Generalizable">Δᵣ</a> <a id="3551" class="Symbol">→</a> <a id="3553" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="3559" class="Symbol">(</a><a id="3560" href="SMT.Script.Base.html#2836" class="Function">Args</a> <a id="3565" href="SMT.Script.Reflection.html#3523" class="Bound">Γ</a> <a id="3567" href="SMT.Script.Reflection.html#3525" class="Bound">Δ</a><a id="3568" class="Symbol">)</a>
    <a id="3574" href="SMT.Script.Reflection.html#3507" class="Function">checkRawArgs</a> <a id="3587" href="SMT.Script.Reflection.html#3587" class="Bound">Γ</a> <a id="3589" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>      <a id="3597" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a>           <a id="3610" class="Symbol">=</a> <a id="3612" class="Symbol">⦇</a> <a id="3614" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a> <a id="3617" class="Symbol">⦈</a>
    <a id="3623" href="SMT.Script.Reflection.html#3507" class="Function">checkRawArgs</a> <a id="3636" href="SMT.Script.Reflection.html#3636" class="Bound">Γ</a> <a id="3638" class="Symbol">(</a><a id="3639" href="SMT.Script.Reflection.html#3639" class="Bound">σ</a> <a id="3641" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3643" href="SMT.Script.Reflection.html#3643" class="Bound">Δ</a><a id="3644" class="Symbol">)</a> <a id="3646" class="Symbol">(</a><a id="3647" href="SMT.Script.Reflection.html#3647" class="Bound">arg</a> <a id="3651" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="3653" href="SMT.Script.Reflection.html#3653" class="Bound">args</a><a id="3657" class="Symbol">)</a> <a id="3659" class="Symbol">=</a> <a id="3661" class="Symbol">⦇</a> <a id="3663" class="Symbol">(</a><a id="3664" href="SMT.Script.Reflection.html#2425" class="Function">checkRawTerm</a> <a id="3677" href="SMT.Script.Reflection.html#3636" class="Bound">Γ</a> <a id="3679" href="SMT.Script.Reflection.html#3639" class="Bound">σ</a> <a id="3681" href="SMT.Script.Reflection.html#3647" class="Bound">arg</a><a id="3684" class="Symbol">)</a> <a id="3686" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="3688" class="Symbol">(</a><a id="3689" href="SMT.Script.Reflection.html#3507" class="Function">checkRawArgs</a> <a id="3702" href="SMT.Script.Reflection.html#3636" class="Bound">Γ</a> <a id="3704" href="SMT.Script.Reflection.html#3643" class="Bound">Δ</a> <a id="3706" href="SMT.Script.Reflection.html#3653" class="Bound">args</a><a id="3710" class="Symbol">)</a> <a id="3712" class="Symbol">⦈</a>
    <a id="3718" href="SMT.Script.Reflection.html#3507" class="CatchallClause Function">checkRawArgs</a><a id="3730" class="CatchallClause"> </a><a id="3731" class="CatchallClause Symbol">_</a><a id="3732" class="CatchallClause"> </a><a id="3733" class="CatchallClause Symbol">_</a><a id="3734" class="CatchallClause">       </a><a id="3741" class="CatchallClause Symbol">_</a>            <a id="3754" class="Symbol">=</a> <a id="3756" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>

  <a id="3767" href="SMT.Script.Reflection.html#3767" class="Function Operator">Script[_↦_,_↦_,_↦_]</a> <a id="3787" class="Symbol">:</a>
    <a id="3793" class="Symbol">(</a><a id="3794" href="SMT.Script.Reflection.html#3794" class="Bound">Γᵣ</a>  <a id="3798" class="Symbol">:</a> <a id="3800" href="SMT.Theory.Raw.Base.html#2684" class="Function">RawCtxt</a><a id="3807" class="Symbol">)</a>       <a id="3815" class="Symbol">(</a><a id="3816" href="SMT.Script.Reflection.html#3816" class="Bound">Γ</a>  <a id="3819" class="Symbol">:</a> <a id="3821" href="Data.Vec.Base.html#959" class="Datatype">Vec</a> <a id="3825" href="SMT.Theory.Base.html#1096" class="Function">Sort</a> <a id="3830" class="Symbol">(</a><a id="3831" href="Data.List.Base.html#4577" class="Function">length</a> <a id="3838" href="SMT.Script.Reflection.html#3794" class="Bound">Γᵣ</a><a id="3840" class="Symbol">))</a>
    <a id="3847" class="Symbol">(</a><a id="3848" href="SMT.Script.Reflection.html#3848" class="Bound">Γᵣ′</a> <a id="3852" class="Symbol">:</a> <a id="3854" href="SMT.Theory.Raw.Base.html#2684" class="Function">RawCtxt</a><a id="3861" class="Symbol">)</a>       <a id="3869" class="Symbol">(</a><a id="3870" href="SMT.Script.Reflection.html#3870" class="Bound">Γ′</a> <a id="3873" class="Symbol">:</a> <a id="3875" href="Data.Vec.Base.html#959" class="Datatype">Vec</a> <a id="3879" href="SMT.Theory.Base.html#1096" class="Function">Sort</a> <a id="3884" class="Symbol">(</a><a id="3885" href="Data.List.Base.html#4577" class="Function">length</a> <a id="3892" href="SMT.Script.Reflection.html#3848" class="Bound">Γᵣ′</a><a id="3895" class="Symbol">))</a>
    <a id="3902" class="Symbol">(</a><a id="3903" href="SMT.Script.Reflection.html#3903" class="Bound">Ξᵣ</a>  <a id="3907" class="Symbol">:</a> <a id="3909" href="SMT.Theory.Raw.Base.html#2638" class="Function">RawOutputCtxt</a><a id="3922" class="Symbol">)</a> <a id="3924" class="Symbol">(</a><a id="3925" href="SMT.Script.Reflection.html#3925" class="Bound">Ξ</a>  <a id="3928" class="Symbol">:</a> <a id="3930" href="Data.Vec.Base.html#959" class="Datatype">Vec</a> <a id="3934" href="SMT.Script.Base.html#4710" class="Datatype">OutputType</a> <a id="3945" class="Symbol">(</a><a id="3946" href="Data.List.Base.html#4577" class="Function">length</a> <a id="3953" href="SMT.Script.Reflection.html#3903" class="Bound">Ξᵣ</a><a id="3955" class="Symbol">))</a> <a id="3958" class="Symbol">→</a> <a id="3960" href="Agda.Primitive.html#326" class="Primitive">Set</a>
  <a id="3966" href="SMT.Script.Reflection.html#3767" class="Function Operator">Script[</a> <a id="3974" class="Symbol">_</a> <a id="3976" href="SMT.Script.Reflection.html#3767" class="Function Operator">↦</a> <a id="3978" href="SMT.Script.Reflection.html#3978" class="Bound">Γ</a> <a id="3980" href="SMT.Script.Reflection.html#3767" class="Function Operator">,</a> <a id="3982" class="Symbol">_</a> <a id="3984" href="SMT.Script.Reflection.html#3767" class="Function Operator">↦</a> <a id="3986" href="SMT.Script.Reflection.html#3986" class="Bound">Γ′</a> <a id="3989" href="SMT.Script.Reflection.html#3767" class="Function Operator">,</a> <a id="3991" class="Symbol">_</a> <a id="3993" href="SMT.Script.Reflection.html#3767" class="Function Operator">↦</a> <a id="3995" href="SMT.Script.Reflection.html#3995" class="Bound">Ξ</a> <a id="3997" href="SMT.Script.Reflection.html#3767" class="Function Operator">]</a> <a id="3999" class="Symbol">=</a> <a id="4001" href="SMT.Script.Base.html#9174" class="Datatype">Script</a> <a id="4008" class="Symbol">(</a><a id="4009" href="Data.Vec.Base.html#7399" class="Function">Vec.toList</a> <a id="4020" href="SMT.Script.Reflection.html#3978" class="Bound">Γ</a><a id="4021" class="Symbol">)</a> <a id="4023" class="Symbol">(</a><a id="4024" href="Data.Vec.Base.html#7399" class="Function">Vec.toList</a> <a id="4035" href="SMT.Script.Reflection.html#3986" class="Bound">Γ′</a><a id="4037" class="Symbol">)</a> <a id="4039" class="Symbol">(</a><a id="4040" href="Data.Vec.Base.html#7399" class="Function">Vec.toList</a> <a id="4051" href="SMT.Script.Reflection.html#3995" class="Bound">Ξ</a><a id="4052" class="Symbol">)</a>

  <a id="4057" href="SMT.Script.Reflection.html#4057" class="Function">checkRawScript</a> <a id="4072" class="Symbol">:</a> <a id="4074" class="Symbol">{</a><a id="4075" href="SMT.Script.Reflection.html#4075" class="Bound">Γᵣ</a> <a id="4078" href="SMT.Script.Reflection.html#4078" class="Bound">Γᵣ′</a> <a id="4082" class="Symbol">:</a> <a id="4084" href="SMT.Theory.Raw.Base.html#2684" class="Function">RawCtxt</a><a id="4091" class="Symbol">}</a> <a id="4093" class="Symbol">{</a><a id="4094" href="SMT.Script.Reflection.html#4094" class="Bound">Ξᵣ</a> <a id="4097" class="Symbol">:</a> <a id="4099" href="SMT.Theory.Raw.Base.html#2638" class="Function">RawOutputCtxt</a><a id="4112" class="Symbol">}</a>
    <a id="4118" class="Symbol">→</a> <a id="4120" class="Symbol">(</a><a id="4121" href="SMT.Script.Reflection.html#4121" class="Bound">Γ</a> <a id="4123" class="Symbol">:</a> <a id="4125" href="Data.Vec.Base.html#959" class="Datatype">Vec</a> <a id="4129" href="SMT.Theory.Base.html#1096" class="Function">Sort</a> <a id="4134" class="Symbol">(</a><a id="4135" href="Data.List.Base.html#4577" class="Function">length</a> <a id="4142" href="SMT.Script.Reflection.html#4075" class="Bound">Γᵣ</a><a id="4144" class="Symbol">))</a>
    <a id="4151" class="Symbol">→</a> <a id="4153" href="SMT.Theory.Raw.Base.html#3339" class="Datatype">RawScript</a> <a id="4163" href="SMT.Script.Reflection.html#4075" class="Bound">Γᵣ</a> <a id="4166" href="SMT.Script.Reflection.html#4078" class="Bound">Γᵣ′</a> <a id="4170" href="SMT.Script.Reflection.html#4094" class="Bound">Ξᵣ</a>
    <a id="4177" class="Symbol">→</a> <a id="4179" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="4185" class="Symbol">(</a><a id="4186" href="Data.Product.html#1806" class="Function">∃[</a> <a id="4189" href="SMT.Script.Reflection.html#4189" class="Bound">Γ′</a> <a id="4192" href="Data.Product.html#1806" class="Function">]</a> <a id="4194" href="Data.Product.html#1806" class="Function">∃[</a> <a id="4197" href="SMT.Script.Reflection.html#4197" class="Bound">Ξ</a> <a id="4199" href="Data.Product.html#1806" class="Function">]</a> <a id="4201" href="SMT.Script.Reflection.html#3767" class="Function Operator">Script[</a> <a id="4209" href="SMT.Script.Reflection.html#4075" class="Bound">Γᵣ</a> <a id="4212" href="SMT.Script.Reflection.html#3767" class="Function Operator">↦</a> <a id="4214" href="SMT.Script.Reflection.html#4121" class="Bound">Γ</a> <a id="4216" href="SMT.Script.Reflection.html#3767" class="Function Operator">,</a> <a id="4218" href="SMT.Script.Reflection.html#4078" class="Bound">Γᵣ′</a> <a id="4222" href="SMT.Script.Reflection.html#3767" class="Function Operator">↦</a> <a id="4224" href="SMT.Script.Reflection.html#4189" class="Bound">Γ′</a> <a id="4227" href="SMT.Script.Reflection.html#3767" class="Function Operator">,</a> <a id="4229" href="SMT.Script.Reflection.html#4094" class="Bound">Ξᵣ</a> <a id="4232" href="SMT.Script.Reflection.html#3767" class="Function Operator">↦</a> <a id="4234" href="SMT.Script.Reflection.html#4197" class="Bound">Ξ</a> <a id="4236" href="SMT.Script.Reflection.html#3767" class="Function Operator">]</a><a id="4237" class="Symbol">)</a>
  <a id="4241" href="SMT.Script.Reflection.html#4057" class="Function">checkRawScript</a> <a id="4256" class="Symbol">{</a><a id="4257" href="SMT.Script.Reflection.html#4257" class="Bound">Γᵣ</a><a id="4259" class="Symbol">}</a> <a id="4261" class="Symbol">{</a><a id="4262" class="DottedPattern Symbol">.</a><a id="4263" class="DottedPattern">Γᵣ</a><a id="4265" class="Symbol">}</a> <a id="4267" class="Symbol">{</a><a id="4268" class="DottedPattern Symbol">.</a><a id="4269" href="Agda.Builtin.List.html#185" class="DottedPattern InductiveConstructor">[]</a><a id="4271" class="Symbol">}</a> <a id="4273" href="SMT.Script.Reflection.html#4273" class="Bound">Γ</a> <a id="4275" href="SMT.Theory.Raw.Base.html#3381" class="InductiveConstructor">[]ᵣ</a> <a id="4279" class="Symbol">=</a>
    <a id="4285" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="4292" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="4294" href="SMT.Script.Reflection.html#4273" class="Bound">Γ</a> <a id="4296" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4298" href="Data.Vec.Base.html#995" class="InductiveConstructor">[]</a> <a id="4301" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4303" href="SMT.Script.Base.html#9237" class="InductiveConstructor">[]</a>
  <a id="4308" href="SMT.Script.Reflection.html#4057" class="Function">checkRawScript</a> <a id="4323" href="SMT.Script.Reflection.html#4323" class="Bound">Γ</a> <a id="4325" class="Symbol">(</a><a id="4326" href="SMT.Theory.Raw.Base.html#3118" class="InductiveConstructor">`set-logicᵣ</a> <a id="4338" href="SMT.Script.Reflection.html#4338" class="Bound">l</a> <a id="4340" href="SMT.Theory.Raw.Base.html#3417" class="InductiveConstructor Operator">∷ᵣ</a> <a id="4343" href="SMT.Script.Reflection.html#4343" class="Bound">scr</a><a id="4346" class="Symbol">)</a> <a id="4348" class="Symbol">=</a> <a id="4350" class="Keyword">do</a>
    <a id="4357" class="Symbol">(</a><a id="4358" href="SMT.Script.Reflection.html#4358" class="Bound">Γ′</a> <a id="4361" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4363" href="SMT.Script.Reflection.html#4363" class="Bound">Ξ</a> <a id="4365" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4367" href="SMT.Script.Reflection.html#4367" class="Bound">scr</a><a id="4370" class="Symbol">)</a> <a id="4372" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="4374" href="SMT.Script.Reflection.html#4057" class="Function">checkRawScript</a> <a id="4389" href="SMT.Script.Reflection.html#4323" class="Bound">Γ</a> <a id="4391" href="SMT.Script.Reflection.html#4343" class="Bound">scr</a>
    <a id="4399" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="4406" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="4408" href="SMT.Script.Reflection.html#4358" class="Bound">Γ′</a> <a id="4411" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4413" href="SMT.Script.Reflection.html#4363" class="Bound">Ξ</a> <a id="4415" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4417" class="Symbol">(</a><a id="4418" href="SMT.Script.Base.html#8826" class="InductiveConstructor">`set-logic</a> <a id="4429" href="SMT.Script.Reflection.html#4338" class="Bound">l</a> <a id="4431" href="SMT.Script.Base.html#9259" class="InductiveConstructor Operator">∷</a> <a id="4433" href="SMT.Script.Reflection.html#4367" class="Bound">scr</a><a id="4436" class="Symbol">)</a>
  <a id="4440" href="SMT.Script.Reflection.html#4057" class="Function">checkRawScript</a> <a id="4455" href="SMT.Script.Reflection.html#4455" class="Bound">Γ</a> <a id="4457" class="Symbol">(</a><a id="4458" href="SMT.Theory.Raw.Base.html#3162" class="InductiveConstructor">`declare-constᵣ</a> <a id="4474" class="Symbol">_</a> <a id="4476" href="SMT.Theory.Raw.Base.html#1032" class="InductiveConstructor">⋆</a> <a id="4478" href="SMT.Script.Base.html#9259" class="InductiveConstructor Operator">∷</a> <a id="4480" class="Symbol">_)</a> <a id="4483" class="Symbol">=</a> <a id="4485" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="4493" class="Comment">-- we never declare constants of type ⋆</a>
  <a id="4535" href="SMT.Script.Reflection.html#4057" class="Function">checkRawScript</a> <a id="4550" href="SMT.Script.Reflection.html#4550" class="Bound">Γ</a> <a id="4552" class="Symbol">(</a><a id="4553" href="SMT.Theory.Raw.Base.html#3162" class="InductiveConstructor">`declare-constᵣ</a> <a id="4569" href="SMT.Script.Reflection.html#4569" class="Bound">n</a> <a id="4571" class="Symbol">(</a><a id="4572" href="SMT.Theory.Raw.Base.html#1049" class="InductiveConstructor">TERM</a> <a id="4577" href="SMT.Script.Reflection.html#4577" class="Bound">σᵣ</a><a id="4579" class="Symbol">)</a> <a id="4581" href="SMT.Theory.Raw.Base.html#3417" class="InductiveConstructor Operator">∷ᵣ</a> <a id="4584" href="SMT.Script.Reflection.html#4584" class="Bound">scr</a><a id="4587" class="Symbol">)</a> <a id="4589" class="Symbol">=</a> <a id="4591" class="Keyword">do</a>
    <a id="4598" href="SMT.Script.Reflection.html#4598" class="Bound">σ</a> <a id="4600" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="4602" href="SMT.Theory.Reflectable.html#399" class="Field">checkSort</a> <a id="4612" href="SMT.Script.Reflection.html#4577" class="Bound">σᵣ</a>
    <a id="4619" href="SMT.Script.Reflection.html#4619" class="Bound">Γ′</a> <a id="4622" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4624" href="SMT.Script.Reflection.html#4624" class="Bound">Ξ</a> <a id="4626" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4628" href="SMT.Script.Reflection.html#4628" class="Bound">scr</a> <a id="4632" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="4634" href="SMT.Script.Reflection.html#4057" class="Function">checkRawScript</a> <a id="4649" class="Symbol">(</a><a id="4650" href="SMT.Script.Reflection.html#4598" class="Bound">σ</a> <a id="4652" href="Data.Vec.Base.html#1014" class="InductiveConstructor Operator">∷</a> <a id="4654" href="SMT.Script.Reflection.html#4550" class="Bound">Γ</a><a id="4655" class="Symbol">)</a> <a id="4657" href="SMT.Script.Reflection.html#4584" class="Bound">scr</a>
    <a id="4665" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="4672" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="4674" href="SMT.Script.Reflection.html#4619" class="Bound">Γ′</a> <a id="4677" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4679" href="SMT.Script.Reflection.html#4624" class="Bound">Ξ</a> <a id="4681" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4683" class="Symbol">(</a><a id="4684" href="SMT.Script.Base.html#8875" class="InductiveConstructor">`declare-const</a> <a id="4699" href="SMT.Script.Reflection.html#4569" class="Bound">n</a> <a id="4701" href="SMT.Script.Reflection.html#4598" class="Bound">σ</a> <a id="4703" href="SMT.Script.Base.html#9259" class="InductiveConstructor Operator">∷</a> <a id="4705" href="SMT.Script.Reflection.html#4628" class="Bound">scr</a><a id="4708" class="Symbol">)</a>
  <a id="4712" href="SMT.Script.Reflection.html#4057" class="Function">checkRawScript</a> <a id="4727" href="SMT.Script.Reflection.html#4727" class="Bound">Γ</a> <a id="4729" class="Symbol">(</a><a id="4730" href="SMT.Theory.Raw.Base.html#3210" class="InductiveConstructor">`assertᵣ</a> <a id="4739" href="SMT.Script.Reflection.html#4739" class="Bound">x</a> <a id="4741" href="SMT.Theory.Raw.Base.html#3417" class="InductiveConstructor Operator">∷ᵣ</a> <a id="4744" href="SMT.Script.Reflection.html#4744" class="Bound">scr</a><a id="4747" class="Symbol">)</a> <a id="4749" class="Symbol">=</a> <a id="4751" class="Keyword">do</a>
    <a id="4758" href="SMT.Script.Reflection.html#4758" class="Bound">x</a> <a id="4760" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="4762" class="Symbol">(</a><a id="4763" href="SMT.Script.Reflection.html#2425" class="Function">checkRawTerm</a> <a id="4776" class="Symbol">(</a><a id="4777" href="Data.Vec.Base.html#7399" class="Function">Vec.toList</a> <a id="4788" href="SMT.Script.Reflection.html#4727" class="Bound">Γ</a><a id="4789" class="Symbol">)</a> <a id="4791" href="SMT.Theory.Base.html#1169" class="Function">BOOL</a> <a id="4796" href="SMT.Script.Reflection.html#4739" class="Bound">x</a><a id="4797" class="Symbol">)</a>
    <a id="4803" class="Symbol">(</a><a id="4804" href="SMT.Script.Reflection.html#4804" class="Bound">Γ′</a> <a id="4807" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4809" href="SMT.Script.Reflection.html#4809" class="Bound">Ξ</a> <a id="4811" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4813" href="SMT.Script.Reflection.html#4813" class="Bound">scr</a><a id="4816" class="Symbol">)</a> <a id="4818" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="4820" class="Symbol">(</a><a id="4821" href="SMT.Script.Reflection.html#4057" class="Function">checkRawScript</a> <a id="4836" href="SMT.Script.Reflection.html#4727" class="Bound">Γ</a> <a id="4838" href="SMT.Script.Reflection.html#4744" class="Bound">scr</a><a id="4841" class="Symbol">)</a>
    <a id="4847" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="4854" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="4856" href="SMT.Script.Reflection.html#4804" class="Bound">Γ′</a> <a id="4859" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4861" href="SMT.Script.Reflection.html#4809" class="Bound">Ξ</a> <a id="4863" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4865" class="Symbol">(</a><a id="4866" href="SMT.Script.Base.html#8942" class="InductiveConstructor">`assert</a> <a id="4874" href="SMT.Script.Reflection.html#4758" class="Bound">x</a> <a id="4876" href="SMT.Script.Base.html#9259" class="InductiveConstructor Operator">∷</a> <a id="4878" href="SMT.Script.Reflection.html#4813" class="Bound">scr</a><a id="4881" class="Symbol">)</a>
  <a id="4885" href="SMT.Script.Reflection.html#4057" class="Function">checkRawScript</a> <a id="4900" href="SMT.Script.Reflection.html#4900" class="Bound">Γ</a> <a id="4902" class="Symbol">(</a><a id="4903" href="SMT.Theory.Raw.Base.html#3251" class="InductiveConstructor">`check-satᵣ</a> <a id="4915" href="SMT.Theory.Raw.Base.html#3417" class="InductiveConstructor Operator">∷ᵣ</a> <a id="4918" href="SMT.Script.Reflection.html#4918" class="Bound">scr</a><a id="4921" class="Symbol">)</a> <a id="4923" class="Symbol">=</a> <a id="4925" class="Keyword">do</a>
    <a id="4932" class="Symbol">(</a><a id="4933" href="SMT.Script.Reflection.html#4933" class="Bound">Γ′</a> <a id="4936" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4938" href="SMT.Script.Reflection.html#4938" class="Bound">Ξ</a> <a id="4940" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4942" href="SMT.Script.Reflection.html#4942" class="Bound">scr</a><a id="4945" class="Symbol">)</a> <a id="4947" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="4949" href="SMT.Script.Reflection.html#4057" class="Function">checkRawScript</a> <a id="4964" href="SMT.Script.Reflection.html#4900" class="Bound">Γ</a> <a id="4966" href="SMT.Script.Reflection.html#4918" class="Bound">scr</a>
    <a id="4974" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="4981" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="4983" href="SMT.Script.Reflection.html#4933" class="Bound">Γ′</a> <a id="4986" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4988" href="SMT.Script.Base.html#4735" class="InductiveConstructor">SAT</a> <a id="4992" href="Data.Vec.Base.html#1014" class="InductiveConstructor Operator">∷</a> <a id="4994" href="SMT.Script.Reflection.html#4938" class="Bound">Ξ</a> <a id="4996" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4998" class="Symbol">(</a><a id="4999" href="SMT.Script.Base.html#8991" class="InductiveConstructor">`check-sat</a> <a id="5010" href="SMT.Script.Base.html#9259" class="InductiveConstructor Operator">∷</a> <a id="5012" href="SMT.Script.Reflection.html#4942" class="Bound">scr</a><a id="5015" class="Symbol">)</a>
  <a id="5019" href="SMT.Script.Reflection.html#4057" class="Function">checkRawScript</a> <a id="5034" href="SMT.Script.Reflection.html#5034" class="Bound">Γ</a> <a id="5036" class="Symbol">(</a><a id="5037" href="SMT.Theory.Raw.Base.html#3295" class="InductiveConstructor">`get-modelᵣ</a> <a id="5049" href="SMT.Theory.Raw.Base.html#3417" class="InductiveConstructor Operator">∷ᵣ</a> <a id="5052" href="SMT.Script.Reflection.html#5052" class="Bound">scr</a><a id="5055" class="Symbol">)</a> <a id="5057" class="Symbol">=</a> <a id="5059" class="Keyword">do</a>
    <a id="5066" class="Symbol">(</a><a id="5067" href="SMT.Script.Reflection.html#5067" class="Bound">Γ′</a> <a id="5070" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5072" href="SMT.Script.Reflection.html#5072" class="Bound">Ξ</a> <a id="5074" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5076" href="SMT.Script.Reflection.html#5076" class="Bound">scr</a><a id="5079" class="Symbol">)</a> <a id="5081" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="5083" href="SMT.Script.Reflection.html#4057" class="Function">checkRawScript</a> <a id="5098" href="SMT.Script.Reflection.html#5034" class="Bound">Γ</a> <a id="5100" href="SMT.Script.Reflection.html#5052" class="Bound">scr</a>
    <a id="5108" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="5115" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="5117" href="SMT.Script.Reflection.html#5067" class="Bound">Γ′</a> <a id="5120" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5122" href="SMT.Script.Base.html#4756" class="InductiveConstructor">MODEL</a> <a id="5128" class="Symbol">(</a><a id="5129" href="Data.Vec.Base.html#7399" class="Function">Vec.toList</a> <a id="5140" href="SMT.Script.Reflection.html#5034" class="Bound">Γ</a><a id="5141" class="Symbol">)</a> <a id="5143" href="Data.Vec.Base.html#1014" class="InductiveConstructor Operator">∷</a> <a id="5145" href="SMT.Script.Reflection.html#5072" class="Bound">Ξ</a> <a id="5147" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5149" class="Symbol">(</a><a id="5150" href="SMT.Script.Base.html#9034" class="InductiveConstructor">`get-model</a> <a id="5161" href="SMT.Script.Base.html#9259" class="InductiveConstructor Operator">∷</a> <a id="5163" href="SMT.Script.Reflection.html#5076" class="Bound">scr</a><a id="5166" class="Symbol">)</a>

<a id="5169" class="Keyword">module</a> <a id="5176" href="SMT.Script.Reflection.html#5176" class="Module">_</a> <a id="5178" class="Keyword">where</a>

  <a id="5187" class="Keyword">open</a> <a id="5192" class="Keyword">import</a> <a id="5199" href="SMT.Theory.Raw.Reflection.html" class="Module">SMT.Theory.Raw.Reflection</a>
  <a id="5227" class="Keyword">import</a> <a id="5234" href="Reflection.TypeChecking.Monad.Categorical.html" class="Module">Reflection.TypeChecking.Monad.Categorical</a> <a id="5276" class="Symbol">as</a> <a id="5279" class="Module">TC</a>

  <a id="5285" class="Keyword">private</a>
    <a id="5297" class="Keyword">open</a> <a id="5302" class="Keyword">module</a> <a id="TCMonad"></a><a id="5309" href="SMT.Script.Reflection.html#5309" class="Module">TCMonad</a> <a id="5317" class="Symbol">{</a><a id="5318" href="SMT.Script.Reflection.html#5318" class="Bound">ℓ</a><a id="5319" class="Symbol">}</a> <a id="5321" class="Symbol">=</a> <a id="5323" href="Category.Monad.html#832" class="Module">Category.Monad.RawMonad</a> <a id="5347" class="Symbol">{</a><a id="5348" href="SMT.Script.Reflection.html#5318" class="Bound">ℓ</a><a id="5349" class="Symbol">}</a> <a id="5351" href="Reflection.TypeChecking.Monad.Categorical.html#1061" class="Function">TC.monad</a> <a id="5360" class="Keyword">renaming</a> <a id="5369" class="Symbol">(</a><a id="5370" href="Category.Applicative.Indexed.html#1034" class="Function Operator">_⊛_</a> <a id="5374" class="Symbol">to</a> <a id="5377" href="SMT.Script.Reflection.html#5377" class="Function Operator">_&lt;*&gt;_</a><a id="5382" class="Symbol">)</a>

  <a id="5387" href="SMT.Script.Reflection.html#5387" class="Function">reflectToScript</a> <a id="5403" class="Symbol">:</a> <a id="5405" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Rfl.Term</a> <a id="5414" class="Symbol">→</a> <a id="5416" href="Agda.Builtin.Reflection.html#7500" class="Postulate">Rfl.TC</a> <a id="5423" class="Symbol">(</a><a id="5424" href="Data.Product.html#1806" class="Function">∃[</a> <a id="5427" href="SMT.Script.Reflection.html#5427" class="Bound">Γ</a> <a id="5429" href="Data.Product.html#1806" class="Function">]</a> <a id="5431" href="SMT.Script.Base.html#9174" class="Datatype">Script</a> <a id="5438" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="5441" href="SMT.Script.Reflection.html#5427" class="Bound">Γ</a> <a id="5443" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="5445" class="Symbol">)</a>
  <a id="5449" href="SMT.Script.Reflection.html#5387" class="Function">reflectToScript</a> <a id="5465" href="SMT.Script.Reflection.html#5465" class="Bound">t</a> <a id="5467" class="Symbol">=</a> <a id="5469" class="Keyword">do</a>
    <a id="5476" class="Symbol">(</a><a id="5477" href="SMT.Script.Reflection.html#5477" class="Bound">Γᵣ</a> <a id="5480" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5482" href="SMT.Script.Reflection.html#5482" class="Bound">scrᵣ</a><a id="5486" class="Symbol">)</a> <a id="5488" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="5490" href="SMT.Theory.Raw.Reflection.html#7532" class="Function">reflectToRawScript</a> <a id="5509" href="SMT.Script.Reflection.html#5465" class="Bound">t</a>
    <a id="5515" href="Function.Base.html#4121" class="Function Operator">case</a> <a id="5520" href="SMT.Script.Reflection.html#4057" class="Function">checkRawScript</a> <a id="5535" href="Data.Vec.Base.html#995" class="InductiveConstructor">[]</a> <a id="5538" href="SMT.Script.Reflection.html#5482" class="Bound">scrᵣ</a> <a id="5543" href="Function.Base.html#4121" class="Function Operator">of</a> <a id="5546" class="Symbol">λ</a> <a id="5548" class="Keyword">where</a>
      <a id="5560" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="5568" class="Symbol">→</a> <a id="5570" href="Reflection.TypeChecking.Format.html#2592" class="Function">Rfl.typeErrorFmt</a> <a id="5587" class="String">&quot;Ill-typed script:\n%s&quot;</a> <a id="5611" class="Symbol">(</a><a id="5612" href="SMT.Theory.Raw.Base.html#3551" class="Function">showRawScript</a> <a id="5626" href="SMT.Script.Reflection.html#5482" class="Bound">scrᵣ</a><a id="5630" class="Symbol">)</a>
      <a id="5638" class="Symbol">(</a><a id="5639" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="5644" class="Symbol">(</a><a id="5645" href="SMT.Script.Reflection.html#5645" class="Bound">Γ</a> <a id="5647" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5649" href="Data.Vec.Base.html#995" class="InductiveConstructor">[]</a> <a id="5652" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5654" href="SMT.Script.Reflection.html#5654" class="Bound">scr</a><a id="5657" class="Symbol">))</a> <a id="5660" class="Symbol">→</a> <a id="5662" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="5669" class="Symbol">(</a><a id="5670" href="Data.Vec.Base.html#7399" class="Function">Vec.toList</a> <a id="5681" href="SMT.Script.Reflection.html#5645" class="Bound">Γ</a> <a id="5683" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5685" href="SMT.Script.Reflection.html#5654" class="Bound">scr</a><a id="5688" class="Symbol">)</a>
</pre></body></html>