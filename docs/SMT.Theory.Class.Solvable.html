<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SMT.Theory.Class.Solvable</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--guardedness</a> <a id="27" class="Symbol">#-}</a>

<a id="32" class="Comment">--------------------------------------------------------------------------------</a>
<a id="113" class="Comment">-- Schmitty the Solver</a>
<a id="136" class="Comment">--</a>
<a id="139" class="Comment">-- Defines the `Solvable` class, which is the top-level interface to an SMT</a>
<a id="215" class="Comment">-- solver. It provides &quot;toSMTLIBWithOutputParser&quot;, which takes a SMT-LIB script</a>
<a id="295" class="Comment">-- embedded in Schmitty and turns it into an actually SMT-LIB script coupled</a>
<a id="372" class="Comment">-- with a correspoinding parser for the outputs.</a>
<a id="421" class="Comment">--</a>
<a id="424" class="Comment">-- There are two ways to make a theory solvable:</a>
<a id="473" class="Comment">--</a>
<a id="476" class="Comment">-- - For a theory natively supported by the SMT-LIB standard (which we call</a>
<a id="552" class="Comment">--   concrete theory), we can implement `Solvable` directly by calling</a>
<a id="623" class="Comment">--   &quot;makeSolve&quot; and providing a &quot;Printable&quot; and a &quot;Parsable&quot; instance.</a>
<a id="695" class="Comment">--</a>
<a id="698" class="Comment">-- - For a theory not natively supported by the SMT-LIB standard (which we call</a>
<a id="778" class="Comment">--   virtual theory), we can implement `Solvable` by translating it to an</a>
<a id="852" class="Comment">--   existing solvable theory using `Translation` and `makeVirtualTheory`.</a>
<a id="927" class="Comment">--------------------------------------------------------------------------------</a>

<a id="1009" class="Keyword">module</a> <a id="1016" href="SMT.Theory.Class.Solvable.html" class="Module">SMT.Theory.Class.Solvable</a> <a id="1042" class="Keyword">where</a>

<a id="1049" class="Keyword">open</a> <a id="1054" class="Keyword">import</a> <a id="1061" href="Data.Product.html" class="Module">Data.Product</a> <a id="1074" class="Symbol">as</a> <a id="1077" class="Module">Prod</a> <a id="1082" class="Keyword">using</a> <a id="1088" class="Symbol">(</a><a id="1089" href="Data.Product.html#1167" class="Function Operator">_×_</a><a id="1092" class="Symbol">;</a> <a id="1094" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="1097" class="Symbol">;</a> <a id="1099" href="Data.Product.html#2675" class="Function">map₂</a><a id="1103" class="Symbol">)</a>
<a id="1105" class="Keyword">open</a> <a id="1110" class="Keyword">import</a> <a id="1117" href="Data.List.html" class="Module">Data.List</a> <a id="1127" class="Symbol">as</a> <a id="1130" class="Module">List</a> <a id="1135" class="Keyword">using</a> <a id="1141" class="Symbol">(</a><a id="1142" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="1146" class="Symbol">;</a> <a id="1148" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="1151" class="Symbol">;</a> <a id="1153" href="Data.List.Base.html#10383" class="InductiveConstructor">[]</a><a id="1155" class="Symbol">)</a>
<a id="1157" class="Keyword">open</a> <a id="1162" class="Keyword">import</a> <a id="1169" href="Data.String.html" class="Module">Data.String</a> <a id="1181" class="Keyword">using</a> <a id="1187" class="Symbol">(</a><a id="1188" href="Agda.Builtin.String.html#336" class="Postulate">String</a><a id="1194" class="Symbol">)</a>
<a id="1196" class="Keyword">open</a> <a id="1201" class="Keyword">import</a> <a id="1208" href="Data.Sum.html" class="Module">Data.Sum</a> <a id="1217" class="Symbol">as</a> <a id="1220" class="Module">Sum</a> <a id="1224" class="Keyword">using</a> <a id="1230" class="Symbol">(</a><a id="1231" href="Data.Sum.Base.html#734" class="Datatype Operator">_⊎_</a><a id="1234" class="Symbol">;</a> <a id="1236" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a><a id="1240" class="Symbol">;</a> <a id="1242" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a><a id="1246" class="Symbol">;</a> <a id="1248" href="Data.Sum.Base.html#1089" class="Function Operator">[_,_]′</a><a id="1254" class="Symbol">)</a>
<a id="1256" class="Keyword">open</a> <a id="1261" class="Keyword">import</a> <a id="1268" href="Function.html" class="Module">Function</a> <a id="1277" class="Keyword">using</a> <a id="1283" class="Symbol">(</a><a id="1284" href="Function.Base.html#1031" class="Function Operator">_∘_</a><a id="1287" class="Symbol">)</a>
<a id="1289" class="Keyword">open</a> <a id="1294" class="Keyword">import</a> <a id="1301" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1339" class="Symbol">as</a> <a id="1342" class="Module">Eq</a> <a id="1345" class="Keyword">using</a> <a id="1351" class="Symbol">(</a><a id="1352" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="1355" class="Symbol">;</a> <a id="1357" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="1361" class="Symbol">;</a> <a id="1363" href="Relation.Binary.PropositionalEquality.Core.html#1780" class="Function">subst</a><a id="1368" class="Symbol">)</a>
<a id="1370" class="Keyword">import</a> <a id="1377" href="SMT.Script.Base.html" class="Module">SMT.Script.Base</a>
<a id="1393" class="Keyword">import</a> <a id="1400" href="SMT.Script.Show.html" class="Module">SMT.Script.Show</a>
<a id="1416" class="Keyword">open</a> <a id="1421" class="Keyword">import</a> <a id="1428" href="SMT.Theory.Base.html" class="Module">SMT.Theory.Base</a>
<a id="1444" class="Keyword">open</a> <a id="1449" class="Keyword">import</a> <a id="1456" href="SMT.Theory.Class.Parsable.html" class="Module">SMT.Theory.Class.Parsable</a>
<a id="1482" class="Keyword">open</a> <a id="1487" class="Keyword">import</a> <a id="1494" href="SMT.Theory.Class.Printable.html" class="Module">SMT.Theory.Class.Printable</a>
<a id="1521" class="Keyword">open</a> <a id="1526" class="Keyword">import</a> <a id="1533" href="Text.Parser.String.html" class="Module">Text.Parser.String</a> <a id="1552" class="Keyword">using</a> <a id="1558" class="Symbol">(</a><a id="1559" href="Relation.Unary.html#3359" class="Function">IUniversal</a><a id="1569" class="Symbol">;</a> <a id="1571" href="Text.Parser.html#2710" class="Function">Parser</a><a id="1577" class="Symbol">;</a> <a id="1579" href="Text.Parser.html#2812" class="Function">runParser</a><a id="1588" class="Symbol">;</a> <a id="1590" href="Text.Parser.Position.html#380" class="Record">Position</a><a id="1598" class="Symbol">)</a>


<a id="InterpError"></a><a id="1602" href="SMT.Theory.Class.Solvable.html#1602" class="Function">InterpError</a> <a id="1614" class="Symbol">:</a> <a id="1616" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="1620" href="SMT.Theory.Class.Solvable.html#1602" class="Function">InterpError</a> <a id="1632" class="Symbol">=</a> <a id="1634" href="Agda.Builtin.String.html#336" class="Postulate">String</a>

<a id="1642" class="Keyword">data</a> <a id="SMTError"></a><a id="1647" href="SMT.Theory.Class.Solvable.html#1647" class="Datatype">SMTError</a> <a id="1656" class="Symbol">:</a> <a id="1658" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="1662" class="Keyword">where</a>
  <a id="SMTError.parseError"></a><a id="1670" href="SMT.Theory.Class.Solvable.html#1670" class="InductiveConstructor">parseError</a>  <a id="1682" class="Symbol">:</a> <a id="1684" href="Text.Parser.Position.html#380" class="Record">Position</a> <a id="1693" class="Symbol">→</a> <a id="1695" href="SMT.Theory.Class.Solvable.html#1647" class="Datatype">SMTError</a>
  <a id="SMTError.interpError"></a><a id="1706" href="SMT.Theory.Class.Solvable.html#1706" class="InductiveConstructor">interpError</a> <a id="1718" class="Symbol">:</a> <a id="1720" href="SMT.Theory.Class.Solvable.html#1602" class="Function">InterpError</a> <a id="1732" class="Symbol">→</a> <a id="1734" href="SMT.Theory.Class.Solvable.html#1647" class="Datatype">SMTError</a>


<a id="1745" class="Keyword">record</a> <a id="Solvable"></a><a id="1752" href="SMT.Theory.Class.Solvable.html#1752" class="Record">Solvable</a> <a id="1761" class="Symbol">(</a><a id="1762" href="SMT.Theory.Class.Solvable.html#1762" class="Bound">theory</a> <a id="1769" class="Symbol">:</a> <a id="1771" href="SMT.Theory.Base.html#1730" class="Record">Theory</a><a id="1777" class="Symbol">)</a> <a id="1779" class="Symbol">:</a> <a id="1781" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="1785" class="Keyword">where</a>
  <a id="1793" class="Keyword">open</a> <a id="1798" href="SMT.Script.Base.html" class="Module">SMT.Script.Base</a> <a id="1814" href="SMT.Theory.Class.Solvable.html#1762" class="Bound">theory</a>
  <a id="1823" class="Keyword">field</a>
    <a id="1833" class="Comment">-- rename to toSMTLIBWithOutputParser</a>
    <a id="Solvable.toSMTLIBWithOutputParser"></a><a id="1875" href="SMT.Theory.Class.Solvable.html#1875" class="Field">toSMTLIBWithOutputParser</a> <a id="1900" class="Symbol">:</a> <a id="1902" class="Symbol">∀</a> <a id="1904" class="Symbol">{</a><a id="1905" href="SMT.Theory.Class.Solvable.html#1905" class="Bound">Γ</a><a id="1906" class="Symbol">}</a> <a id="1908" class="Symbol">{</a><a id="1909" href="SMT.Theory.Class.Solvable.html#1909" class="Bound">Ξ</a><a id="1910" class="Symbol">}</a>
             <a id="1925" class="Symbol">→</a> <a id="1927" href="SMT.Script.Base.html#9148" class="Datatype">Script</a> <a id="1934" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="1937" href="SMT.Theory.Class.Solvable.html#1905" class="Bound">Γ</a> <a id="1939" href="SMT.Theory.Class.Solvable.html#1909" class="Bound">Ξ</a> <a id="1941" class="Symbol">→</a> <a id="1943" href="Agda.Builtin.String.html#336" class="Postulate">String</a> <a id="1950" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="1952" class="Symbol">(</a><a id="1953" href="Agda.Builtin.String.html#336" class="Postulate">String</a> <a id="1960" class="Symbol">→</a> <a id="1962" href="SMT.Theory.Class.Solvable.html#1647" class="Datatype">SMTError</a> <a id="1971" href="Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="1973" href="SMT.Script.Base.html#7142" class="Datatype">Outputs</a> <a id="1981" href="SMT.Theory.Class.Solvable.html#1909" class="Bound">Ξ</a><a id="1982" class="Symbol">)</a>


<a id="1986" class="Comment">---------------------</a>
<a id="2008" class="Comment">-- Concrete Theory --</a>
<a id="2030" class="Comment">---------------------</a>

<a id="makeSolvable"></a><a id="2053" href="SMT.Theory.Class.Solvable.html#2053" class="Function">makeSolvable</a> <a id="2066" class="Symbol">:</a> <a id="2068" class="Symbol">(</a><a id="2069" href="SMT.Theory.Class.Solvable.html#2069" class="Bound">theory</a> <a id="2076" class="Symbol">:</a> <a id="2078" href="SMT.Theory.Base.html#1730" class="Record">Theory</a><a id="2084" class="Symbol">)</a> <a id="2086" class="Symbol">→</a> <a id="2088" class="Symbol">{{</a><a id="2090" href="SMT.Theory.Class.Printable.html#664" class="Record">Printable</a> <a id="2100" href="SMT.Theory.Class.Solvable.html#2069" class="Bound">theory</a><a id="2106" class="Symbol">}}</a> <a id="2109" class="Symbol">→</a> <a id="2111" class="Symbol">{{</a><a id="2113" href="SMT.Theory.Class.Parsable.html#452" class="Record">Parsable</a> <a id="2122" href="SMT.Theory.Class.Solvable.html#2069" class="Bound">theory</a><a id="2128" class="Symbol">}}</a> <a id="2131" class="Symbol">→</a> <a id="2133" href="SMT.Theory.Class.Solvable.html#1752" class="Record">Solvable</a> <a id="2142" href="SMT.Theory.Class.Solvable.html#2069" class="Bound">theory</a>
<a id="2149" href="SMT.Theory.Class.Solvable.html#2053" class="Function">makeSolvable</a> <a id="2162" href="SMT.Theory.Class.Solvable.html#2162" class="Bound">theory</a> <a id="2169" class="Symbol">=</a> <a id="2171" class="Keyword">record</a> <a id="2178" class="Symbol">{</a>
    <a id="2184" href="SMT.Theory.Class.Solvable.html#1875" class="Field">toSMTLIBWithOutputParser</a> <a id="2209" class="Symbol">=</a> <a id="2211" href="Data.Product.html#2675" class="Function">Prod.map₂</a> <a id="2221" class="Symbol">(λ</a> <a id="2224" href="SMT.Theory.Class.Solvable.html#2224" class="Bound">p</a> <a id="2226" href="SMT.Theory.Class.Solvable.html#2226" class="Bound">s</a> <a id="2228" class="Symbol">→</a> <a id="2230" href="Data.Sum.Base.html#1440" class="Function">Sum.map₁</a> <a id="2239" href="SMT.Theory.Class.Solvable.html#1670" class="InductiveConstructor">parseError</a> <a id="2250" class="Symbol">(</a><a id="2251" href="SMT.Theory.Class.Solvable.html#2224" class="Bound">p</a> <a id="2253" href="SMT.Theory.Class.Solvable.html#2226" class="Bound">s</a><a id="2254" class="Symbol">))</a> <a id="2257" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="2259" href="SMT.Script.Show.html#10425" class="Function">showScript</a>
  <a id="2272" class="Symbol">}</a>
  <a id="2276" class="Keyword">where</a>
    <a id="2286" class="Keyword">open</a> <a id="2291" href="SMT.Script.Show.html" class="Module">SMT.Script.Show</a> <a id="2307" href="SMT.Theory.Class.Solvable.html#2162" class="Bound">theory</a>


<a id="2316" class="Comment">--------------------</a>
<a id="2337" class="Comment">-- Virtual Theory --</a>
<a id="2358" class="Comment">--------------------</a>

<a id="2380" class="Keyword">record</a> <a id="SortTranslation"></a><a id="2387" href="SMT.Theory.Class.Solvable.html#2387" class="Record">SortTranslation</a> <a id="2403" class="Symbol">(</a><a id="2404" href="SMT.Theory.Class.Solvable.html#2404" class="Bound">virtual</a> <a id="2412" class="Symbol">:</a> <a id="2414" href="SMT.Theory.Base.html#1730" class="Record">Theory</a><a id="2420" class="Symbol">)</a> <a id="2422" class="Symbol">(</a><a id="2423" href="SMT.Theory.Class.Solvable.html#2423" class="Bound">concrete</a> <a id="2432" class="Symbol">:</a> <a id="2434" href="SMT.Theory.Base.html#1730" class="Record">Theory</a><a id="2440" class="Symbol">)</a> <a id="2442" class="Symbol">:</a> <a id="2444" href="Agda.Primitive.html#326" class="Primitive">Set₁</a> <a id="2449" class="Keyword">where</a>
  <a id="2457" class="Keyword">private</a>
    <a id="2469" class="Keyword">module</a> <a id="SortTranslation.VT"></a><a id="2476" href="SMT.Theory.Class.Solvable.html#2476" class="Module">VT</a> <a id="2479" class="Symbol">=</a> <a id="2481" href="SMT.Theory.Base.html#1730" class="Module">Theory</a> <a id="2488" href="SMT.Theory.Class.Solvable.html#2404" class="Bound">virtual</a>
    <a id="2500" class="Keyword">module</a> <a id="SortTranslation.VS"></a><a id="2507" href="SMT.Theory.Class.Solvable.html#2507" class="Module">VS</a> <a id="2510" class="Symbol">=</a> <a id="2512" href="SMT.Script.Base.html" class="Module">SMT.Script.Base</a> <a id="2528" href="SMT.Theory.Class.Solvable.html#2404" class="Bound">virtual</a>
    <a id="2540" class="Keyword">module</a> <a id="SortTranslation.CT"></a><a id="2547" href="SMT.Theory.Class.Solvable.html#2547" class="Module">CT</a> <a id="2550" class="Symbol">=</a> <a id="2552" href="SMT.Theory.Base.html#1730" class="Module">Theory</a> <a id="2559" href="SMT.Theory.Class.Solvable.html#2423" class="Bound">concrete</a>
    <a id="2572" class="Keyword">module</a> <a id="SortTranslation.CS"></a><a id="2579" href="SMT.Theory.Class.Solvable.html#2579" class="Module">CS</a> <a id="2582" class="Symbol">=</a> <a id="2584" href="SMT.Script.Base.html" class="Module">SMT.Script.Base</a> <a id="2600" href="SMT.Theory.Class.Solvable.html#2423" class="Bound">concrete</a>

  <a id="2612" class="Keyword">field</a>
    <a id="SortTranslation.compileSort"></a><a id="2622" href="SMT.Theory.Class.Solvable.html#2622" class="Field">compileSort</a>       <a id="2640" class="Symbol">:</a> <a id="2642" href="SMT.Theory.Base.html#1762" class="Function">VT.Sort</a> <a id="2650" class="Symbol">→</a> <a id="2652" href="SMT.Theory.Base.html#1762" class="Function">CT.Sort</a>
    <a id="SortTranslation.interpSort"></a><a id="2664" href="SMT.Theory.Class.Solvable.html#2664" class="Field">interpSort</a>        <a id="2682" class="Symbol">:</a> <a id="2684" href="SMT.Theory.Base.html#1762" class="Function">CT.Sort</a> <a id="2692" class="Symbol">→</a> <a id="2694" href="SMT.Theory.Base.html#1762" class="Function">VT.Sort</a>
    <a id="SortTranslation.interpCompileSort"></a><a id="2706" href="SMT.Theory.Class.Solvable.html#2706" class="Field">interpCompileSort</a> <a id="2724" class="Symbol">:</a> <a id="2726" class="Symbol">∀</a> <a id="2728" href="SMT.Theory.Class.Solvable.html#2728" class="Bound">σ</a> <a id="2730" class="Symbol">→</a> <a id="2732" href="SMT.Theory.Class.Solvable.html#2664" class="Field">interpSort</a> <a id="2743" class="Symbol">(</a><a id="2744" href="SMT.Theory.Class.Solvable.html#2622" class="Field">compileSort</a> <a id="2756" href="SMT.Theory.Class.Solvable.html#2728" class="Bound">σ</a><a id="2757" class="Symbol">)</a> <a id="2759" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2761" href="SMT.Theory.Class.Solvable.html#2728" class="Bound">σ</a>

  <a id="SortTranslation.compileCtxt"></a><a id="2766" href="SMT.Theory.Class.Solvable.html#2766" class="Function">compileCtxt</a> <a id="2778" class="Symbol">:</a> <a id="2780" href="SMT.Script.Base.html#2388" class="Function">VS.Ctxt</a> <a id="2788" class="Symbol">→</a> <a id="2790" href="SMT.Script.Base.html#2388" class="Function">CS.Ctxt</a>
  <a id="2800" href="SMT.Theory.Class.Solvable.html#2766" class="Function">compileCtxt</a> <a id="2812" class="Symbol">=</a> <a id="2814" href="Data.List.Base.html#1544" class="Function">List.map</a> <a id="2823" href="SMT.Theory.Class.Solvable.html#2622" class="Field">compileSort</a>

  <a id="SortTranslation.compileOutputType"></a><a id="2838" href="SMT.Theory.Class.Solvable.html#2838" class="Function">compileOutputType</a> <a id="2856" class="Symbol">:</a> <a id="2858" href="SMT.Script.Base.html#5523" class="Datatype">VS.OutputType</a> <a id="2872" class="Symbol">→</a> <a id="2874" href="SMT.Script.Base.html#5523" class="Datatype">CS.OutputType</a>
  <a id="2890" href="SMT.Theory.Class.Solvable.html#2838" class="Function">compileOutputType</a> <a id="2908" href="SMT.Script.Base.html#5548" class="InductiveConstructor">VS.SAT</a>       <a id="2921" class="Symbol">=</a> <a id="2923" href="SMT.Script.Base.html#5548" class="InductiveConstructor">CS.SAT</a>
  <a id="2932" href="SMT.Theory.Class.Solvable.html#2838" class="Function">compileOutputType</a> <a id="2950" class="Symbol">(</a><a id="2951" href="SMT.Script.Base.html#5569" class="InductiveConstructor">VS.MODEL</a> <a id="2960" href="SMT.Theory.Class.Solvable.html#2960" class="Bound">Γ</a><a id="2961" class="Symbol">)</a> <a id="2963" class="Symbol">=</a> <a id="2965" href="SMT.Script.Base.html#5569" class="InductiveConstructor">CS.MODEL</a> <a id="2974" class="Symbol">(</a><a id="2975" href="SMT.Theory.Class.Solvable.html#2766" class="Function">compileCtxt</a> <a id="2987" href="SMT.Theory.Class.Solvable.html#2960" class="Bound">Γ</a><a id="2988" class="Symbol">)</a>

  <a id="SortTranslation.compileOutputCtxt"></a><a id="2993" href="SMT.Theory.Class.Solvable.html#2993" class="Function">compileOutputCtxt</a> <a id="3011" class="Symbol">:</a> <a id="3013" href="SMT.Script.Base.html#5617" class="Function">VS.OutputCtxt</a> <a id="3027" class="Symbol">→</a> <a id="3029" href="SMT.Script.Base.html#5617" class="Function">CS.OutputCtxt</a>
  <a id="3045" href="SMT.Theory.Class.Solvable.html#2993" class="Function">compileOutputCtxt</a> <a id="3063" class="Symbol">=</a> <a id="3065" href="Data.List.Base.html#1544" class="Function">List.map</a> <a id="3074" href="SMT.Theory.Class.Solvable.html#2838" class="Function">compileOutputType</a>

  <a id="SortTranslation.interpCtxt"></a><a id="3095" href="SMT.Theory.Class.Solvable.html#3095" class="Function">interpCtxt</a> <a id="3106" class="Symbol">:</a> <a id="3108" href="SMT.Script.Base.html#2388" class="Function">CS.Ctxt</a> <a id="3116" class="Symbol">→</a> <a id="3118" href="SMT.Script.Base.html#2388" class="Function">VS.Ctxt</a>
  <a id="3128" href="SMT.Theory.Class.Solvable.html#3095" class="Function">interpCtxt</a> <a id="3139" class="Symbol">=</a> <a id="3141" href="Data.List.Base.html#1544" class="Function">List.map</a> <a id="3150" href="SMT.Theory.Class.Solvable.html#2664" class="Field">interpSort</a>

  <a id="SortTranslation.interpOutputType"></a><a id="3164" href="SMT.Theory.Class.Solvable.html#3164" class="Function">interpOutputType</a> <a id="3181" class="Symbol">:</a> <a id="3183" href="SMT.Script.Base.html#5523" class="Datatype">CS.OutputType</a> <a id="3197" class="Symbol">→</a> <a id="3199" href="SMT.Script.Base.html#5523" class="Datatype">VS.OutputType</a>
  <a id="3215" href="SMT.Theory.Class.Solvable.html#3164" class="Function">interpOutputType</a> <a id="3232" href="SMT.Script.Base.html#5548" class="InductiveConstructor">CS.SAT</a>       <a id="3245" class="Symbol">=</a> <a id="3247" href="SMT.Script.Base.html#5548" class="InductiveConstructor">VS.SAT</a>
  <a id="3256" href="SMT.Theory.Class.Solvable.html#3164" class="Function">interpOutputType</a> <a id="3273" class="Symbol">(</a><a id="3274" href="SMT.Script.Base.html#5569" class="InductiveConstructor">CS.MODEL</a> <a id="3283" href="SMT.Theory.Class.Solvable.html#3283" class="Bound">Γ</a><a id="3284" class="Symbol">)</a> <a id="3286" class="Symbol">=</a> <a id="3288" href="SMT.Script.Base.html#5569" class="InductiveConstructor">VS.MODEL</a> <a id="3297" class="Symbol">(</a><a id="3298" href="SMT.Theory.Class.Solvable.html#3095" class="Function">interpCtxt</a> <a id="3309" href="SMT.Theory.Class.Solvable.html#3283" class="Bound">Γ</a><a id="3310" class="Symbol">)</a>

  <a id="SortTranslation.interpOutputCtxt"></a><a id="3315" href="SMT.Theory.Class.Solvable.html#3315" class="Function">interpOutputCtxt</a> <a id="3332" class="Symbol">:</a> <a id="3334" href="SMT.Script.Base.html#5617" class="Function">CS.OutputCtxt</a> <a id="3348" class="Symbol">→</a> <a id="3350" href="SMT.Script.Base.html#5617" class="Function">VS.OutputCtxt</a>
  <a id="3366" href="SMT.Theory.Class.Solvable.html#3315" class="Function">interpOutputCtxt</a> <a id="3383" class="Symbol">=</a> <a id="3385" href="Data.List.Base.html#1544" class="Function">List.map</a> <a id="3394" href="SMT.Theory.Class.Solvable.html#3164" class="Function">interpOutputType</a>

  <a id="SortTranslation.interpCompileCtxt"></a><a id="3414" href="SMT.Theory.Class.Solvable.html#3414" class="Function">interpCompileCtxt</a> <a id="3432" class="Symbol">:</a> <a id="3434" class="Symbol">∀</a> <a id="3436" href="SMT.Theory.Class.Solvable.html#3436" class="Bound">Γ</a> <a id="3438" class="Symbol">→</a> <a id="3440" href="SMT.Theory.Class.Solvable.html#3095" class="Function">interpCtxt</a> <a id="3451" class="Symbol">(</a><a id="3452" href="SMT.Theory.Class.Solvable.html#2766" class="Function">compileCtxt</a> <a id="3464" href="SMT.Theory.Class.Solvable.html#3436" class="Bound">Γ</a><a id="3465" class="Symbol">)</a> <a id="3467" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="3469" href="SMT.Theory.Class.Solvable.html#3436" class="Bound">Γ</a>
  <a id="3473" href="SMT.Theory.Class.Solvable.html#3414" class="Function">interpCompileCtxt</a> <a id="3491" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="3494" class="Symbol">=</a> <a id="3496" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
  <a id="3503" href="SMT.Theory.Class.Solvable.html#3414" class="Function">interpCompileCtxt</a> <a id="3521" class="Symbol">(</a><a id="3522" href="SMT.Theory.Class.Solvable.html#3522" class="Bound">σ</a> <a id="3524" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3526" href="SMT.Theory.Class.Solvable.html#3526" class="Bound">Γ</a><a id="3527" class="Symbol">)</a> <a id="3529" class="Keyword">rewrite</a> <a id="3537" href="SMT.Theory.Class.Solvable.html#2706" class="Field">interpCompileSort</a> <a id="3555" href="SMT.Theory.Class.Solvable.html#3522" class="Bound">σ</a> <a id="3557" class="Symbol">|</a> <a id="3559" href="SMT.Theory.Class.Solvable.html#3414" class="Function">interpCompileCtxt</a> <a id="3577" href="SMT.Theory.Class.Solvable.html#3526" class="Bound">Γ</a> <a id="3579" class="Symbol">=</a> <a id="3581" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

  <a id="SortTranslation.interpCompileOutputType"></a><a id="3589" href="SMT.Theory.Class.Solvable.html#3589" class="Function">interpCompileOutputType</a> <a id="3613" class="Symbol">:</a> <a id="3615" class="Symbol">∀</a> <a id="3617" href="SMT.Theory.Class.Solvable.html#3617" class="Bound">ξ</a> <a id="3619" class="Symbol">→</a> <a id="3621" href="SMT.Theory.Class.Solvable.html#3164" class="Function">interpOutputType</a> <a id="3638" class="Symbol">(</a><a id="3639" href="SMT.Theory.Class.Solvable.html#2838" class="Function">compileOutputType</a> <a id="3657" href="SMT.Theory.Class.Solvable.html#3617" class="Bound">ξ</a><a id="3658" class="Symbol">)</a> <a id="3660" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="3662" href="SMT.Theory.Class.Solvable.html#3617" class="Bound">ξ</a>
  <a id="3666" href="SMT.Theory.Class.Solvable.html#3589" class="Function">interpCompileOutputType</a> <a id="3690" href="SMT.Script.Base.html#5548" class="InductiveConstructor">VS.SAT</a> <a id="3697" class="Symbol">=</a> <a id="3699" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
  <a id="3706" href="SMT.Theory.Class.Solvable.html#3589" class="Function">interpCompileOutputType</a> <a id="3730" class="Symbol">(</a><a id="3731" href="SMT.Script.Base.html#5569" class="InductiveConstructor">VS.MODEL</a> <a id="3740" href="SMT.Theory.Class.Solvable.html#3740" class="Bound">Γ</a><a id="3741" class="Symbol">)</a> <a id="3743" class="Keyword">rewrite</a> <a id="3751" href="SMT.Theory.Class.Solvable.html#3414" class="Function">interpCompileCtxt</a> <a id="3769" href="SMT.Theory.Class.Solvable.html#3740" class="Bound">Γ</a> <a id="3771" class="Symbol">=</a> <a id="3773" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

  <a id="SortTranslation.interpCompileOutputCtxt"></a><a id="3781" href="SMT.Theory.Class.Solvable.html#3781" class="Function">interpCompileOutputCtxt</a> <a id="3805" class="Symbol">:</a> <a id="3807" class="Symbol">∀</a> <a id="3809" href="SMT.Theory.Class.Solvable.html#3809" class="Bound">Ξ</a> <a id="3811" class="Symbol">→</a> <a id="3813" href="SMT.Theory.Class.Solvable.html#3315" class="Function">interpOutputCtxt</a> <a id="3830" class="Symbol">(</a><a id="3831" href="SMT.Theory.Class.Solvable.html#2993" class="Function">compileOutputCtxt</a> <a id="3849" href="SMT.Theory.Class.Solvable.html#3809" class="Bound">Ξ</a><a id="3850" class="Symbol">)</a> <a id="3852" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="3854" href="SMT.Theory.Class.Solvable.html#3809" class="Bound">Ξ</a>
  <a id="3858" href="SMT.Theory.Class.Solvable.html#3781" class="Function">interpCompileOutputCtxt</a> <a id="3882" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="3885" class="Symbol">=</a> <a id="3887" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
  <a id="3894" href="SMT.Theory.Class.Solvable.html#3781" class="Function">interpCompileOutputCtxt</a> <a id="3918" class="Symbol">(</a><a id="3919" href="SMT.Theory.Class.Solvable.html#3919" class="Bound">ξ</a> <a id="3921" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3923" href="SMT.Theory.Class.Solvable.html#3923" class="Bound">Ξ</a><a id="3924" class="Symbol">)</a> <a id="3926" class="Keyword">rewrite</a> <a id="3934" href="SMT.Theory.Class.Solvable.html#3589" class="Function">interpCompileOutputType</a> <a id="3958" href="SMT.Theory.Class.Solvable.html#3919" class="Bound">ξ</a> <a id="3960" class="Symbol">|</a> <a id="3962" href="SMT.Theory.Class.Solvable.html#3781" class="Function">interpCompileOutputCtxt</a> <a id="3986" href="SMT.Theory.Class.Solvable.html#3923" class="Bound">Ξ</a> <a id="3988" class="Symbol">=</a> <a id="3990" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>


<a id="3997" class="Keyword">record</a> <a id="Translation"></a><a id="4004" href="SMT.Theory.Class.Solvable.html#4004" class="Record">Translation</a> <a id="4016" class="Symbol">(</a><a id="4017" href="SMT.Theory.Class.Solvable.html#4017" class="Bound">virtual</a> <a id="4025" class="Symbol">:</a> <a id="4027" href="SMT.Theory.Base.html#1730" class="Record">Theory</a><a id="4033" class="Symbol">)</a> <a id="4035" class="Symbol">(</a><a id="4036" href="SMT.Theory.Class.Solvable.html#4036" class="Bound">concrete</a> <a id="4045" class="Symbol">:</a> <a id="4047" href="SMT.Theory.Base.html#1730" class="Record">Theory</a><a id="4053" class="Symbol">)</a> <a id="4055" class="Symbol">:</a> <a id="4057" href="Agda.Primitive.html#326" class="Primitive">Set₁</a> <a id="4062" class="Keyword">where</a>
  <a id="4070" class="Keyword">private</a>
    <a id="4082" class="Keyword">module</a> <a id="Translation.VT"></a><a id="4089" href="SMT.Theory.Class.Solvable.html#4089" class="Module">VT</a> <a id="4092" class="Symbol">=</a> <a id="4094" href="SMT.Theory.Base.html#1730" class="Module">Theory</a> <a id="4101" href="SMT.Theory.Class.Solvable.html#4017" class="Bound">virtual</a>
    <a id="4113" class="Keyword">module</a> <a id="Translation.VS"></a><a id="4120" href="SMT.Theory.Class.Solvable.html#4120" class="Module">VS</a> <a id="4123" class="Symbol">=</a> <a id="4125" href="SMT.Script.Base.html" class="Module">SMT.Script.Base</a> <a id="4141" href="SMT.Theory.Class.Solvable.html#4017" class="Bound">virtual</a>
    <a id="4153" class="Keyword">module</a> <a id="Translation.CT"></a><a id="4160" href="SMT.Theory.Class.Solvable.html#4160" class="Module">CT</a> <a id="4163" class="Symbol">=</a> <a id="4165" href="SMT.Theory.Base.html#1730" class="Module">Theory</a> <a id="4172" href="SMT.Theory.Class.Solvable.html#4036" class="Bound">concrete</a>
    <a id="4185" class="Keyword">module</a> <a id="Translation.CS"></a><a id="4192" href="SMT.Theory.Class.Solvable.html#4192" class="Module">CS</a> <a id="4195" class="Symbol">=</a> <a id="4197" href="SMT.Script.Base.html" class="Module">SMT.Script.Base</a> <a id="4213" href="SMT.Theory.Class.Solvable.html#4036" class="Bound">concrete</a>

  <a id="4225" class="Keyword">field</a>
    <a id="Translation.sortTranslation"></a><a id="4235" href="SMT.Theory.Class.Solvable.html#4235" class="Field">sortTranslation</a> <a id="4251" class="Symbol">:</a> <a id="4253" href="SMT.Theory.Class.Solvable.html#2387" class="Record">SortTranslation</a> <a id="4269" href="SMT.Theory.Class.Solvable.html#4017" class="Bound">virtual</a> <a id="4277" href="SMT.Theory.Class.Solvable.html#4036" class="Bound">concrete</a>

  <a id="4289" class="Keyword">open</a> <a id="4294" href="SMT.Theory.Class.Solvable.html#2387" class="Module">SortTranslation</a> <a id="4310" href="SMT.Theory.Class.Solvable.html#4235" class="Field">sortTranslation</a> <a id="4326" class="Keyword">public</a>

  <a id="4336" class="Keyword">field</a>
    <a id="Translation.compileScript"></a><a id="4346" href="SMT.Theory.Class.Solvable.html#4346" class="Field">compileScript</a>     <a id="4364" class="Symbol">:</a> <a id="4366" class="Symbol">∀</a> <a id="4368" class="Symbol">{</a><a id="4369" href="SMT.Theory.Class.Solvable.html#4369" class="Bound">Γ</a> <a id="4371" href="SMT.Theory.Class.Solvable.html#4371" class="Bound">Γ′</a> <a id="4374" href="SMT.Theory.Class.Solvable.html#4374" class="Bound">Ξ</a><a id="4375" class="Symbol">}</a> <a id="4377" class="Symbol">→</a> <a id="4379" href="SMT.Script.Base.html#9148" class="Datatype">VS.Script</a> <a id="4389" href="SMT.Theory.Class.Solvable.html#4369" class="Bound">Γ</a> <a id="4391" href="SMT.Theory.Class.Solvable.html#4371" class="Bound">Γ′</a> <a id="4394" href="SMT.Theory.Class.Solvable.html#4374" class="Bound">Ξ</a> <a id="4396" class="Symbol">→</a> <a id="4398" href="SMT.Script.Base.html#9148" class="Datatype">CS.Script</a> <a id="4408" class="Symbol">(</a><a id="4409" href="SMT.Theory.Class.Solvable.html#2766" class="Function">compileCtxt</a> <a id="4421" href="SMT.Theory.Class.Solvable.html#4369" class="Bound">Γ</a><a id="4422" class="Symbol">)</a> <a id="4424" class="Symbol">(</a><a id="4425" href="SMT.Theory.Class.Solvable.html#2766" class="Function">compileCtxt</a> <a id="4437" href="SMT.Theory.Class.Solvable.html#4371" class="Bound">Γ′</a><a id="4439" class="Symbol">)</a> <a id="4441" class="Symbol">(</a><a id="4442" href="SMT.Theory.Class.Solvable.html#2993" class="Function">compileOutputCtxt</a> <a id="4460" href="SMT.Theory.Class.Solvable.html#4374" class="Bound">Ξ</a><a id="4461" class="Symbol">)</a>
    <a id="Translation.interpOutputs"></a><a id="4467" href="SMT.Theory.Class.Solvable.html#4467" class="Field">interpOutputs</a>     <a id="4485" class="Symbol">:</a> <a id="4487" class="Symbol">∀</a> <a id="4489" class="Symbol">{</a><a id="4490" href="SMT.Theory.Class.Solvable.html#4490" class="Bound">Ξ</a><a id="4491" class="Symbol">}</a> <a id="4493" class="Symbol">→</a> <a id="4495" href="SMT.Script.Base.html#7142" class="Datatype">CS.Outputs</a> <a id="4506" href="SMT.Theory.Class.Solvable.html#4490" class="Bound">Ξ</a> <a id="4508" class="Symbol">→</a> <a id="4510" href="SMT.Theory.Class.Solvable.html#1602" class="Function">InterpError</a> <a id="4522" href="Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="4524" href="SMT.Script.Base.html#7142" class="Datatype">VS.Outputs</a> <a id="4535" class="Symbol">(</a><a id="4536" href="SMT.Theory.Class.Solvable.html#3315" class="Function">interpOutputCtxt</a> <a id="4553" href="SMT.Theory.Class.Solvable.html#4490" class="Bound">Ξ</a><a id="4554" class="Symbol">)</a>


<a id="makeVirtualSolvable"></a><a id="4558" href="SMT.Theory.Class.Solvable.html#4558" class="Function">makeVirtualSolvable</a> <a id="4578" class="Symbol">:</a> <a id="4580" class="Symbol">(</a><a id="4581" href="SMT.Theory.Class.Solvable.html#4581" class="Bound">virtual</a> <a id="4589" class="Symbol">:</a> <a id="4591" href="SMT.Theory.Base.html#1730" class="Record">Theory</a><a id="4597" class="Symbol">)</a> <a id="4599" class="Symbol">→</a> <a id="4601" class="Symbol">(</a><a id="4602" href="SMT.Theory.Class.Solvable.html#4602" class="Bound">concrete</a> <a id="4611" class="Symbol">:</a> <a id="4613" href="SMT.Theory.Base.html#1730" class="Record">Theory</a><a id="4619" class="Symbol">)</a> <a id="4621" class="Symbol">→</a> <a id="4623" class="Symbol">{{</a><a id="4625" href="SMT.Theory.Class.Solvable.html#1752" class="Record">Solvable</a> <a id="4634" href="SMT.Theory.Class.Solvable.html#4602" class="Bound">concrete</a><a id="4642" class="Symbol">}}</a> <a id="4645" class="Symbol">→</a> <a id="4647" href="SMT.Theory.Class.Solvable.html#4004" class="Record">Translation</a> <a id="4659" href="SMT.Theory.Class.Solvable.html#4581" class="Bound">virtual</a> <a id="4667" href="SMT.Theory.Class.Solvable.html#4602" class="Bound">concrete</a> <a id="4676" class="Symbol">→</a> <a id="4678" href="SMT.Theory.Class.Solvable.html#1752" class="Record">Solvable</a> <a id="4687" href="SMT.Theory.Class.Solvable.html#4581" class="Bound">virtual</a>
<a id="4695" href="SMT.Theory.Class.Solvable.html#4558" class="Function">makeVirtualSolvable</a> <a id="4715" href="SMT.Theory.Class.Solvable.html#4715" class="Bound">virtual</a> <a id="4723" href="SMT.Theory.Class.Solvable.html#4723" class="Bound">concrete</a> <a id="4732" href="SMT.Theory.Class.Solvable.html#4732" class="Bound">translation</a> <a id="4744" class="Symbol">=</a> <a id="4746" class="Keyword">record</a> <a id="4753" class="Symbol">{</a>
    <a id="4759" href="SMT.Theory.Class.Solvable.html#1875" class="Field">toSMTLIBWithOutputParser</a> <a id="4784" class="Symbol">=</a> <a id="4786" href="Data.Product.html#2675" class="Function">Prod.map₂</a> <a id="4796" class="Symbol">(λ</a> <a id="4799" href="SMT.Theory.Class.Solvable.html#4799" class="Bound">p</a> <a id="4801" href="SMT.Theory.Class.Solvable.html#4801" class="Bound">s</a> <a id="4803" class="Symbol">→</a> <a id="4805" href="Data.Sum.Base.html#1089" class="Function Operator">[</a> <a id="4807" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="4812" href="Data.Sum.Base.html#1089" class="Function Operator">,</a> <a id="4814" href="Data.Sum.Base.html#1362" class="Function">Sum.map</a> <a id="4822" href="SMT.Theory.Class.Solvable.html#1706" class="InductiveConstructor">interpError</a> <a id="4834" class="Symbol">((</a><a id="4836" href="Relation.Binary.PropositionalEquality.Core.html#1780" class="Function">subst</a> <a id="4842" href="SMT.Script.Base.html#7142" class="Datatype">VS.Outputs</a> <a id="4853" class="Symbol">(</a><a id="4854" href="SMT.Theory.Class.Solvable.html#3781" class="Function">interpCompileOutputCtxt</a> <a id="4878" class="Symbol">_)))</a> <a id="4883" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="4885" href="SMT.Theory.Class.Solvable.html#4467" class="Field">interpOutputs</a> <a id="4899" href="Data.Sum.Base.html#1089" class="Function Operator">]′</a> <a id="4902" class="Symbol">(</a><a id="4903" href="SMT.Theory.Class.Solvable.html#4799" class="Bound">p</a> <a id="4905" href="SMT.Theory.Class.Solvable.html#4801" class="Bound">s</a><a id="4906" class="Symbol">)</a> <a id="4908" class="Symbol">)</a> <a id="4910" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="4912" href="SMT.Theory.Class.Solvable.html#1875" class="Field">toSMTLIBWithOutputParser</a> <a id="4937" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="4939" href="SMT.Theory.Class.Solvable.html#4346" class="Field">compileScript</a>
  <a id="4955" class="Symbol">}</a>
  <a id="4959" class="Keyword">where</a>
    <a id="4969" class="Keyword">open</a> <a id="4974" href="SMT.Theory.Class.Solvable.html#1752" class="Module">Solvable</a> <a id="4983" class="Symbol">{{...}}</a>
    <a id="4995" class="Keyword">open</a> <a id="5000" href="SMT.Theory.Class.Solvable.html#4004" class="Module">Translation</a> <a id="5012" href="SMT.Theory.Class.Solvable.html#4732" class="Bound">translation</a>
    <a id="5028" class="Keyword">module</a> <a id="5035" href="SMT.Theory.Class.Solvable.html#5035" class="Module">VS</a> <a id="5038" class="Symbol">=</a> <a id="5040" href="SMT.Script.Base.html" class="Module">SMT.Script.Base</a> <a id="5056" href="SMT.Theory.Class.Solvable.html#4715" class="Bound">virtual</a>
</pre></body></html>